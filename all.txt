/utilities.py
from .models import User, TokenBase,PasswordResetToken
from fastapi import HTTPException, status, Depends, Request
from typing import Optional
import uuid
from sqlalchemy.orm import Session
import secrets
import random
from jose import jwt,JWTError
import string
from passlib.context import CryptContext
from datetime import datetime,timedelta, timezone
from .database import get_db
from .system_vars import ACCESS_TOKEN_EXPIERY
from fastapi.security import OAuth2PasswordBearer



pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/oauth2form")

SECRET_KEY = "jncksndjc34jrnfkj3493n49DNKcjijno5KMLkMkmL9c9JCInoc"
ALGORITHM = "HS256"

def authenticate_user(email: str, password: str,db : Session):
    user = db.query(User).filter(User.email == email).first()
    if not user or not pwd_context.verify(password, user.password_hash):  # type: ignore
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None, db: Session = Depends(get_db)) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc)   + (expires_delta or timedelta(minutes=30))
    jti = str(uuid.uuid4())
    issued_at = datetime.now(timezone.utc)  

    to_encode.update({
        "exp": expire,
        "iat": issued_at,
        "jti": jti,
        "type": "access",
        })

    user = db.query(User).filter(User.id == to_encode["id"]).first()
    token = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    token_entry = TokenBase(
        jti=jti,
        iat=issued_at,
        user_id=data.get("id"),
        exp=expire,
        token=token,
        revoked=False
    )
    db.add(token_entry)
    db.commit()

    return token

def create_refresh_token(data: dict, expires_delta: timedelta | None = None, db: Session = Depends(get_db)) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc)   + (expires_delta or timedelta(minutes=150))
    jti = str(uuid.uuid4())
    issued_at = datetime.now(timezone.utc)  

    to_encode.update({
        "exp": expire,
        "iat": issued_at,
        "jti": jti,
        "type": "refresh"
    })

    token = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    token_entry = TokenBase(
        jti=jti,
        iat=issued_at,
        user_id=data.get("id"),
        exp=expire,
        token=token,
        revoked=False
    )
    db.add(token_entry)
    db.commit()

  
    return token





def generate_id(len=None):
    """gen any len id, default 36uuid

    Args:
        len (int, optional): lenth of id. Defaults to None.

    Returns:
        str : len passed
    """
    if len is None:
        return str(uuid.uuid4())
    else:

        if len % 2:
            print("cc")

            return f"{secrets.token_hex(len // 2)}{random.choice(string.ascii_letters + string.digits)}"
        return secrets.token_hex(len // 2)

def get_changes(old_obj, new_obj):
    """
    Returns updated object and chenges.
    
    Returns:
        tuple: (updated_old_obj, changes_dict)
        changes_dict is empty if no changes found
    """
    new_data = new_obj.dict(exclude_unset=True)
    changes = {}
    
    for field, new_val in new_data.items():
        old_val = getattr(old_obj, field, None)
        if old_val != new_val:
            changes[field] = {"old": old_val, "new": new_val}
            setattr(old_obj, field, new_val)
    
    return old_obj, changes

def revoke_tokens(request: Request, db: Session) -> str:
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):

 
        return "not logged in"

    token = auth_header.split(" ")[1]

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("id")
        if not user_id:
     
            return "not logged in"
    except JWTError:
        return "not logged in"

    db.query(TokenBase).filter(TokenBase.user_id == user_id).delete()
    db.commit()
    return "bye"


def revoke_tokens_byid(user_id:str, db:Session):
    db.query(TokenBase).filter(TokenBase.user_id == user_id).delete()
    db.commit()



def check_token(token: str, db: Session) -> bool:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        jti = payload.get("jti")
        token_type = payload.get("type")
        if token_type != "access":
            return False
        
       


        token_in_db = db.query(TokenBase).filter_by(jti=jti, revoked=False).first()
        if not token_in_db:

            return False

        if token_in_db.exp < datetime.now(timezone.utc):

            return False

        return True

    except JWTError:
        return False

def get_user_id(token: str, db: Session) -> str | None:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("id")
        return user_id
    except JWTError:
        return None

def get_user_email(token: str, db: Session) -> str | None:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_email = payload.get("sub")
        return user_email
    except JWTError:
        return None
    
def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):

    user_id = get_user_id(token, db)
 
    if not user_id:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized request")

    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not foundd")
    
    return user


def generate_reset_token() -> str:
    
    return f"{secrets.token_urlsafe(8)}-{secrets.token_urlsafe(12)}-{secrets.token_urlsafe(12)}-{secrets.token_urlsafe(12)}-{secrets.token_urlsafe(8)}"


def create_password_reset_token(user_email: str, db: Session) -> str:
    db.query(PasswordResetToken).filter(PasswordResetToken.user_email == user_email).delete()
    
    token = generate_reset_token()
    expires_at = datetime.utcnow() + timedelta(hours=1)
    
    reset_token = PasswordResetToken(token=token, user_email=user_email, expires_at=expires_at, is_used=False)
    
    db.add(reset_token)
    db.commit()
    
    return token


def validate_reset_token(token: str, db: Session) -> Optional[str]:
    """Validate reset token and return user email if valid"""
    reset_token = db.query(PasswordResetToken).filter(PasswordResetToken.token == token, PasswordResetToken.is_used == False, PasswordResetToken.expires_at > datetime.utcnow()).first()
    
    if reset_token:
        return reset_token.user_email 
    return None


/schemas/maintain_dispose.py
from pydantic import BaseModel
from datetime import datetime, date
from typing import Optional
from decimal import Decimal

 

class MaintenanceInitiateReq(BaseModel):
    maintenance_type: Optional[str]
    issue_category: Optional[str]
    priority: Optional[str]
    severity: Optional[str]
    description: Optional[str]

class MaintenanceScheduleReq(BaseModel):
    maintenance_type: Optional[str] = None
    issue_category: Optional[str] = None
    priority: Optional[str] = None
    severity: Optional[str] = None
    description: str
    issue_type: str
    maintenance_date: date
    status: Optional[str] = None

class MaintenanceApproveReq(BaseModel):
    approved: bool = True  


class MaintenanceStartReq(BaseModel):
    notes: Optional[str] = None




class MaintenanceResp(BaseModel):
    id: str
    asset_id: str
    maintenance_type: Optional[str]
    issue_category: Optional[str]
    priority: Optional[str]
    severity: Optional[str]
    description: Optional[str]
    status: str
    request_date: datetime
    maintenance_date: Optional[date]
    resolved_date: Optional[datetime]
    assigned_to: Optional[str]
    notes: Optional[str]

    class Config:
        orm_mode = True


class MaintenanceHistResp(MaintenanceResp):
    requested_by: Optional[str]
    approved_by: Optional[str]

class MaintenanceCompleteReq(BaseModel):
    cost: Optional[float] = None
    outcome: Optional[str] = None
    notes: Optional[str] = None


class MaintenanceCompleteResp(BaseModel):
    id: str
    asset_id: str
    status: str
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    duration: Optional[str]
    cost: Optional[float]
    paid_by: Optional[str]
    outcome: Optional[str]
    notes: Optional[str]

    class Config:
        orm_mode = True

    
#-------------------

class DisposalInitiateReq(BaseModel):
    reason: str
    
class DisposalScheduleReq(BaseModel):
    disposal_date: date
    disposal_method: Optional[str] = None
    
class DisposalApproveReq(BaseModel):
    pass
    
class DisposalExecuteReq(BaseModel):
    proceeds_amount: Optional[Decimal] = None
    disposal_cost: Optional[Decimal] = None
    disposal_method: Optional[str] = None
    remarks: Optional[str] = None
    
class DisposalUndoReq(BaseModel):
    justification: str
    
class DisposalResp(BaseModel):
    msg: str
    
class DisposalHistResp(BaseModel):
    id: str
    asset_id: str
    disposal_method: Optional[str]
    disposal_date: Optional[date]
    approved_by: Optional[str]
    proceeds_amount: Optional[Decimal]
    disposal_cost: Optional[Decimal]
    remarks: Optional[str]
    status: str
    
    class Config:
        from_attributes = True

/schemas/secc.py
from pydantic import BaseModel, EmailStr, Field, validator
from typing import Optional, Dict, Any, List
from datetime import datetime

class LoginRequestSecurity(BaseModel):
    email: EmailStr
    password: str
    fingerprint: str
    remember_me: bool = False
    timezone: Optional[str] = None
    language: Optional[str] = None

class TokenOutSecurity(BaseModel):
    access_token: Optional[str] = None
    refresh_token: Optional[str] = None
    role: Optional[str] = None
    dept_id: Optional[str] = None
    token_type: str
    a_expires: Optional[int] = None
    req_mfa: int = 0
    pass_change: bool = False
    temp_session_token: Optional[str] = None

    class Config:
        from_attributes = True

class MFAVerifyRequest(BaseModel):
    temp_session_token: str
    mfa_code: str

class WhitelistIPRequest(BaseModel):
    mfa_code: str

class DeviceOut(BaseModel):
    id: str
    fingerprint_hash: str
    device_info: Optional[Dict[str, Any]]
    browser: Optional[str]
    os: Optional[str]
    first_seen: datetime
    last_seen: datetime
    is_trusted: bool
    ip_at_registration: Optional[str]

    class Config:
        from_attributes = True

class LoginAttemptOut(BaseModel):
    id: str
    email: str
    ip_address: str
    success: bool
    failure_reason: Optional[str]
    device_info: Optional[Dict[str, Any]]
    browser: Optional[str]
    os: Optional[str]
    timezone: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

class ForcePasswordChangeRequest(BaseModel):
    temp_session_token: str
    new_password: str = Field(..., min_length=8)

class UnlockAccountRequest(BaseModel):
    token: str/schemas/assets.py
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from decimal import Decimal
from datetime import datetime, date
from enum import Enum
from .location import LocationPreview

from ..models import AssetCategory as AssetCategoryEnum
from ..models import AssetStatus as AssetStatusEnum
from ..models  import AssetCondition as AssetConditionEnum
from ..models import TransferStatus as TransferStatusEnum

# Base schemas
class AssetBase(BaseModel):
    name: str
    pic: Optional[str] = None
    other_pics: Optional[Dict[str, Any]] = None
    description: Optional[str] = None
    category: AssetCategoryEnum
    tag_number: Optional[str] = None
    serial_number: Optional[str] = None
    department_id: Optional[str] = None
    department_name: Optional[str] = None
    responsible_officer_id: Optional[str] = None
    responsible_officer_name: Optional[str] = None
    location: Optional[LocationPreview] = None
    status: AssetStatusEnum = AssetStatusEnum.OPERATIONAL
    condition: AssetConditionEnum = AssetConditionEnum.GOOD
    acquisition_date: Optional[date] = None
    acquisition_cost: Decimal
    source_of_funds: Optional[str] = None
    depreciation_rate: Optional[Decimal] = None
    useful_life_years: Optional[int] = None
    is_portable_attractive: bool = False
    insurance_details: Optional[Dict[str, Any]] = None
    maintenance_schedule: Optional[Dict[str, Any]] = None
    specific_attributes: Optional[Dict[str, Any]] = None

class AssetCreate(AssetBase):
    pass

class AssetUpdate(BaseModel):
    description: Optional[str] = None
    tag_number: Optional[str] = None
    pic: Optional[str] = None
    other_pics: Optional[Dict[str, Any]] = None
    serial_number: Optional[str] = None
    responsible_officer_id: Optional[str] = None
    responsible_officer_name: Optional[str] = None
    location: Optional[LocationPreview] = None
    condition: Optional[AssetConditionEnum] = None
    acquisition_date: Optional[date] = None
    acquisition_cost: Optional[Decimal] = None
    source_of_funds: Optional[str] = None
    depreciation_rate: Optional[Decimal] = None
    useful_life_years: Optional[int] = None
    is_portable_attractive: Optional[bool] = None
    insurance_details: Optional[Dict[str, Any]] = None
    maintenance_schedule: Optional[Dict[str, Any]] = None
    specific_attributes: Optional[Dict[str, Any]] = None

class AssetStatusUpdate(BaseModel):
    status: AssetStatusEnum
    remarks: Optional[str] = None

class AssetLocationUpdate(BaseModel):
    location: Optional[LocationPreview] = None
    remarks: Optional[str] = None

# Responses
class AssetResponse(AssetBase):
    id: str
    barcode: Optional[str] = None
    qr_code: Optional[str] = None
    current_value: Optional[Decimal] = None
    disposal_date: Optional[date] = None
    disposal_value: Optional[Decimal] = None
    disposal_method: Optional[str] = None
    revaluation_history: Optional[Dict[str, Any]] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_deleted: bool = False
    
    department_name: Optional[str] = None
    responsible_officer_name: Optional[str] = None

    class Config:
        from_attributes = True

class AssetListResponse(BaseModel):
    assets: List[AssetResponse]
    total: int
    page: int
    size: int
    total_pages: int

# Transfer
class AssetTransfereInitiate(BaseModel):
    asset_id: str
    to_user_id: Optional[str] = None
    to_dept_id: Optional[str] = None
    transfer_reason: Optional[str] = None
    remarks: Optional[str] = None

class AssetTransferResponse(BaseModel):
    id: int
    asset_id: str
    from_user_id: Optional[str] = None
    to_user_id: Optional[str] = None
    from_dept_id: Optional[str] = None
    to_dept_id: Optional[str] = None
    initiated_by: str
    initiated_date: datetime
    approved_by: Optional[str] = None
    approval_date: Optional[datetime] = None
    completed_date: Optional[datetime] = None
    status: TransferStatusEnum
    transfer_reason: Optional[str] = None
    remarks: Optional[str] = None
    
    asset_description: Optional[str] = None
    from_user_name: Optional[str] = None
    to_user_name: Optional[str] = None

    class Config:
        from_attributes = True

class TransferApproval(BaseModel):
    approve: bool
    remarks: Optional[str] = None

# Lifecycle
class AssetLifecycleEventResponse(BaseModel):
    id: int
    asset_id: str
    event_type: str
    event_date: datetime
    performed_by: Optional[str] = None
    details: Optional[Dict[str, Any]] = None
    remarks: Optional[str] = None
    performed_by_name: Optional[str] = None

    class Config:
        from_attributes = True

# Search
class AssetSearchParams(BaseModel):
    query: Optional[str] = None
    category: Optional[AssetCategoryEnum] = None
    status: Optional[AssetStatusEnum] = None
    condition: Optional[AssetConditionEnum] = None
    department_id: Optional[str] = None
    responsible_officer_id: Optional[str] = None
    location: Optional[LocationPreview] = None
    min_value: Optional[Decimal] = None
    max_value: Optional[Decimal] = None
    acquisition_date_from: Optional[date] = None
    acquisition_date_to: Optional[date] = None
    page: int = 1
    size: int = 20
    sort_by: Optional[str] = "created_at"
    sort_order: Optional[str] = "desc"

class TransSearchParams(BaseModel):
    u_from: Optional[str] = None
    d_from: Optional[str] = None
    u_to: Optional[str] = None
    d_to: Optional[str] = None
    init_by: Optional[str] = None
    f_init_date: Optional[date] = None
    t_init_date: Optional[date] = None
    approv_by: Optional[str] = None
    f_approv_date: Optional[date] = None
    t_approv_date: Optional[date] = None
    status: Optional[str] = None

# QR,bar code
class QRCodeResponse(BaseModel):
    qr_code_data: str
    qr_code_image_url: Optional[str] = None

class BarcodeResponse(BaseModel):
    barcode: str
    barcode_image_url: Optional[str] = None

# Reports
class AssetSummaryReport(BaseModel):
    total_assets: int
    total_value: Decimal
    by_category: Dict[str, Dict[str, Any]]
    by_status: Dict[str, Dict[str, Any]]
    by_condition: Dict[str, Dict[str, Any]]

class DepartmentAssetReport(BaseModel):
    department_id: str
    department_name: str
    total_assets: int
    total_value: Decimal
    assets_by_category: Dict[str, int]
    assets_by_status: Dict[str, int]
    top_assets: List[AssetResponse]

# oth
class CategoryFieldInfo(BaseModel):
    field_name: str
    field_type: str
    required: bool
    description: Optional[str] = None

class CategoryInfo(BaseModel):
    category: str
    description: str
    fields: List[CategoryFieldInfo]
    sample_attributes: Optional[Dict[str, Any]] = None

class AssignAssetUserDep(BaseModel):
    user_id : Optional[str] = None
    dept_id : Optional[str] = None/schemas/__init__.py
/schemas/location.py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict
 


class Ward(BaseModel):
    name: str

class Constituency(BaseModel):
    constituency_name: str
    wards: List[str]

class County(BaseModel):
    county_code: int
    county_name: str
    constituencies: List[Constituency]

class CountySimple(BaseModel):
    county_code: int
    county_name: str

class ConstituencySimple(BaseModel):
    constituency_name: str

class WardResponse(BaseModel):
    county_name: str
    constituency_name: str
    wards: List[str]

class Coordinates(BaseModel):
    lat: Optional[float] = Field(None, example=-0.7832) 
    lng: Optional[float] = Field(None, example=37.0400)


class AdministrativeLocation(BaseModel):
    county: Optional[str] = Field(None, example="Murang'a")
    constituency: Optional[str] = Field(None, example="Kandara")
    ward: Optional[str] = Field(None, example="Ithiru")

class LocationDetails(BaseModel):
    coordinates: Coordinates
    address: Optional[str] = Field(None, example="Kangari Market, Murang'a")
    administrative: AdministrativeLocation

class SearchResult(BaseModel):
    counties: List[CountySimple] = []
    constituencies: List[Dict[str, str]] = [] 
    wards: List[Dict[str, str]] = []


class LocationPreview(BaseModel):
    administrative_location: Optional[AdministrativeLocation] = None
    coordinates: Optional[Coordinates] = None
    address: Optional[str] = Field(None, example="Kangari Market, Murang'a")

    class Config:
        schema_extra = {
            "example": {
                "administrative_location": {
                    "county": "Murang'a",
                    "constituency": "Kandara",
                    "ward": "Ithiru"
                },
                "coordinates": {
                    "lat": -0.7832,
                    "lng": 37.0400
                },
                "address": "Kangari Market, Murang'a"
            }
        }/schemas/main.py
from pydantic import BaseModel, Field, EmailStr
from typing import Dict, Any, Optional, ClassVar,List,Union
import enum
from datetime import datetime
from ..models import GovLevel, EntityType
from .location import LocationPreview

class LogLevel(str,  enum.Enum):
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

class ActionType(str,  enum.Enum):
    CREATE = "create"
    UPDATE = "update"
    DELETE = "delete"
    LOGIN = "login"
    LOGOUT = "logout"
    VIEW = "view"
    EXPORT = "export"
    IMPORT = "import"
    INVENTORY_ADD = "inventory_add"
    INVENTORY_REMOVE = "inventory_remove"
    SALE_RECORD = "sale_record"
    PERMISSION_DENIED ="permission_denied"
    PASSWORD_CHANGE = "password_change"
    PASSWORD_RESET_REQUEST = "password_reset_request" 
    PASSWORD_RESET_COMPLETE = "password_reset_complete"
    TWO_FA_SENT = "two_fa_sent"
    TWO_FA_VERIFIED = "two_fa_verified"
    TWO_FA_FAILED = "two_fa_failed"
    NEW_DEVICE_DETECTED = "new_device_detected"
    NEW_IP_DETECTED = "new_ip_detected"
    ACCOUNT_LOCKED = "account_locked"
    ACCOUNT_UNLOCKED = "account_unlocked"
    SUSPICIOUS_ACTIVITY = "suspicious_activity"
    SESSION_HIJACK_DETECTED = "session_hijack_detected"
    FORCED_LOGOUT = "forced_logout"
    WORKING_HOURS_VIOLATION = "working_hours_violation"
    BRUTE_FORCE_DETECTED = "brute_force_detected"
    IP_BANNED = "ip_banned"
    ADMIN_OVERRIDE = "admin_override"
    CONCURRENT_SESSION_WARNING = "concurrent_session_warning"
    DEVICE_TRUSTED = "device_trusted"

class UserStatus(str, enum.Enum):
    active = "active"
    inactive = "inactive"
    deleted = "deleted"
    suspended = "suspended"

class UserStatus2(str, enum.Enum):
    active = "active"
    suspended = "suspended"

class AuthMethod(str, enum.Enum):
    password = "password"
    oauth = "oauth"
    sso = "sso"

 
class RoleOutt(BaseModel):
    # id: str
    name: str
    description: str
    # permissions: dict[str, list[str]]

    class Config:
        from_attributes = True

class RoleOuttid(BaseModel):
    id: str
    name: str
    description: str
    # permissions: dict[str, list[str]]

    class Config:
        from_attributes = True

    

class ChangePassword(BaseModel):
    old_password: str
    old_password2: str
    new_password: str
class PasswordReset(BaseModel):
    token: str
    new_password: str

class PasswordResetRequest(BaseModel):
    email: str
    
class PasswordResetResponse(BaseModel):
    message: str
    success: bool

    
class CreateUser(BaseModel):
    profile_pic: Optional[str] = "http://profile.com/some/pic/here"
    first_name: Optional[str] = Field(None, min_length=2, max_length=100)
    last_name: Optional[str] = Field(None, min_length=2, max_length=100)
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = "25412345678"
    department_id: Optional[str] = None
    # role_id: str
    position_title: Optional[str] = "member"
    gov_level: Optional[GovLevel] = GovLevel.county
    entity_type: Optional[EntityType] = EntityType.department
    entity_name: Optional[str] = None
    location: Optional[LocationPreview] = None
    notes: Optional[str] = None
    password:  str = Field(..., min_length=6, max_length=30)  
    class Config:
        from_attributes = True

class ChangeUserStatus(BaseModel):
    status: UserStatus2 = UserStatus2.suspended

class NoChangesResponse(BaseModel):
    detail: str
class CreateUserAdmin(CreateUser):
    password: ClassVar[None] = None
    role_id: Optional[str] = None
    status: Optional[str] = None

class PatchUserAdmin(CreateUser):
    password: ClassVar[None] = None
    role_id: ClassVar[None] = None
 
class UserOut(CreateUser):  
    password: ClassVar[None] = None  
    role_id: ClassVar[None] = None
    status: Optional[str] = None
    id: str

    created_at : datetime
    updated_at : Optional[datetime] = None
    
class UserOutProfile(UserOut):
    status: str
    role: RoleOuttid
    is_department_head: Optional[bool] = False 
    created_at : datetime

    updated_at : Optional[datetime] = None
    last_login :Optional[datetime] = None
    last_activity_at: Optional[datetime] = None
    last_password_change: Optional[datetime] = None
    access_scope: Union [Dict[str, Any],str]


class GivePerms(BaseModel):
    permissions: list[str]


class AdminUpdateUser(BaseModel):
    status: UserStatus
    role_id: str
    email: EmailStr
    is_active: bool = False


class ModifyProfile(BaseModel):
    profile_pic: Optional[str] = None
    # email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    phone: Optional[str] = None

class UserNameOut(BaseModel):
    username: str


class DeleteUser(BaseModel):
    status: UserStatus
    is_active: bool = False


class UsersWithRoleX(BaseModel):
    id:str
    first_name:str
    entity_name:str
    email: EmailStr



class UserOutWithRole(UserOut):
    status: UserStatus
    role: Optional[RoleOutt] = None

class TokenOut(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str
    a_expires: int

class TokenOutId(TokenOut):
    role:str
    dept_id:str
    
class LoginRequest(BaseModel):
    email: EmailStr
    password: str
    remember_me: bool = False
# ---------------------------[ ROLES ]--------------------------
class RoleCreate(BaseModel):
    name: str = Field(..., example="admin")  # type: ignore
    description:str
    permissions: List[str] = Field(
        ...,  # type: ignore
        example={
            "resource.action","resource.action2","resource2.action"
           }
    )

class RoleOut(BaseModel):
    id:str
    description:str
    name: str = Field(..., example="admin")  # type: ignore
    permissions: List[str] = Field(
        ...,  # type: ignore
        example={
            "resource.action","resource.action2","resource2.action"
           }
    )
class RoleUpdate(BaseModel):
    name: Optional[str]
    description: Optional[str]
    permissions: Optional[List[str]]



class CreateDepartment(BaseModel):
    name : Optional[str] = None 
    parent_dept_id : Optional[str] = None 
    entity_type : Optional[EntityType] = EntityType.department 
    description : Optional[str] = None 

class DepartmentDetails(BaseModel):
    dept_id : str    
    name : Optional[str] = None 
    parent_dept_id : Optional[str] = None 
    entity_type : Optional[EntityType] = EntityType.department 
    description : Optional[str] = None 
    status : Optional[UserStatus] = UserStatus.active  

class DepartmentDetailsSimple(BaseModel):
    dept_id : str    
    name : Optional[str] = None 

class DepartmentDetailsPublic(BaseModel):
    dept_id : str
    name : Optional[str] = None
    entity_type : Optional[EntityType] = EntityType.department

class DepartmentStatus(BaseModel):
    status: UserStatus2 = UserStatus2.active
class DepartmentUsers(UsersWithRoleX):
    position_title: Optional[str] = None /asset_utils.py

from typing import Dict, Any, Optional, List
from decimal import Decimal
from datetime import datetime, date
from pydantic import BaseModel, validator
from enum import Enum
from .models import Assets


def add_namedep_asset(asset: Assets) -> dict:
    return {
        **asset.__dict__,
        "department_name": asset.department.name if asset.department else None,
        "responsible_officer_name": (
            asset.responsible_officer.full_name if asset.responsible_officer else None
        ),
    }

class StandardAssetAttributes(BaseModel):
    make_model: Optional[str] = None
    date_of_delivery: Optional[date] = None
    payment_voucher_number: Optional[str] = None
    original_location: Optional[str] = None
    replacement_date: Optional[date] = None
    notes: Optional[str] = None

class LandAttributes(BaseModel):
    gps_coordinates: Optional[str] = None
    polygon_coordinates: Optional[Dict] = None 
    lr_certificate_no: Optional[str] = None
    document_of_ownership: Optional[str] = None
    proprietorship_details: Optional[str] = None
    
    # Land Specific Details
    size_hectares: Optional[Decimal] = None
    ownership_status: Optional[str] = None  # Freehold/Leasehold
    registration_date: Optional[date] = None
    disputed_status: Optional[str] = None  # Disputed/Undisputed
    encumbrances: Optional[str] = None
    planned_unplanned: Optional[str] = None
    purpose_use_of_land: Optional[str] = None
    surveyed_status: Optional[str] = None  # Surveyed/Not Surveyed
    
    change_of_use_date: Optional[date] = None
    annual_rental_income: Optional[Decimal] = None
  

class BuildingAttributes(BaseModel):
    building_ownership: Optional[str] = None
    building_no: Optional[str] = None
    institution_no: Optional[str] = None
    street: Optional[str] = None
    lr_no: Optional[str] = None
    
    size_of_land_ha: Optional[Decimal] = None
    ownership_status: Optional[str] = None  # Freehold/Leasehold
    building_construction_date: Optional[date] = None
    lease_start_date: Optional[date] = None
    type_of_building: Optional[str] = None  # Permanent/Temporary
    designated_use: Optional[str] = None
    period_of_lease: Optional[int] = None
    no_of_floors: Optional[int] = None
    plinth_area_sq_feet: Optional[Decimal] = None

    cost_of_construction: Optional[Decimal] = None
    valuation: Optional[Decimal] = None
    annual_rental_income: Optional[Decimal] = None

def get_category_schema(category: str) -> Optional[BaseModel]:
    """Get the appropriate schema for a given asset category"""
    schema_mapping = {
        "Standard Assets": StandardAssetAttributes,
        "Land": LandAttributes,
        "Buildings and building improvements": BuildingAttributes,
    }
    return schema_mapping.get(category)

def validate_category_attributes(category: str, attributes: Dict[str, Any]) -> Dict[str, Any]:
    """Validate category-specific attributes against their schema"""
    schema_class = get_category_schema(category)
    if not schema_class:
        # if not implemented  return as it s
        return attributes
    
    try:
        validated = schema_class(**attributes)
        return validated.dict(exclude_none=True)
    except Exception as e:
        raise ValueError(f"Invalid attributes for category {category}: {str(e)}")

def get_required_fields(category: str) -> List[str]:
    """Get required fields for a specific asset category"""
    required_fields_mapping = {
        "Standard Assets": ["asset_description", "acquisition_cost_kshs"],
        "Land": ["description_of_land", "size_hectares", "county"],
        "Buildings and building improvements": ["description_name_of_building", "type_of_building", "county"]
    }
    return required_fields_mapping.get(category, [])

def get_default_attributes(category: str) -> Dict[str, Any]:
    """Get default attributes structure for a category"""
    schema_class = get_category_schema(category)
    if not schema_class:
        return {}
    
    # Return empty instance of schema as dict
    return schema_class().dict()

def format_attributes_for_display(category: str, attributes: Dict[str, Any]) -> Dict[str, Any]:
    """Format category-specific attributes for display purposes"""
    if not attributes:
        return {}
     
    formatted = {}
    for key, value in attributes.items():
        if value is not None:
            
            display_key = key.replace('_', ' ').title() #change case to normal
   
            if isinstance(value, Decimal):
                formatted[display_key] = f"KES {value:,.2f}"
            elif isinstance(value, date):
                formatted[display_key] = value.strftime("%Y-%m-%d")
            elif isinstance(value, str) and key.endswith('_date'):
                formatted[display_key] = value
            else:
                formatted[display_key] = value
    
    return formatted

def extract_searchable_text(category: str, attributes: Dict[str, Any]) -> str:
    """Extract searchable text from category-specific attributes"""
    if not attributes:
        return ""
    
    searchable_fields = {
        "Standard Assets": ["asset_description", "make_model", "serial_number"],
        "Land": ["description_of_land", "nearest_town_location", "lr_certificate_no"],
        "Buildings and building improvements": ["description_name_of_building", "street", "designated_use"]
    }
    
    fields = searchable_fields.get(category, list(attributes.keys()))
    searchable_values = []
    
    for field in fields:
        if field in attributes and attributes[field]:
            searchable_values.append(str(attributes[field]))
    
    return " ".join(searchable_values)

def calculate_depreciation(
    acquisition_cost: Decimal, 
    depreciation_rate: Decimal, 
    acquisition_date: date,
    calculation_date: Optional[date] = None
) -> Dict[str, Decimal]:
    """calc depreciation vals"""
    if calculation_date is None:
        calculation_date = date.today()
    
    years_elapsed = Decimal((calculation_date - acquisition_date).days) / Decimal("365.25")
    annual_depreciation = acquisition_cost * (depreciation_rate / Decimal("100"))
    accumulated_depreciation = min(annual_depreciation * years_elapsed, acquisition_cost)
    net_book_value = acquisition_cost - accumulated_depreciation
    
    return {
        "annual_depreciation": annual_depreciation,
        "accumulated_depreciation": accumulated_depreciation,
        "net_book_value": net_book_value
    }

def generate_tag_number(category: str, department_code: str, sequence: int) -> str:
    """Generate asset tag number based on category and department"""
    category_codes = {
        "Standard Assets": "STD",
        "Land": "LND", 
        "Buildings and building improvements": "BLD",
        "ICT_EQUIPMENT": "ICT",
        "MOTOR_VEHICLES": "VEH"
    }
    
    category_code = category_codes.get(category, "AST")
    return f"{category_code}-{department_code}-{sequence:05d}"

def get_category_specific_reports_fields(category: str) -> List[Dict[str, str]]:
    """Get fields that should be included in reports for specific categories"""
    report_fields = {
        "Land": [
            {"field": "lr_certificate_no", "label": "L.R. Certificate No."},
            {"field": "size_hectares", "label": "Size (Ha)"},
            {"field": "ownership_status", "label": "Ownership Status"},
            {"field": "county", "label": "County"}
        ],
        "Buildings and building improvements": [
            {"field": "type_of_building", "label": "Building Type"},
            {"field": "no_of_floors", "label": "No. of Floors"},
            {"field": "plinth_area_sq_feet", "label": "Plinth Area (Sq Ft)"},
            {"field": "county", "label": "County"}
        ],
        "Standard Assets": [
            {"field": "make_model", "label": "Make & Model"},
            {"field": "serial_number", "label": "Serial Number"},
            {"field": "asset_condition", "label": "Condition"}
        ]
    }
    
    return report_fields.get(category, [])/sec_utils.py
import os
import hashlib
import secrets
import requests
from typing import Tuple, List, Optional
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from sqlalchemy import and_

from .models import User, DeviceFingerprint, IPWhitelist, LoginAttempt, TempDisableLog, UserStatus
from .system_vars import (
    FRAUD_SCORE_LIMIT, TEMP_DISABLE_DURATION_HOURS, PASSWORD_EXPIRY_DAYS,
    WORKING_HOURS_START, WORKING_HOURS_END, INACTIVE_ACCOUNT_DAYS,
    MFA_CODE_LENGTH, TEMP_SESSION_TOKEN_EXPIRY_MINUTES, UNLOCK_ACCOUNT_TOKEN_EXPIRY_MINUTES
)
from .utilities import generate_id, SECRET_KEY, ALGORITHM

load_dotenv(dotenv_path="./fapi/.env")
ABUSEDB_KEY = os.getenv("ABUSEDB_KEY")
SECRET_KEY_FP = os.getenv("SECRET_KEY_FP", "default_fp_secret_key_change_me")


def check_ip_det(ip: str) -> Tuple[bool, str]:
    if not ABUSEDB_KEY:
        return True, "missing ABUSEDB_KEY"

    url = "https://api.abuseipdb.com/api/v2/check"
    params = {"ipAddress": ip, "maxAgeInDays": "90"}
    headers = {"Accept": "application/json", "Key": ABUSEDB_KEY}

    try:
        resp = requests.get(url, headers=headers, params=params, timeout=6)
        resp.raise_for_status()
        payload = resp.json().get("data", {})
    except Exception as e:
        return True, f"abusedb_error: {e}"

    country = (payload.get("countryCode") or "").upper()
    hostnames = payload.get("hostnames") or []
    usage = (payload.get("usageType") or "").lower()
    isp = (payload.get("isp") or "").lower()
    domain = (payload.get("domain") or "").lower()
    is_tor = payload.get("isTor") is True
    abuse_score = int(payload.get("abuseConfidenceScore") or 0)

    reasons = []
    suspicious = False

    if is_tor or any(k in isp for k in ("vpn", "proxy")) or any(k in domain for k in ("vpn", "proxy", "tor")):
        suspicious = True
        reasons.append("vpn/proxy/tor detected")

    if any(k in usage for k in ("data center", "datacenter", "web hosting", "hosting", "transit")):
        suspicious = True
        reasons.append(f"hosting/datacenter ({usage or 'unknown'})")

    if hostnames:
        suspicious = True
        reasons.append(f"hostnames: {', '.join(hostnames)}")

    if country and country != "KE":
        suspicious = True
        reasons.append(f"foreign country: {country}")

    if abuse_score > FRAUD_SCORE_LIMIT:
        suspicious = True
        reasons.append(f"abuse_score: {abuse_score}")

    summary = f"isp: {isp or payload.get('isp')}, country: {country or 'unknown'}, abuse_score: {abuse_score}, usage: {usage or 'unknown'}"
    return (suspicious, "; ".join(reasons) if reasons else summary)


def hash_fingerprint(fingerprint: str) -> str:
    if not fingerprint:
        return ""
    
    salted = f"{fingerprint}{SECRET_KEY_FP}"
 
    hash_obj = hashlib.sha256(salted.encode('utf-8'))
    
    return hash_obj.hexdigest()


def is_device_known(user_id: str, fingerprint_hash: str, db: Session) -> bool:

    device = db.query(DeviceFingerprint).filter(
        and_(
            DeviceFingerprint.user_id == user_id,
            DeviceFingerprint.fingerprint_hash == fingerprint_hash,
            DeviceFingerprint.is_deleted == False
        )
    ).first()
    
    return device is not None

def is_ip_whitelisted(user_id: str, ip_address: str, db: Session) -> bool:
    whitelist = db.query(IPWhitelist).filter(
        and_(
            IPWhitelist.user_id == user_id,
            IPWhitelist.ip_address == ip_address
        )
    ).first()
    
    return whitelist is not None


def temp_disable_account(user: User, reason: str, db: Session) -> None:
    disabled_until = datetime.now(timezone.utc) + timedelta(hours=TEMP_DISABLE_DURATION_HOURS)
    
    user.status = UserStatus.temp_disabled
    user.temp_disabled_until = disabled_until
    
    log_entry = TempDisableLog(
        id=generate_id(),
        user_id=user.id,
        reason=reason,
        disabled_until=disabled_until,
        is_active=True
    )
    
    db.add(log_entry)
    db.commit()


def deactivate_account(user: User, reason: str, db: Session) -> None:
    user.status = UserStatus.suspended
    user.temp_disabled_until = None

    log_entry = TempDisableLog(
        id=generate_id(),
        user_id=user.id,
        reason=f"SUSPENDED: {reason}",
        disabled_until=datetime.now(timezone.utc) + timedelta(days=36500),
        is_active=True
    )
    
    db.add(log_entry)
    db.commit()


def is_account_temp_disabled(user: User) -> bool:
    if user.status != UserStatus.temp_disabled:
        return False
    
    if not user.temp_disabled_until:
        return False

    if datetime.now(timezone.utc) >= user.temp_disabled_until:
        return False
    
    return True


def get_failed_attempts_count(user_id: str, since_datetime: datetime, db: Session) -> int:
    count = db.query(LoginAttempt).filter(
        and_(
            LoginAttempt.user_id == user_id,
            LoginAttempt.success == False,
            LoginAttempt.timestamp >= since_datetime
        )
    ).count()
    
    return count


def count_successful_logins_from_ip(user_id: str, ip_address: str, db: Session) -> int:
    count = db.query(LoginAttempt).filter(
        and_(
            LoginAttempt.user_id == user_id,
            LoginAttempt.ip_address == ip_address,
            LoginAttempt.success == True
        )
    ).count()
    
    return count


def check_last_login_expiry(user: User) -> bool:
    if not user.last_login:
        return True
    
    days_since_login = (datetime.now(timezone.utc) - user.last_login).days
    
    return days_since_login >= INACTIVE_ACCOUNT_DAYS


def check_password_expiry(user: User) -> bool:
    if not user.last_password_change:
        if not user.created_at:
            return True
        
        days_since_creation = (datetime.now(timezone.utc) - user.created_at).days
        return days_since_creation >= PASSWORD_EXPIRY_DAYS
    
    days_since_change = (datetime.now(timezone.utc) - user.last_password_change).days
    
    return days_since_change >= PASSWORD_EXPIRY_DAYS


def is_within_working_hours() -> bool:
    eat_offset = timedelta(hours=3)
    current_time_eat = datetime.now(timezone.utc) + eat_offset
    
    current_hour = current_time_eat.hour

    return WORKING_HOURS_START <= current_hour < WORKING_HOURS_END


def generate_mfa_code() -> str:
    code = ''.join([str(secrets.randbelow(10)) for _ in range(MFA_CODE_LENGTH)])
    
    return code


def create_temp_session_token(user_id: str, email: str) -> str:

    expire = datetime.now(timezone.utc) + timedelta(minutes=TEMP_SESSION_TOKEN_EXPIRY_MINUTES)
    jti = generate_id()
    issued_at = datetime.now(timezone.utc)
    
    payload = {
        "user_id": user_id,
        "email": email,
        "exp": expire,
        "iat": issued_at,
        "jti": jti,
        "type": "temp_sess"
    }
    
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    
    return token


def decode_temp_session_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        
        if payload.get("type") != "temp_sess":
            return None
        
        exp = payload.get("exp")
        if exp and datetime.fromtimestamp(exp, tz=timezone.utc) < datetime.now(timezone.utc):
            return None
        
        return payload
    
    except JWTError:
        return None


def create_unlock_account_token(user_id: str, user_email: str) -> str:

    expire = datetime.now(timezone.utc) + timedelta(minutes=UNLOCK_ACCOUNT_TOKEN_EXPIRY_MINUTES)
    jti = generate_id()
    issued_at = datetime.now(timezone.utc)
    
    payload = {
        "user_id": user_id,
        "email": user_email,
        "exp": expire,
        "iat": issued_at,
        "jti": jti,
        "type": "u_acc"
    }
    
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    
    return token


def decode_unlock_account_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") != "u_acc":
            return None
        
        exp = payload.get("exp")
        if exp and datetime.fromtimestamp(exp, tz=timezone.utc) < datetime.now(timezone.utc):
            return None
        
        return payload
    
    except JWTError:
        return None


def get_dept_heads(user: User, db: Session) -> List[User]:
    from .models import Departments
    
    if not user.department_id:
        return []
    
    department = db.query(Departments).filter(
        Departments.dept_id == user.department_id
    ).first()
    
    if not department:
        return []
    
    heads = []
    if department.department_head_id:
        head = db.query(User).filter(User.id == department.department_head_id).first()
        if head:
            heads.append(head)

    if department.deputy_head_id:
        deputy = db.query(User).filter(User.id == department.deputy_head_id).first()
        if deputy:
            heads.append(deputy)
    
    return heads


def system_notification_handler(to_users: List[str], msg: str) -> None:
    """
    for de fucha.
    
    Args:
        to_users: List user types n roles (e.g., ["security", "dept_head", "me"])# expound for edge
        msg: notifiction message
    """
    # in  messages and email
    # This could send in-app notifications, emails, SMS, etc.
    pass/migrations/versions/084eb931f64e_add_fields_mainanance_and_disposal.py
"""add fields mainanance and disposal

Revision ID: 084eb931f64e
Revises: 1eb44413307a
Create Date: 2025-09-12 19:20:14.453033
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision: str = '084eb931f64e'
down_revision: Union[str, Sequence[str], None] = '1eb44413307a'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# Explicit enum type
disposal_status_enum = sa.Enum(
    'INITIATED',
    'SCHEDULED',
    'APPROVED',
    'EXECUTED',
    'CANCELLED',
    'UNDONE',
    name='disposalstatus'
)

maintenance_status_enum = sa.Enum(
    'INITIATED',
    'SCHEDULED',
    'APPROVED',
    'IN_PROGRESS',
    'COMPLETED',
    'CANCELLED',
    name='maintenancestatus'
)

def upgrade() -> None:
    """Upgrade schema."""
    # create enums first
    disposal_status_enum.create(op.get_bind(), checkfirst=True)
    maintenance_status_enum.create(op.get_bind(), checkfirst=True)

    # asset_disposals.status
    op.add_column(
        'asset_disposals',
        sa.Column('status', disposal_status_enum, nullable=True)
    )
    op.create_index(
        op.f('ix_asset_disposals_status'),
        'asset_disposals',
        ['status'],
        unique=False
    )

    # assets.department_id -> nullable
    op.alter_column(
        'assets',
        'department_id',
        existing_type=sa.VARCHAR(length=60),
        nullable=True
    )

    # maintenance_requests.maintenance_date
    op.add_column(
        'maintenance_requests',
        sa.Column('maintenance_date', sa.DateTime(), nullable=True)
    )

    # maintenance_requests.status type change
    op.alter_column(
        "maintenance_requests",
        "status",
        type_=sa.Enum("PENDING", "IN_PROGRESS", "COMPLETED", "CANCELLED", name="maintenancestatus"),
        postgresql_using="status::maintenancestatus"
    )

    op.create_index(
        op.f('ix_maintenance_requests_status'),
        'maintenance_requests',
        ['status'],
        unique=False
    )


def downgrade() -> None:
    """Downgrade schema."""
    op.drop_index(op.f('ix_maintenance_requests_status'), table_name='maintenance_requests')
    op.alter_column(
        'maintenance_requests',
        'status',
        existing_type=maintenance_status_enum,
        type_=sa.VARCHAR(length=20),
        existing_nullable=True
    )
    op.drop_column('maintenance_requests', 'maintenance_date')

    op.alter_column(
        'assets',
        'department_id',
        existing_type=sa.VARCHAR(length=60),
        nullable=False
    )

    op.drop_index(op.f('ix_asset_disposals_status'), table_name='asset_disposals')
    op.drop_column('asset_disposals', 'status')

    # drop enums last
    disposal_status_enum.drop(op.get_bind(), checkfirst=True)
    maintenance_status_enum.drop(op.get_bind(), checkfirst=True)
/migrations/versions/4b4ff2e9b42b_add_audit_relations_asset.py
"""add audit relations asset

Revision ID: 4b4ff2e9b42b
Revises: 0255751c95d5
Create Date: 2025-09-03 09:58:03.388550

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '4b4ff2e9b42b'
down_revision: Union[str, Sequence[str], None] = '0255751c95d5'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('assets', sa.Column('checked_by', sa.String(length=60), nullable=True))
    op.add_column('assets', sa.Column('authorized_by', sa.String(length=60), nullable=True))
    op.create_foreign_key(None, 'assets', 'users', ['authorized_by'], ['id'])
    op.create_foreign_key(None, 'assets', 'users', ['checked_by'], ['id'])
    op.alter_column('users', 'location_code',
               existing_type=sa.VARCHAR(length=30),
               type_=sa.String(length=500),
               existing_nullable=True)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('users', 'location_code',
               existing_type=sa.String(length=500),
               type_=sa.VARCHAR(length=30),
               existing_nullable=True)
    op.drop_constraint(None, 'assets', type_='foreignkey')
    op.drop_constraint(None, 'assets', type_='foreignkey')
    op.drop_column('assets', 'authorized_by')
    op.drop_column('assets', 'checked_by')
    # ### end Alembic commands ###
/migrations/versions/8b0aa51b8226_jange_locations_from_string_to_json.py
"""jange locations from string to json

Revision ID: 8b0aa51b8226
Revises: 4b4ff2e9b42b
Create Date: 2025-09-03 12:25:07.334743

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '8b0aa51b8226'
down_revision: Union[str, Sequence[str], None] = '4b4ff2e9b42b'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('assets', 'location',
               existing_type=sa.VARCHAR(length=255),
               type_=sa.JSON(),
               existing_nullable=True,
               postgresql_using="NULL")
    op.add_column('users', sa.Column('location', sa.JSON(), nullable=True))
    op.drop_column('users', 'location_code')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('location_code', sa.VARCHAR(length=500), autoincrement=False, nullable=True))
    op.drop_column('users', 'location')
    op.alter_column('assets', 'location',
               existing_type=sa.JSON(),
               type_=sa.VARCHAR(length=255),
               existing_nullable=True)
    # ### end Alembic commands ###
/migrations/versions/1eb44413307a_convert_some_ids_from_int_to_str.py
"""convert some ids from int to str

Revision ID: 1eb44413307a
Revises: 8b0aa51b8226
Create Date: 2025-09-07 09:58:21.177705

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '1eb44413307a'
down_revision: Union[str, Sequence[str], None] = '8b0aa51b8226'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('asset_disposals', 'id',
               existing_type=sa.INTEGER(),
               type_=sa.String(length=60),
               existing_nullable=False)
    op.alter_column('asset_lifecycle_events', 'id',
               existing_type=sa.INTEGER(),
               type_=sa.String(length=60),
               existing_nullable=False)
    op.alter_column('asset_revaluations', 'id',
               existing_type=sa.INTEGER(),
               type_=sa.String(length=60),
               existing_nullable=False)
    op.alter_column('asset_transfers', 'id',
               existing_type=sa.INTEGER(),
               type_=sa.String(length=60),
               existing_nullable=False)
    op.alter_column('assets', 'other_pics',
               existing_type=postgresql.JSONB(astext_type=sa.Text()),
               type_=sa.JSON(),
               existing_nullable=True)
    op.alter_column('maintenance_requests', 'id',
               existing_type=sa.INTEGER(),
               type_=sa.String(length=60),
               existing_nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('maintenance_requests', 'id',
               existing_type=sa.String(length=60),
               type_=sa.INTEGER(),
               existing_nullable=False)
    op.alter_column('assets', 'other_pics',
               existing_type=sa.JSON(),
               type_=postgresql.JSONB(astext_type=sa.Text()),
               existing_nullable=True)
    op.alter_column('asset_transfers', 'id',
               existing_type=sa.String(length=60),
               type_=sa.INTEGER(),
               existing_nullable=False)
    op.alter_column('asset_revaluations', 'id',
               existing_type=sa.String(length=60),
               type_=sa.INTEGER(),
               existing_nullable=False)
    op.alter_column('asset_lifecycle_events', 'id',
               existing_type=sa.String(length=60),
               type_=sa.INTEGER(),
               existing_nullable=False)
    op.alter_column('asset_disposals', 'id',
               existing_type=sa.String(length=60),
               type_=sa.INTEGER(),
               existing_nullable=False)
    # ### end Alembic commands ###
/migrations/versions/771ffdc88eb6_add_dep_head_and_assistand_to_.py
"""add dep head and assistand to departments table

Revision ID: 771ffdc88eb6
Revises: 70533b633f8d
Create Date: 2025-09-22 15:17:26.597891

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '771ffdc88eb6'
down_revision: Union[str, Sequence[str], None] = '70533b633f8d'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('departments', sa.Column('department_head_id', sa.String(length=60), nullable=True))
    op.add_column('departments', sa.Column('deputy_head_id', sa.String(length=60), nullable=True))
    op.add_column('departments', sa.Column('county_code', sa.String(length=10), nullable=True))
    op.create_foreign_key(None, 'departments', 'users', ['department_head_id'], ['id'])
    op.create_foreign_key(None, 'departments', 'users', ['deputy_head_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'departments', type_='foreignkey')
    op.drop_constraint(None, 'departments', type_='foreignkey')
    op.drop_column('departments', 'county_code')
    op.drop_column('departments', 'deputy_head_id')
    op.drop_column('departments', 'department_head_id')
    # ### end Alembic commands ###
/migrations/versions/59e19fa8f118_add_county_as_entitiy_enum.py
"""add county as entitiy enum

Revision ID: 59e19fa8f118
Revises: f77bd06c4d70
Create Date: 2025-10-05 14:24:12.228253

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '59e19fa8f118'
down_revision: Union[str, Sequence[str], None] = 'f77bd06c4d70'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
/migrations/versions/70533b633f8d_change_action_name_in_policytable_to_.py
"""change action_name in policytable to jsonb, from json

Revision ID: 70533b633f8d
Revises: 084eb931f64e
Create Date: 2025-09-21 19:35:59.453582

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '70533b633f8d'
down_revision: Union[str, Sequence[str], None] = '084eb931f64e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('abac_policies', 'action_names',
               existing_type=postgresql.JSON(astext_type=sa.Text()),
               type_=postgresql.JSONB(astext_type=sa.Text()),
               existing_nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('abac_policies', 'action_names',
               existing_type=postgresql.JSONB(astext_type=sa.Text()),
               type_=postgresql.JSON(astext_type=sa.Text()),
               existing_nullable=False)
    # ### end Alembic commands ###
/migrations/versions/a0ce087e3924_add_fields_to_maintinance_and_some_enums.py
"""add fields to maintinance and some enums

Revision ID: a0ce087e3924
Revises: 771ffdc88eb6
Create Date: 2025-10-01 21:49:01.606321

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'a0ce087e3924'
down_revision: Union[str, Sequence[str], None] = '771ffdc88eb6'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('maintenance_requests', sa.Column('maintenance_type', sa.Enum('CORRECTIVE', 'PREVENTIVE', 'MAJOR', 'MANUFACTURER', 'REFURBISHMENT', 'ENHANCEMENT', 'DEFERRED', name='maintenancetype'), nullable=False))
    op.add_column('maintenance_requests', sa.Column('issue_category', sa.Enum('MECHANICAL_FAILURE', 'MECHANICAL_ISSUE', 'ELECTRICAL', 'SOFTWARE', 'PHYSICAL_DAMAGE', 'THEFT_LOSS', 'OBSOLESCENCE', 'FIRE_NATURAL', 'COMPLIANCE', 'OTHER', name='issuecategory'), nullable=False))
    op.add_column('maintenance_requests', sa.Column('priority', sa.Enum('CRITICAL', 'HIGH', 'MEDIUM', 'LOW', name='prioritylevel'), nullable=False))
    op.add_column('maintenance_requests', sa.Column('severity', sa.Enum('MINOR', 'MAJOR', 'CRITICAL', name='severitylevel'), nullable=True))
    op.create_index(op.f('ix_maintenance_requests_issue_category'), 'maintenance_requests', ['issue_category'], unique=False)
    op.create_index(op.f('ix_maintenance_requests_maintenance_type'), 'maintenance_requests', ['maintenance_type'], unique=False)
    op.create_index(op.f('ix_maintenance_requests_priority'), 'maintenance_requests', ['priority'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_maintenance_requests_priority'), table_name='maintenance_requests')
    op.drop_index(op.f('ix_maintenance_requests_maintenance_type'), table_name='maintenance_requests')
    op.drop_index(op.f('ix_maintenance_requests_issue_category'), table_name='maintenance_requests')
    op.drop_column('maintenance_requests', 'severity')
    op.drop_column('maintenance_requests', 'priority')
    op.drop_column('maintenance_requests', 'issue_category')
    op.drop_column('maintenance_requests', 'maintenance_type')
    # ### end Alembic commands ###
/migrations/versions/f77bd06c4d70_add_cost_fields_and_sup_to_sys.py
"""add cost fields and sup to sys

Revision ID: f77bd06c4d70
Revises: a0ce087e3924
Create Date: 2025-10-01 22:28:13.833942

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'f77bd06c4d70'
down_revision: Union[str, Sequence[str], None] = 'a0ce087e3924'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade():
    # Create the ENUM type first
    maintenanceoutcome_enum = sa.Enum('FIXED', 'NOT_FIXED', name='maintenanceoutcome')
    maintenanceoutcome_enum.create(op.get_bind(), checkfirst=True)
    
    # Now add the columns
    op.add_column('maintenance_requests', sa.Column('cost', sa.Numeric(precision=12, scale=2), nullable=True))
    op.add_column('maintenance_requests', sa.Column('started_at', sa.DateTime(), nullable=True))
    op.add_column('maintenance_requests', sa.Column('completed_at', sa.DateTime(), nullable=True))
    op.add_column('maintenance_requests', sa.Column('duration', sa.Interval(), nullable=True))
    op.add_column('maintenance_requests', sa.Column('outcome', sa.Enum('FIXED', 'NOT_FIXED', name='maintenanceoutcome'), nullable=True))


def downgrade():
    # Drop the columns first
    op.drop_column('maintenance_requests', 'outcome')
    op.drop_column('maintenance_requests', 'duration')
    op.drop_column('maintenance_requests', 'completed_at')
    op.drop_column('maintenance_requests', 'started_at')
    op.drop_column('maintenance_requests', 'cost')
    
    # Then drop the ENUM type
    sa.Enum(name='maintenanceoutcome').drop(op.get_bind(), checkfirst=True)/migrations/versions/0255751c95d5_add_name_and_pics_to_assets.py
"""add name and pics to assets

Revision ID: 0255751c95d5
Revises: 
Create Date: 2025-08-28 12:31:30.973865

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0255751c95d5'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('assets', sa.Column('pic', sa.String(length=200), nullable=True))
    op.add_column('assets', sa.Column('other_pics', sa.JSON(), nullable=True))
    op.add_column('assets', sa.Column('name', sa.String(length=100), nullable=True))
    op.execute("UPDATE assets SET name = 'Unknown' WHERE name IS NULL")
    op.alter_column("assets", "name", nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('assets', 'name')
    op.drop_column('assets', 'other_pics')
    op.drop_column('assets', 'pic')
    # ### end Alembic commands ###
/migrations/versions/15bf5ca82f0f_add_sec_tables_n_fields.py
"""add sec tables n fields

Revision ID: 15bf5ca82f0f
Revises: 59e19fa8f118
Create Date: 2025-10-08 10:54:17.127628

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '15bf5ca82f0f'
down_revision: Union[str, Sequence[str], None] = '59e19fa8f118'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('device_fingerprints',
    sa.Column('id', sa.String(length=60), nullable=False),
    sa.Column('user_id', sa.String(length=60), nullable=False),
    sa.Column('fingerprint_hash', sa.String(length=255), nullable=False),
    sa.Column('device_info', sa.JSON(), nullable=True),
    sa.Column('browser', sa.String(length=100), nullable=True),
    sa.Column('os', sa.String(length=100), nullable=True),
    sa.Column('ip_at_registration', sa.String(length=45), nullable=True),
    sa.Column('first_seen', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('last_seen', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('is_deleted', sa.Boolean(), nullable=False),
    sa.Column('is_trusted', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_device_fingerprints_fingerprint_hash'), 'device_fingerprints', ['fingerprint_hash'], unique=False)
    op.create_index(op.f('ix_device_fingerprints_id'), 'device_fingerprints', ['id'], unique=False)
    op.create_table('ip_whitelist',
    sa.Column('id', sa.String(length=60), nullable=False),
    sa.Column('user_id', sa.String(length=60), nullable=False),
    sa.Column('ip_address', sa.String(length=45), nullable=False),
    sa.Column('whitelist_type', sa.String(length=20), nullable=False),
    sa.Column('whitelisted_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_ip_whitelist_id'), 'ip_whitelist', ['id'], unique=False)
    op.create_index(op.f('ix_ip_whitelist_ip_address'), 'ip_whitelist', ['ip_address'], unique=False)
    op.create_table('login_attempts',
    sa.Column('id', sa.String(length=60), nullable=False),
    sa.Column('user_id', sa.String(length=60), nullable=True),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('ip_address', sa.String(length=45), nullable=False),
    sa.Column('fingerprint_hash', sa.String(length=255), nullable=True),
    sa.Column('success', sa.Boolean(), nullable=False),
    sa.Column('failure_reason', sa.String(length=255), nullable=True),
    sa.Column('location', sa.JSON(), nullable=True),
    sa.Column('device_info', sa.JSON(), nullable=True),
    sa.Column('browser', sa.String(length=100), nullable=True),
    sa.Column('os', sa.String(length=100), nullable=True),
    sa.Column('timezone', sa.String(length=50), nullable=True),
    sa.Column('language', sa.String(length=10), nullable=True),
    sa.Column('ip_details', sa.JSON(), nullable=True),
    sa.Column('fraud_score', sa.Integer(), nullable=True),
    sa.Column('timestamp', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_login_attempts_email'), 'login_attempts', ['email'], unique=False)
    op.create_index(op.f('ix_login_attempts_id'), 'login_attempts', ['id'], unique=False)
    op.create_index(op.f('ix_login_attempts_timestamp'), 'login_attempts', ['timestamp'], unique=False)
    op.create_table('mfa_codes',
    sa.Column('id', sa.String(length=60), nullable=False),
    sa.Column('user_id', sa.String(length=60), nullable=False),
    sa.Column('code', sa.String(length=10), nullable=False),
    sa.Column('temp_session_token', sa.String(length=500), nullable=False),
    sa.Column('expires_at', sa.DateTime(timezone=True), nullable=False),
    sa.Column('used', sa.Boolean(), nullable=False),
    sa.Column('ip_address', sa.String(length=45), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_mfa_codes_id'), 'mfa_codes', ['id'], unique=False)
    op.create_index(op.f('ix_mfa_codes_temp_session_token'), 'mfa_codes', ['temp_session_token'], unique=True)
    op.create_table('temp_disable_logs',
    sa.Column('id', sa.String(length=60), nullable=False),
    sa.Column('user_id', sa.String(length=60), nullable=False),
    sa.Column('reason', sa.String(length=255), nullable=False),
    sa.Column('disabled_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('disabled_until', sa.DateTime(timezone=True), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_temp_disable_logs_id'), 'temp_disable_logs', ['id'], unique=False)
    # op.add_column('users', sa.Column('timezone', sa.String(length=50), nullable=False))
    op.add_column('users', sa.Column('temp_disabled_until', sa.DateTime(timezone=True), nullable=True))
    op.drop_column('users', 'login_attempts')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('login_attempts', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False))
    op.drop_column('users', 'temp_disabled_until')
    op.drop_column('users', 'timezone')
    op.drop_index(op.f('ix_temp_disable_logs_id'), table_name='temp_disable_logs')
    op.drop_table('temp_disable_logs')
    op.drop_index(op.f('ix_mfa_codes_temp_session_token'), table_name='mfa_codes')
    op.drop_index(op.f('ix_mfa_codes_id'), table_name='mfa_codes')
    op.drop_table('mfa_codes')
    op.drop_index(op.f('ix_login_attempts_timestamp'), table_name='login_attempts')
    op.drop_index(op.f('ix_login_attempts_id'), table_name='login_attempts')
    op.drop_index(op.f('ix_login_attempts_email'), table_name='login_attempts')
    op.drop_table('login_attempts')
    op.drop_index(op.f('ix_ip_whitelist_ip_address'), table_name='ip_whitelist')
    op.drop_index(op.f('ix_ip_whitelist_id'), table_name='ip_whitelist')
    op.drop_table('ip_whitelist')
    op.drop_index(op.f('ix_device_fingerprints_id'), table_name='device_fingerprints')
    op.drop_index(op.f('ix_device_fingerprints_fingerprint_hash'), table_name='device_fingerprints')
    op.drop_table('device_fingerprints')
    # ### end Alembic commands ###
/migrations/env.py
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
from database import Base
import models

target_metadata = Base.metadata
# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
/database.py
from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import sessionmaker, declarative_base
import os
from dotenv import load_dotenv


load_dotenv(dotenv_path="./K-ALMIS/.env")

DB_HOST = os.getenv("DB_HOST")
DB_PORT = os.getenv("DB_PORT", 11412)
DB_USER = os.getenv("DB_USER")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_NAME = os.getenv("DB_NAME")

DB_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

print(f"\n\n\n\n{DB_URL}\n\n\n")
engine = create_engine(DB_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

/misc/aa.py
import requests
import json

url = 'https://api.abuseipdb.com/api/v2/check'

querystring = {
    'ipAddress': '196.96.24.54',
    'maxAgeInDays': '90'
}

headers = {
    'Accept': 'application/json',
    'Key': '1ad2de736e538768cf0b63d8a3a488b76fd08fc6362b919b65e20be28422ec9c0a518d26415356d0'
}

response = requests.request(method='GET', url=url, headers=headers, params=querystring)
decodedResponse = json.loads(response.text)
print(json.dumps(decodedResponse, sort_keys=True, indent=4))
/__init__.py
/routers/a_lifecycle.py
from fastapi import APIRouter, Depends,HTTPException
from sqlalchemy.orm import Session
from ..database import get_db
from ..models import Assets,AssetStatus,User,AssetLifecycleEvents
from ..schemas.assets import AssetResponse
from sqlalchemy import desc
from .a_crude import create_lifecycle_event
from ..utilities import get_current_user
from typing import List
from ..schemas.assets import AssetLifecycleEventResponse
from ..asset_utils import add_namedep_asset

from ..asset_utils import add_namedep_asset
router = APIRouter(
    prefix="/api/v1/assets/life",
    tags=["Assets Lifecycle"]
    )

@router.post("/{asset_id}/activate")
async def activate_asset(asset_id: str, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    asset = db.query(Assets).filter(Assets.id == asset_id, Assets.is_deleted == False).first()
    
    if not asset:
     
        raise HTTPException(status_code=404, detail="Asset not found")
    
    if asset.status == AssetStatus.OPERATIONAL:
        raise HTTPException(status_code=400, detail="Asset is already operational")
    
    asset.status = AssetStatus.OPERATIONAL
    
    # create_lifecycle_event(db, asset.id, "activated", current_user.id,remarks="Asset activated for operational use")
    
    db.commit()
    db.refresh(asset)
    
    return {"msg" : f"Asset {asset.id} : Activated" }

@router.post("/{asset_id}/deactivate")  
async def deactivate_asset(asset_id: str, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    asset = db.query(Assets).filter(Assets.id == asset_id, Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    if asset.status in [AssetStatus.DISPOSED, AssetStatus.RETIRED]:
        raise HTTPException(status_code=400, detail="Cannot deactivate disposed or retired asset")
    
    asset.status = AssetStatus.IMPAIRED
    
    # create_lifecycle_event(db, asset.id, "deactivated", current_user.id,remarks="Asset deactivated from operational use")
    
    db.commit()
    db.refresh(asset)
    
    return {"msg" : f"Asset {asset.id} : Dectivated" }

@router.post("/{asset_id}/mark-disposal")
async def mark_asset_for_disposal( asset_id: str, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):
    asset = db.query(Assets).filter(Assets.id == asset_id,Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    if asset.status in [AssetStatus.DISPOSED, AssetStatus.HELD_FOR_SALE]:
        raise HTTPException(status_code=400, detail="Asset already marked for disposal")
    
    asset.status = AssetStatus.HELD_FOR_SALE
    
    # create_lifecycle_event(db, asset.id, "marked_for_disposal", current_user.id,remarks="Asset marked for disposal")
    
    db.commit()
    db.refresh(asset)
    
    return AssetResponse(**add_namedep_asset(asset))


@router.get("/{asset_id}/lifecycle", response_model=List[AssetLifecycleEventResponse])
async def get_asset_lifecycle_adm(asset_id: str,db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):
    """Get complete asset lifecycle history"""
    
    asset = db.query(Assets).filter(Assets.id == asset_id,Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    events = db.query(AssetLifecycleEvents).filter(AssetLifecycleEvents.asset_id == asset_id).order_by(desc(AssetLifecycleEvents.event_date)).all()
    
    return events/routers/a_supp_routes.py
from fastapi import APIRouter,Depends
from ..models import AssetStatus,AssetCondition,AssetCategory,User,MaintenanceType, IssueCategory,PriorityLevel,SeverityLevel,MaintenanceOutcome
from typing import Dict,List
from ..asset_utils import StandardAssetAttributes, LandAttributes,BuildingAttributes,get_required_fields,get_default_attributes
from ..schemas.assets import CategoryInfo
from ..utilities import get_current_user

router = APIRouter(
    prefix="/api/v1/assets/supp",
    tags=["Assets Supporting routes"]
    )

@router.get("/assetstatus", status_code=200,response_model=Dict[str, str])
async def list_asset_statuses(curr: User = Depends(get_current_user)):
    
    return {x.name: x.value for x in AssetStatus }

@router.get("/assetcondition", status_code=200,response_model=Dict[str, str])
async def list_asset_condition(curr: User = Depends(get_current_user)):
    
    return {x.name: x.value for x in AssetCondition}

@router.get("/categories/newlist", status_code=200,response_model=Dict[str, str])
async def list_categories_byname(curr: User = Depends(get_current_user)):


    return {x.name: x.value for x in AssetCategory}


@router.get("/categories/detailed", status_code=200)
async def list_asset_categories_detailed(curr: User = Depends(get_current_user)):
    categories = {
        "Standard Assets": StandardAssetAttributes,
        "Land": LandAttributes,
        "Buildings and building improvements": BuildingAttributes,
    }
    
    result = {}
    
    for category_name, schema_class in categories.items():
        required_fields = get_required_fields(category_name)
        
        schema_instance = schema_class()
        
        if hasattr(schema_instance, '__fields__'):
            all_fields = list(schema_instance.__fields__.keys())
        elif hasattr(schema_instance, 'model_fields'):
            all_fields = list(schema_instance.model_fields.keys())
        else:
            all_fields = list(schema_class.__annotations__.keys())
        
        field_details = {}
        for field_name in all_fields:

            field_type = schema_class.__annotations__.get(field_name, str)

            type_str = str(field_type)
            if "Optional" in type_str:
                if hasattr(field_type, '__args__') and field_type.__args__:
                    actual_type = field_type.__args__[0]
                    type_name = getattr(actual_type, '__name__', str(actual_type))
                else:
                    type_name = "str"
            else:
                type_name = getattr(field_type, '__name__', str(field_type))
            
            field_details[field_name] = {
                "type": type_name,
                "required": field_name in required_fields,
                "description": field_name.replace('_', ' ').title()
            }
        
        result[category_name] = {
            "required_fields": required_fields,
            "all_fields": field_details,
            "schema_name": schema_class.__name__
        }
    
    return {
        "message": "Asset categories and their fields",
        "categories": result
    }


@router.get("/categories/info", response_model=List[CategoryInfo])
async def get_asset_categories_info():
    categories = [
        {
            "category": "Standard Assets",
            "description": "General assets register for standard equipment and items",
            "fields": [
                {"field_name": "asset_description", "field_type": "string", "required": True},
                {"field_name": "make_model", "field_type": "string", "required": False},
                {"field_name": "serial_number", "field_type": "string", "required": False},
                {"field_name": "responsible_officer", "field_type": "string", "required": False}
            ],
            "sample_attributes": get_default_attributes("Standard Assets")
        },
        {
            "category": "Land",
            "description": "Land register for land assets and properties",
            "fields": [
                {"field_name": "description_of_land", "field_type": "string", "required": True},
                {"field_name": "size_hectares", "field_type": "decimal", "required": True},
                {"field_name": "county", "field_type": "string", "required": True},
                {"field_name": "lr_certificate_no", "field_type": "string", "required": False}
            ],
            "sample_attributes": get_default_attributes("Land")
        },
        {
            "category": "Buildings and building improvements",
            "description": "Buildings register for building assets and improvements",
            "fields": [
                {"field_name": "description_name_of_building", "field_type": "string", "required": True},
                {"field_name": "type_of_building", "field_type": "string", "required": True},
                {"field_name": "county", "field_type": "string", "required": True},
                {"field_name": "no_of_floors", "field_type": "integer", "required": False}
            ],
            "sample_attributes": get_default_attributes("Buildings and building improvements")
        }
    ]
    
    return categories


@router.get("/maintain/MaintenanceType",status_code=200,response_model=Dict[str, str])
async def list_maintainance_types(curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in MaintenanceType}

@router.get("/maintain/IssueCategory",status_code=200,response_model=Dict[str, str])
async def list_issue_categories(curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in IssueCategory}
@router.get("/maintain/PriorityLevel",status_code=200,response_model=Dict[str, str])
async def list_priorrity_levels(curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in PriorityLevel}
@router.get("/maintain/SeverityLevel",status_code=200,response_model=Dict[str, str])
async def list_Severerity_level(curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in SeverityLevel}

@router.get("/maintain/maintainanceoutcome",status_code=200,response_model=Dict[str, str])
async def list_the_2_maint_outcomes(curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in MaintenanceOutcome}




/routers/a_tracking.py
from fastapi import APIRouter, Depends,HTTPException
from sqlalchemy.orm import Session,joinedload
from ..models import Assets,User
from ..database import get_db
from ..schemas.assets import QRCodeResponse,AssetResponse,AssetLocationUpdate
from ..utilities import get_current_user
from datetime import datetime
import base64
import io
import qrcode
from .a_crude import create_lifecycle_event
from ..asset_utils import add_namedep_asset


router = APIRouter(
    prefix="/api/v1/assets",
    tags=["Assets Tracking"]
    )

@router.post("/{asset_id}/generate-qr", response_model=QRCodeResponse)
async def generate_asset_qr_code(asset_id: str,db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):
    asset = db.query(Assets).filter( Assets.id == asset_id, Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")

    qr_data = {"asset_id": asset.id,"tag_number": asset.tag_number,"description": asset.description,"category": asset.category,"generated_at": datetime.now().isoformat()}
    
    qr_code_text = f"ASSET:{asset.id}|TAG:{asset.tag_number}|DESC:{asset.description}"

    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(qr_code_text)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    qr_code_base64 = base64.b64encode(buffer.getvalue()).decode()
    
    asset.qr_code = qr_code_text
    
    create_lifecycle_event( db, asset.id, "qr_generated", current_user.id, details={"qr_data": qr_code_text}, remarks="QR code generated for asset")
    
    db.commit()  
    return QRCodeResponse(qr_code_data=qr_code_text, qr_code_image_url=f"data:image/png;base64,{qr_code_base64}")

@router.put("/{asset_id}/location", response_model=AssetResponse)
async def update_asset_location(asset_id: str, location_data: AssetLocationUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    
    
    asset = db.query(Assets).filter(Assets.id == asset_id,Assets.is_deleted == False).first() 
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    old_location = asset.location
    asset.location = location_data.location
    
    create_lifecycle_event(db, asset.id, "location_changed", current_user.id,
        details={
            "old_location": old_location,
            "new_location": location_data.location
        },remarks=location_data.remarks or "Asset location updated" # remak
    )
    
    db.commit()
    db.refresh(asset)
    
    return AssetResponse(**add_namedep_asset(asset))

# lookup 
@router.get("/by-tag/{tag_number}", response_model=AssetResponse)
async def get_asset_by_tag_no(tag_number: str,db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):

    asset = db.query(Assets).options(joinedload(Assets.department),joinedload(Assets.responsible_officer)
    ).filter(
        Assets.tag_number == tag_number,
        Assets.is_deleted == False
    ).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    return AssetResponse(**add_namedep_asset(asset))

@router.get("/by-barcode/{barcode}", response_model=AssetResponse)
async def get_asset_by_barcode(barcode: str, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    
    asset = db.query(Assets).options( joinedload(Assets.department), joinedload(Assets.responsible_officer)
    ).filter(
        Assets.barcode == barcode,
        Assets.is_deleted == False
    ).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    return AssetResponse(**add_namedep_asset(asset))

@router.get("/by-serial/{serial_number}", response_model=AssetResponse)
async def get_asset_by_serial_no(
    serial_number: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):

    asset = db.query(Assets).options(joinedload(Assets.department),joinedload(Assets.responsible_officer)
    ).filter(
        Assets.serial_number == serial_number,
        Assets.is_deleted == False
    ).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    return AssetResponse(**add_namedep_asset(asset))/routers/auth.py
from fastapi import Depends, HTTPException, status, APIRouter, Query, Request, BackgroundTasks
from ..models import User, TokenBase,PasswordResetToken
from ..utilities import get_current_user, pwd_context, generate_id, authenticate_user, create_access_token, create_refresh_token,oauth2_scheme, check_token,revoke_tokens, SECRET_KEY,ALGORITHM, get_user_id,create_password_reset_token, validate_reset_token,revoke_tokens_byid
from ..schemas.main import CreateUser,AuthMethod, UserOut, TokenOut,TokenOutId, LoginRequest,UserOutProfile, UserStatus, ChangePassword,PasswordResetResponse, PasswordResetRequest,PasswordReset
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from ..database import get_db
from datetime import datetime, timedelta, timezone
from ..system_vars import ACCESS_TOKEN_EXPIERY,default_new_user_status, send_emails,sys_logger,default_role_id
from jose import jwt,JWTError
from ..services.emailsender import AssetFlowEmailService
import os
from fastapi.security import OAuth2PasswordRequestForm
from typing import Optional

from dotenv import load_dotenv
load_dotenv(dotenv_path="./fapi/.env")

if send_emails:
    email_service = AssetFlowEmailService(api_key=os.getenv("SENDINBLUE_API_KEY", "kk"))
router = APIRouter(
   
    tags=['Authentication'],
    prefix="/api/v1/auth"
)

@router.post("/register", status_code = status.HTTP_201_CREATED,response_model=UserOut)
def user_register(user: CreateUser ,background_tasks: BackgroundTasks,   db: Session = Depends(get_db)):

    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="User already exists")
 
    hashed_pass = pwd_context.hash(user.password)
    user_id = generate_id()

    new_user = User(
        id=user_id,
        profile_pic=user.profile_pic,
        first_name=user.first_name,
        last_name=user.last_name,
        email=user.email,
        phone_number=user.phone_number,
        department_id=user.department_id,
        position_title=user.position_title,
        is_accounting_officer=False,
        password_hash=hashed_pass,  
        role_id=default_role_id,
        status=default_new_user_status,
        created_at=datetime.now(timezone.utc),
        last_login=None,
        gov_level=user.gov_level,
        entity_type=user.entity_type,
        entity_name=user.entity_name,
        location=user.location.dict() if user.location else None,
        access_scope='{}',
        is_two_factor_enabled=False,
        last_password_change=None,
        login_attempts=None,
        last_activity_at=None,
        notes=user.notes,
        auth_method=AuthMethod.password,
    )
    db.add(new_user)
    try:
        db.commit()
        db.refresh(new_user) 
    except IntegrityError as e:
        db.rollback()
        if "foreign key constraint" in str(e.orig).lower():
            raise HTTPException(status_code=400, detail="Invalid department ID")
        raise HTTPException(status_code=400, detail="Db integrity error")


    if send_emails:
        background_tasks.add_task(
            email_service.send_account_created_email,
            str(new_user.email),
            str(new_user.first_name)
        )
    return new_user

@router.post("/login", response_model=TokenOutId, status_code=status.HTTP_200_OK)
def login(login_req: LoginRequest, db:Session = Depends(get_db)):
    user = authenticate_user(login_req.email, login_req.password, db)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid email or password")
    if user.status == "deleted":
        raise HTTPException(status_code=401, detail="Account nolonger Exists, contact support")
    if user.status == "inactive" and user.last_login == None:
        raise HTTPException(status_code=401, detail="Account awaiting activation, contact support")
    if user.status != "active":
        raise HTTPException(status_code=401, detail="Account Deactivated, contact support")
    
    #bad imp - discuss use of speciffic atttribute role
    if user.position_title == 'member':
        rolem = user.position_title
    elif user.role_id == '3fef8a21e7f53606402fcd4f692746':
        rolem = "superadmin"
    elif user.role_id =='role_006':
        rolem = "admin"
    else:
        rolem = "member"

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIERY)


    access_token = create_access_token(
        data={"sub": user.email, "id": user.id, "role": rolem,"username": user.first_name, "dept_id": user.department_id}, 
        expires_delta=access_token_expires, db= db
    )

    if login_req.remember_me:
        refresh_token_expiery = timedelta(days=7)
    else:
        refresh_token_expiery = access_token_expires
    
    refresh_token = create_refresh_token( data={"sub": user.email, "user_id": user.id}, expires_delta=refresh_token_expiery, db= db)






    user.last_login = datetime.now(timezone.utc)  
    db.commit()
    return {"access_token": access_token,"refresh_token": refresh_token,"role": rolem ,"dept_id": user.department_id ,"token_type": "bearer","a_expires" : ACCESS_TOKEN_EXPIERY * 60 }

@router.post("/login/oauth2form", response_model=TokenOut)
async def login_oauth2(
    form_data: OAuth2PasswordRequestForm = Depends(),
    remember_me: Optional[bool] = Query(default=False),
    db: Session = Depends(get_db)
):
    user = authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid email or password")
    if user.status != "active":
        raise HTTPException(status_code=401, detail="Account Deactivated, contact support")
 
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIERY)
    access_token = create_access_token(
        data={"sub": user.email, "id": user.id},
        expires_delta=access_token_expires,
        db=db
    )

    refresh_token_expiery = timedelta(days=7) if remember_me else access_token_expires

    refresh_token = create_refresh_token(
        data={"sub": user.email, "id": user.id},
        expires_delta=refresh_token_expiery,
        db=db
    )

    user.last_login = datetime.now(timezone.utc)
    db.commit()

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "a_expires": ACCESS_TOKEN_EXPIERY * 60
    }


@router.post("/logout")
async def logout(
    request: Request,
    db: Session = Depends(get_db),
    token: str = Depends(oauth2_scheme)
):
    if not check_token(token, db):
        return "not logged in"
    return revoke_tokens(request, db)

@router.get("/protected")
async def protected_route_test(
    db: Session = Depends(get_db),
    token: str = Depends(oauth2_scheme)
):
    if not check_token(token, db):
        raise HTTPException(status_code=401, detail="Token invalid or revoked")
    
    return {"msg": "You are authorized"}


@router.post("/refresh")
async def refresh_token(
    request: Request,
    db: Session = Depends(get_db),
    token: str = Depends(oauth2_scheme)
):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        jti = payload.get("jti")
        user_id = payload.get("id")
        token_type = payload.get("type")
        
        if token_type != "refresh":
            raise HTTPException(status_code=401, detail="Invalid token type")
        
       
        token_record = db.query(TokenBase).filter(
            TokenBase.jti == jti,
            TokenBase.revoked == False
        ).first()
        
        if not token_record:
            raise HTTPException(status_code=401, detail="Refresh token not found or revoked")
        
        if token_record.exp < datetime.now(timezone.utc): 
            raise HTTPException(status_code=401, detail="Refresh token expired")
    
        db.query(TokenBase).filter(
            TokenBase.user_id == user_id,
            TokenBase.revoked == False
        ).update({"revoked": True})
        db.commit()     

        original_expiry = token_record.exp
        now = datetime.now(timezone.utc)
        remaining = original_expiry - now
        remaining_seconds = max(60, int(remaining.total_seconds()))
        
        new_access_token = create_access_token(
            data={"sub": payload.get("sub"), "id": user_id},
            expires_delta=timedelta(seconds=remaining_seconds),
            db=db
        )  

        new_refresh_token = create_refresh_token(
            data={"sub": payload.get("sub"), "id": user_id},
            expires_delta=timedelta(seconds=remaining_seconds),
            db=db
        )
        
        return {
            "access_token": new_access_token,
            "refresh_token": new_refresh_token,
            "token_type": "bearer",
            "expires_in": remaining_seconds
        }
        
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")
    
@router.post("/change-password", status_code=status.HTTP_200_OK)
async def prifile_change_password(req : ChangePassword, curr_user :User = Depends(get_current_user), db: Session = Depends(get_db)):
   
    if req.old_password != req.old_password2:
        raise  HTTPException(status_code=status.HTTP_304_NOT_MODIFIED, detail="Old Passwords dont match")
   
    user = authenticate_user(curr_user.email,req.old_password, db)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    if req.old_password == req.new_password:
         raise HTTPException(status_code=401, detail="Old password and new password cannot be thesame")
    
    password_hash = pwd_context.hash(req.new_password)
    user.password_hash = password_hash
    db.commit()
    db.refresh(user)

    return {"msg": "password updated successfully"}

@router.post("/request-password-reset", response_model=PasswordResetResponse)
async def request_password_reset(reset_request: PasswordResetRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):

    user = db.query(User).filter(User.email == reset_request.email).first()
    
    if not user:
        return PasswordResetResponse(
            message="If an account with this email exists, a password reset link has been sent.",
            success=True
        )
    
    if user.status == "deleted":
        return PasswordResetResponse(
            message="If an account with this email exists, a password reset link has been sent.",
            success=True
        )
    
    reset_token = create_password_reset_token(user.email, db)

    background_tasks.add_task(
        email_service.send_password_reset_email,
        user.email,
        str(user.first_name),
        reset_token
    )
    
    return PasswordResetResponse(
        message="If an account with this email exists, a password reset link has been sent.",
        success=True
    )

@router.get("/password-reset", response_model=dict)
async def check_password_reset_token(token: str = Query(...), db: Session = Depends(get_db)):

    user_email = validate_reset_token(token, db)
    
    if not user_email:
        raise HTTPException(
            status_code=400,
            detail="Invalid or expired reset token"
        )
    
    user = db.query(User).filter(User.email == user_email).first()
    
    return {
        "message": "Valid reset token",
        "token": token,
        "user_email": user_email,
        "user_name": user.first_name if user else None,
        "success": True
    }

@router.post("/password-reset", response_model=PasswordResetResponse)
async def reset_password(reset_data: PasswordReset, db: Session = Depends(get_db)):

    user_email = validate_reset_token(reset_data.token, db)
    
    if not user_email:
        raise HTTPException(
            status_code=400,
            detail="Invalid or expired reset token"
        )
    

    user = db.query(User).filter(User.email == user_email).first()
    
    if not user:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    
    if len(reset_data.new_password) < 6:
        raise HTTPException(
            status_code=400,
            detail="Password must be at least 6 characters long"
        )
    

    hashed_password = pwd_context.hash(reset_data.new_password)
    
    user.password_hash = hashed_password
    
    reset_token = db.query(PasswordResetToken).filter(
        PasswordResetToken.token == reset_data.token
    ).first()
    
    if reset_token:
        reset_token.is_used = True
    
    revoke_tokens_byid(user.id, db)
    
    db.commit()
    
    return PasswordResetResponse(
        message="Password reset successfully. Please login with your new password.",
        success=True
    )




@router.get("/me", response_model=UserOutProfile, status_code=status.HTTP_200_OK)
def get_my_profile(token: str = Depends(oauth2_scheme),db:Session = Depends(get_db)):

    if not check_token(token, db):
        raise HTTPException(status_code=401, detail="Token invalid or revoked")
    
    user_id = get_user_id(token,db)
    if not user_id:
        raise HTTPException(status_code=401, detail="An Error Has occured")
    
    profile = db.query(User).filter(User.id == user_id).first()
    
    return profile /routers/roles.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from typing import List
from ..database import get_db
from ..models import Role, User
from ..schemas.main import RoleCreate, RoleOut,UsersWithRoleX,RoleUpdate
from ..utilities import generate_id,get_current_user,generate_id
from ..system_vars import sys_logger,debugging
from ..services.logger_queue import enqueue_log
from ..schemas.main import  ActionType, LogLevel
from ..services.policy_eval import check_simple_permission,require_specific_role,check_full_permission


router = APIRouter(
    prefix="/api/v1/roles", 
    tags=["Roles"]
    )

@router.post("/no-auth-crit", response_model=RoleOut, status_code=status.HTTP_201_CREATED)
async def create_role_noperm(rdata: RoleCreate,db:Session = Depends(get_db)):
    id = generate_id(30)
    role = Role(id =id,name=rdata.name, description =rdata.description ,permissions=rdata.permissions)
    db.add(role)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Role with name '{rdata.name}' already exists")

    db.refresh(role)

    if sys_logger:
        await enqueue_log(
            user_id=None,
            action=ActionType.CREATE,
            target_table="roles",
            target_id=id,
            details={"route": "no-auth-crit", "payload": rdata.dict(exclude_unset=True)},
            level=LogLevel.INFO
        )
    return role


@router.post("/", response_model=RoleOut, status_code=status.HTTP_201_CREATED)
async def create_role(rdata: RoleCreate,current_user: User = Depends(get_current_user) ,db:Session = Depends(get_db)):
    state,det = require_specific_role(current_user,['super_user_do'])
    if not state:
        if sys_logger:
            await enqueue_log(
               user_id=current_user.id,
               action=ActionType.SUSPICIOUS_ACTIVITY,
               target_table="roles",
               target_id=None,
               details=f"Insufficient permissions to create role {rdata.dict(exclude_unset=True)}",
               level=LogLevel.CRITICAL)
        
        raise HTTPException(status_code=403, detail=det)
    idd = generate_id(30)
    role = Role(id = idd ,name=rdata.name,description =rdata.description, permissions=rdata.permissions)

        
    db.add(role)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Role with name '{rdata.name}' already exists")

    db.refresh(role)

    if sys_logger:
        await enqueue_log(
           user_id=current_user.id,
           action=ActionType.CREATE,
           target_table="roles",
           target_id=idd,
           details=None,
           level=LogLevel.INFO)
    return role

@router.get("/", response_model=List[RoleOut])
async def list_roles(db: Session = Depends(get_db)):
    
    
    # if not check_simple_permission(current_user, "role", "read"):
    #     if sys_logger:
    #         await enqueue_log(
    #             user_id=current_user.id,
    #             action=ActionType.SUSPICIOUS_ACTIVITY,
    #             target_table="roles",
    #             target_id=None,
    #             details="Attempt to list roles without permission",
    #             level=LogLevel.WARNING
    #         )
    #     raise HTTPException(status_code=403, detail="Not enough permissions")
    
    if sys_logger:
        await enqueue_log(
            user_id="no_user",
            action=ActionType.VIEW,
            target_table="roles",
            target_id=None,
            details=None,
            level=LogLevel.INFO
    )
    roles = db.query(Role).all()
    if debugging:
        print("\n\n\n\n\n\nreturnung role\n\n\n")
    if roles: 
        return roles 
    else:
        return []
    


@router.get("/{role_id}", response_model=RoleOut)
async def get_role(role_id: str,db:Session = Depends(get_db)):
    if not check_simple_permission(current_user, "role", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="roles",
                target_id=role_id,
                details="Attempt to get role without permission",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="roles",
            target_id=role_id,
            details=None,
            level=LogLevel.INFO
            ) 
    role = db.query(Role).filter(Role.id == role_id).first()
    if not role:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.VIEW,
                target_table="roles",
                target_id=role_id,
                details="Role not found",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Role not found")
    return role

@router.get("/{role_id}/permissions")
async def get_role_permissions(role_id: str,current_user: User = Depends(get_current_user) ,db:Session = Depends(get_db)):
    if not check_simple_permission(current_user, "role", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="roles",
                target_id=role_id,
                details="Attempt to read role permissions without permission",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")
    

    role = db.query(Role).filter(Role.id == role_id).first()
    if not role:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.VIEW,
                target_table="roles",
                target_id=role_id,
                details="Role not found when fetching permissions",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Role not found")
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="roles",
            target_id=role_id,
            details="Fetched role permissions",
            level=LogLevel.INFO
        )
    
    return role.permissions or {}


@router.post("/{role_id}/permissions/add")
async def add_permission(role_id: str,permission: str,db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):
    role = db.query(Role).filter(Role.id == role_id).first()
    if not role:
        raise HTTPException(status_code=404, detail="Role not found")

    perms = set(role.permissions or [])
    if permission in perms:
        raise HTTPException(status_code=400, detail=f"Permission '{permission}' already exists in role")

    perms.add(permission)
    role.permissions = list(perms)
    db.commit()
    db.refresh(role)

    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.UPDATE,
            target_table="roles",
            target_id=role_id,
            details={"added_permission": permission},
            level=LogLevel.INFO,
        )

    return {"detail": f"Permission '{permission}' added", "permissions": role.permissions}


@router.post("/{role_id}/permissions/remove")
async def remove_permission(role_id: str,permission: str,db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):
    role = db.query(Role).filter(Role.id == role_id).first()
    if not role:
        raise HTTPException(status_code=404, detail="Role not found")

    perms = set(role.permissions or [])
    if permission not in perms:
        raise HTTPException(status_code=400, detail=f"Permission '{permission}' not found in role")

    perms.remove(permission)
    role.permissions = list(perms)
    db.commit()
    db.refresh(role)

    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.UPDATE,
            target_table="roles",
            target_id=role_id,
            details={"removed_permission": permission},
            level=LogLevel.INFO,
        )

    return {"detail": f"Permission '{permission}' removed", "permissions": role.permissions}

@router.put("/{role_id}", response_model=RoleOut)
async def update_role(role_id: str, rdata: RoleUpdate,current_user: User = Depends(get_current_user) ,db:Session = Depends(get_db)):
    # if not check_simple_permission(current_user, "role", "update"):
    #     raise HTTPException(status_code=403, detail="Not enough permissions")
    try:
        check_full_permission(current_user, "role", "update", db, resource=None)
    except HTTPException as e:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="roles",
                target_id=role_id,
                details=f"Update denied: {e.detail}",
                level=LogLevel.CRITICAL
            )
        raise

    role = db.query(Role).filter(Role.id == role_id).first()
    if not role:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="roles",
                target_id=role_id,
                details="Role not found for update",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Role not found")
    
    changes = {}
    update_data = rdata.dict(exclude_unset=True)
    for field, value in update_data.items():
        old_value = getattr(role, field)
        if old_value != value:
            setattr(role, field, value)
            changes[field] = {"old": old_value, "new": value}
  
    role.name = rdata.name
    role.permissions = rdata.permissions
    db.commit()
    db.refresh(role)


    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.UPDATE,
            target_table="roles",
            target_id=role_id,
            details=changes or rdata.dict(exclude_unset=True),
            level=LogLevel.INFO
        )

    return role

@router.delete("/{role_id}", status_code=status.HTTP_202_ACCEPTED)
async def delete_role(role_id: str,current_user: User = Depends(get_current_user) ,db:Session = Depends(get_db)):
    # if not check_simple_permission(current_user, "role", "delete"):
    #     raise HTTPException(status_code=403, detail="Not enough permissions")
    try:
        check_full_permission(current_user, "role", "delete", db, resource=None)
    except HTTPException as e:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="roles",
                target_id=role_id,
                details=f"Delete denied: {e.detail}",
                level=LogLevel.CRITICAL
            )
        raise

    role = db.query(Role).filter(Role.id == role_id).first()
    if not role:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.DELETE,
                target_table="roles",
                target_id=role_id,
                details="Role not found for delete",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Role not found")
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.DELETE,
            target_table="roles",
            target_id=role_id,
            details=None,
            level=LogLevel.INFO
        )
    db.delete(role)
    db.commit()

    return {"detail": f"deleted role: {role.id}"}

@router.get("/user/{role_id}",status_code=status.HTTP_200_OK, response_model=List[UsersWithRoleX])
async def get_all_users_with_role(role_id: str,current_user: User = Depends(get_current_user) ,db:Session = Depends(get_db)):
    if not check_simple_permission(current_user, "role", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="roles",
                target_id=role_id,
                details="Attempt to list users with role without role.read",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions (role.read)")

    if not check_simple_permission(current_user, "users", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="users",
                target_id=None,
                details="Attempt to list users with role without users.read",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions (users.read)")

    users = db.query(User).filter(User.role_id == role_id).all()
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="roles",
            target_id=role_id,
            details={"view": f"all users with role {role_id}", "count": len(users)},
            level=LogLevel.INFO
        )
    return users/routers/a_maintainance.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, date
from typing import List
import uuid
from ..models import MaintenanceRequests,Assets,User,AssetStatus, MaintenanceStatus, MaintenanceType,PriorityLevel, SeverityLevel,IssueCategory
from..schemas.maintain_dispose import MaintenanceApproveReq,MaintenanceCompleteReq,MaintenanceCompleteResp,MaintenanceHistResp,MaintenanceInitiateReq,MaintenanceResp,MaintenanceScheduleReq,MaintenanceStartReq
from ..utilities import get_current_user
from ..services.policy_eval import check_simple_permission,require_specific_role
from ..schemas.main import LogLevel, ActionType
from ..services.logger_queue import enqueue_log
from ..system_vars import sys_logger

from ..database import get_db

router = APIRouter(
    prefix="/api/v1/assets",
    tags=["Assets Maintainance"]
    )


@router.post("/{asset_id}/maintenance/initiate", status_code=201, response_model=MaintenanceResp)
async def init_maint_req(asset_id: str, req: MaintenanceInitiateReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if not check_simple_permission(curr_user, "maintenance", "create"):
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="maintenance_requests",
                target_id=None,
                details=f"Unauthorized attempt to initiate maintenance for asset {asset_id}",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")

    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.VIEW,
                target_table="assets",
                target_id=asset_id,
                details="Asset not found when initiating maintenance",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="asset not found")
    
    asset.status = AssetStatus.UNDER_MAINTENANCE

    maint_req = MaintenanceRequests(
        id=str(uuid.uuid4()),
        asset_id=asset_id,
        requested_by=curr_user.id,
        issue_type=req.issue_type,
        description=req.description,
        status="initiated",
        maintenance_type=req.maintenance_type or MaintenanceType.CORRECTIVE,
        issue_category=req.issue_category or IssueCategory.OTHER,
        priority=req.priority or PriorityLevel.MEDIUM,
        severity=req.severity or SeverityLevel.MINOR
    )

    db.add(maint_req)
    db.commit()
    db.refresh(asset)
    db.refresh(maint_req)

    if sys_logger:
        await enqueue_log(
            user_id=curr_user.id,
            action=ActionType.CREATE,
            target_table="maintenance_requests",
            target_id=maint_req.id,
            details={"route": "initiate", "asset_id": asset_id, "payload": req.dict(exclude_unset=True)},
            level=LogLevel.INFO
        )

    return {"msg": "maintenance initiated"}

@router.post("/{asset_id}/maintenance/schedule", status_code=200, response_model=MaintenanceResp)
async def schedule_maint(asset_id: str, req: MaintenanceScheduleReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if not check_simple_permission(curr_user, "maintenance", "update"):
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="maintenance_requests",
                target_id=None,
                details=f"Unauthorized attempt to schedule maintenance for asset {asset_id}",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")

    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.VIEW,
                target_table="assets",
                target_id=asset_id,
                details="Asset not found when scheduling maintenance",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="asset not found")
    
    asset.status = AssetStatus.SCHEDULED_MAINTENANCE

    maint_req = MaintenanceRequests(
        id=str(uuid.uuid4()),
        asset_id=asset_id,
        requested_by=curr_user.id,
        issue_type=req.issue_type,
        description=req.description,
        status="scheduled",
        maintenance_type=req.maintenance_type or MaintenanceType.PREVENTIVE,
        issue_category=req.issue_category or IssueCategory.OTHER,
        priority=req.priority or PriorityLevel.MEDIUM,
        severity=req.severity or SeverityLevel.MINOR,
        maintenance_date=req.maintenance_date
    )

    db.add(maint_req)
    db.commit()
    db.refresh(asset)
    db.refresh(maint_req)

    if sys_logger:
        await enqueue_log(
            user_id=curr_user.id,
            action=ActionType.CREATE,
            target_table="maintenance_requests",
            target_id=maint_req.id,
            details={"route": "schedule", "asset_id": asset_id, "payload": req.dict(exclude_unset=True)},
            level=LogLevel.INFO
        )

    return {"msg": "maintenance scheduled"}


@router.post("/{asset_id}/maintenance/approve", status_code=200, response_model=MaintenanceResp)
async def approve_maint(asset_id: str, req: MaintenanceApproveReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    state, det = require_specific_role(curr_user, ["maintenance_manager"])
    if not state:
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="maintenance_requests",
                target_id=None,
                details=f"Unauthorized attempt to approve maintenance for asset {asset_id}: {det}",
                level=LogLevel.CRITICAL
            )
        raise HTTPException(status_code=403, detail=det)

    maint_req = db.query(MaintenanceRequests).filter(MaintenanceRequests.asset_id == asset_id, MaintenanceRequests.status == "scheduled").first()
    if not maint_req:
        raise HTTPException(status_code=404, detail="scheduled maintenance not found")
    
    maint_req.status = "approved"
    db.commit()
    db.refresh(maint_req)

    if sys_logger:
        await enqueue_log(
            user_id=curr_user.id,
            action=ActionType.UPDATE,
            target_table="maintenance_requests",
            target_id=maint_req.id,
            details={"route": "approve"},
            level=LogLevel.INFO
        )
    
    return {"msg": "maintenance approved"}


@router.post("/{asset_id}/maintenance/start", status_code=200, response_model=MaintenanceResp)
async def start_maint(asset_id: str, req: MaintenanceStartReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    allowed = curr_user.id == db.query(Assets).filter(Assets.id == asset_id).first().owner_id or check_simple_permission(curr_user, "asset", "maintain")
    if not allowed:
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="maintenance_requests",
                target_id=None,
                details=f"Unauthorized attempt to start maintenance for asset {asset_id}",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")

    maint_req = db.query(MaintenanceRequests).filter(MaintenanceRequests.asset_id == asset_id, MaintenanceRequests.status == "approved").first()
    if not maint_req:
        raise HTTPException(status_code=404, detail="approved maintenance not found")
    
    maint_req.status = "in_progress"
    db.commit()
    db.refresh(maint_req)

    if sys_logger:
        await enqueue_log(
            user_id=curr_user.id,
            action=ActionType.UPDATE,
            target_table="maintenance_requests",
            target_id=maint_req.id,
            details={"route": "start"},
            level=LogLevel.INFO
        )
    
    return {"msg": "maintenance started"}


@router.post("/{asset_id}/maintenance/complete", status_code=200, response_model=MaintenanceCompleteResp)
async def complete_maint(asset_id: str, req: MaintenanceCompleteReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    allowed = curr_user.id == db.query(Assets).filter(Assets.id == asset_id).first().owner_id or check_simple_permission(curr_user, "asset", "maintain")
    if not allowed:
        if sys_logger:
            await enqueue_log(user_id=curr_user.id, action=ActionType.SUSPICIOUS_ACTIVITY, target_table="maintenance_requests", target_id=None, details=f"Unauthorized attempt to complete maintenance for asset {asset_id}", level=LogLevel.WARNING)
        raise HTTPException(status_code=403, detail="Not enough permissions")

    maint_req = db.query(MaintenanceRequests).filter(MaintenanceRequests.asset_id == asset_id, MaintenanceRequests.status == "in_progress").first()
    if not maint_req:
        raise HTTPException(status_code=404, detail="active maintenance not found")

    maint_req.status = "completed"
    maint_req.completed_at = datetime.now()
    if maint_req.started_at:
        maint_req.duration = maint_req.completed_at - maint_req.started_at
    maint_req.cost = req.cost

    maint_req.outcome = req.outcome
    maint_req.notes = req.notes

    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if asset and req.outcome == "fixed":
        asset.status = AssetStatus.OPERATIONAL

    db.commit()
    db.refresh(maint_req)

    if sys_logger:
        await enqueue_log(user_id=curr_user.id, action=ActionType.UPDATE, target_table="maintenance_requests", target_id=maint_req.id, details={"route": "complete", "payload": req.dict(exclude_unset=True)}, level=LogLevel.INFO)

    return {
        "id": maint_req.id,
        "asset_id": maint_req.asset_id,
        "status": maint_req.status,
        "started_at": maint_req.started_at,
        "completed_at": maint_req.completed_at,
        "duration": str(maint_req.duration) if maint_req.duration else None,
        "cost": float(maint_req.cost) if maint_req.cost else None,
        "paid_by": maint_req.paid_by,
        "outcome": maint_req.outcome,
        "notes": maint_req.notes
    }
@router.post("/{asset_id}/maintenance/complete", status_code=200, response_model=MaintenanceCompleteResp)
async def complete_maint(asset_id: str, req: MaintenanceCompleteReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    allowed = curr_user.id == db.query(Assets).filter(Assets.id == asset_id).first().owner_id or check_simple_permission(curr_user, "asset", "maintain")
    if not allowed:
        if sys_logger:
            await enqueue_log(user_id=curr_user.id, action=ActionType.SUSPICIOUS_ACTIVITY, target_table="maintenance_requests", target_id=None, details=f"Unauthorized attempt to complete maintenance for asset {asset_id}", level=LogLevel.WARNING)
        raise HTTPException(status_code=403, detail="Not enough permissions")

    maint_req = db.query(MaintenanceRequests).filter(MaintenanceRequests.asset_id == asset_id, MaintenanceRequests.status == "in_progress").first()
    if not maint_req:
        raise HTTPException(status_code=404, detail="active maintenance not found")

    maint_req.status = "completed"
    maint_req.completed_at = datetime.now()
    if maint_req.started_at:
        maint_req.duration = maint_req.completed_at - maint_req.started_at
    maint_req.cost = req.cost
    maint_req.paid_by = req.paid_by
    maint_req.outcome = req.outcome
    maint_req.notes = req.notes

    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if asset and req.outcome == "fixed":
        asset.status = AssetStatus.OPERATIONAL

    db.commit()
    db.refresh(maint_req)

    if sys_logger:
        await enqueue_log(user_id=curr_user.id, action=ActionType.UPDATE, target_table="maintenance_requests", target_id=maint_req.id, details={"route": "complete", "payload": req.dict(exclude_unset=True)}, level=LogLevel.INFO)

    return {
        "id": maint_req.id,
        "asset_id": maint_req.asset_id,
        "status": maint_req.status,
        "started_at": maint_req.started_at,
        "completed_at": maint_req.completed_at,
        "duration": str(maint_req.duration) if maint_req.duration else None,
        "cost": float(maint_req.cost) if maint_req.cost else None,
        "paid_by": maint_req.paid_by,
        "outcome": maint_req.outcome,
        "notes": maint_req.notes
    }

@router.get("/{asset_id}/maintenance/history", status_code=200, response_model=List[MaintenanceHistResp])
async def get_maint_hist(asset_id: str, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if not check_simple_permission(curr_user, "maintenance", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="maintenance_requests",
                target_id=None,
                details=f"Unauthorized attempt to fetch maintenance history for asset {asset_id}",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")

    hist = db.query(MaintenanceRequests).filter(MaintenanceRequests.asset_id == asset_id).all()

    if sys_logger:
        await enqueue_log(
            user_id=curr_user.id,
            action=ActionType.VIEW,
            target_table="maintenance_requests",
            target_id=None,
            details={"route": "history", "asset_id": asset_id},
            level=LogLevel.INFO
        )
    return hist


@router.get("/maintenance/upcoming", status_code=200, response_model=List[MaintenanceHistResp])
async def get_upcoming_maint(dept_id: str = None, start_date: date = None, end_date: date = None, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if not check_simple_permission(curr_user, "maintenance", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=curr_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="maintenance_requests",
                target_id=None,
                details="Unauthorized attempt to fetch upcoming maintenance",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")

    q = db.query(MaintenanceRequests).filter(MaintenanceRequests.status.in_(["scheduled", "approved"]))
    if dept_id:
        q = q.join(Assets).filter(Assets.department_id == dept_id)
    if start_date:
        q = q.filter(MaintenanceRequests.maintenance_date >= start_date)
    if end_date:
        q = q.filter(MaintenanceRequests.maintenance_date <= end_date)
    
    upcoming = q.all()

    if sys_logger:
        await enqueue_log(
            user_id=curr_user.id,
            action=ActionType.VIEW,
            target_table="maintenance_requests",
            target_id=None,
            details={"route": "upcoming", "dept_id": dept_id, "range": [start_date, end_date]},
            level=LogLevel.INFO
        )
    return upcoming
/routers/a_transfer.py
from fastapi import status, Depends,HTTPException,APIRouter
from sqlalchemy.orm import Session
from sqlalchemy import or_
from ..database import get_db
from ..utilities import generate_id,get_current_user

from ..schemas.assets import AssetTransfereInitiate,TransferStatusEnum,TransSearchParams
from ..models import User, AssetTransfers,Assets
from datetime import timezone, datetime

router = APIRouter(
    prefix="/api/v1/transfers",
    tags=["Assets Transfers"]
    )

@router.post("/initiate", status_code=status.HTTP_200_OK)
async def transfer_an_asset(det: AssetTransfereInitiate,curr_user : User = Depends(get_current_user),db: Session = Depends(get_db)):
    
    asset = db.query(Assets).filter(Assets.id == det.asset_id).first()
    transfa = AssetTransfers(
        id = generate_id(40),
        asset_id = det.asset_id,
        from_user_id = asset.responsible_officer_id,
        to_user_id = det.to_user_id,
        from_dept_id = asset.department_id,
        to_dept_id = det.to_dept_id,

        initiated_by = curr_user.id,
        initiated_date = datetime.now(timezone.utc),
        approved_by = None,
        approval_date = None,
        completed_date = None,

        status = TransferStatusEnum.INITIATED,
        transfer_reason = det.transfer_reason,
        remarks = det.remarks,
        )
    db.add(transfa)
    db.commit()
    db.refresh(transfa)

    return transfa


@router.get("/",status_code=200)
async def list_transfers_param( p : TransSearchParams = Depends() ,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    """_summary_

    Args:
        u_from : from user id.
        d_from : from department id.
        u_to : to user id
        d_to : department id destination
        init_by : id of initializer
        f_init_date : initialized from date 
        t_init_date : initialized upto date
        approv_by : who approved  id
        f_approv_date : transferes aproved from date
        t_approv_date : approved upto date
        status : status of approval, [initiated,apptoved,rejected,completed,cancelled]

    Returns:
        List : of all transfers matching filter
    """
    
    
    res = db.query(AssetTransfers)
    if p.u_from:
        res = res.filter(AssetTransfers.from_user_id == p.u_from)
    if p.d_from:
        res = res.filter(AssetTransfers.from_dept_id == p.d_from)
    if p.u_to: 
        res = res.filter(AssetTransfers.to_user_id == p.u_to)
    if p.d_to:
        res = res.filter(AssetTransfers.to_dept_id == p.d_to)
    if p.init_by:
        res = res.filter(AssetTransfers.initiated_by == p.init_by)
    if p.approv_by: 
        res = res.filter(AssetTransfers.approved_by == p.approv_by)
    if p.status:
        res = res.filter(AssetTransfers.status == status)

    if p.f_init_date and not p.t_init_date:
        res = res.filter(AssetTransfers.initiated_date >= p.f_init_date)
    elif p.t_init_date and not p.f_init_date:
        res = res.filter(AssetTransfers.initiated_date <= p.t_init_date)
    elif p.t_init_date and p.f_init_date:
        res = res.filter(AssetTransfers.initiated_date.between(p.f_init_date,p.t_init_date))


    if p.f_approv_date and not p.t_approv_date:
        res = res.filter(AssetTransfers.approval_date >= p.f_approv_date)
    elif p.t_approv_date and not p.f_approv_date:
        res = res.filter(AssetTransfers.approval_date <= p.f_approv_date)
    elif  p.t_approv_date and p.f_approv_date:
        res = res.filter(AssetTransfers.approval_date.between(p.f_approv_date,p.f_approv_date))
    return res

@router.get("/{trans_id}",status_code=200)
async def get_transfer_by_id(trans_id, curr: User = Depends(get_current_user), db: Session = Depends(get_db)):
    transf = db.query(AssetTransfers).filter(AssetTransfers.id == trans_id).first()
    if not transf:
        raise HTTPException(status_code=404, detail="transfer record not found")
    return transf

@router.post("/{trans_id}/approve",status_code=200)
async def approve_a_transfer(trans_id,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    transf = db.query(AssetTransfers).filter(AssetTransfers.id == trans_id).first()
    if not transf:
        raise HTTPException(status_code=404, detail="transfer record not found")
    transf.status = TransferStatusEnum.APPROVED
    db.commit()
    db.refresh(transf)
    return {"msg":"transfer approved"}


@router.post("/{trans_id}/complete",status_code=200)
async def approve_a_transfer(trans_id,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    transf = db.query(AssetTransfers).filter(AssetTransfers.id == trans_id).first()
    if not transf:
        raise HTTPException(status_code=404, detail="transfer record not found")
    transf.status = TransferStatusEnum.COMPLETED
    db.commit()
    db.refresh(transf)
    return {"msg":"transfer completed"}


@router.post("/{asset_id}/history",status_code=200)
async def get_asset_transfer_hist(asset_id,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    hist = db.query(AssetTransfers).filter(AssetTransfers.asset_id == asset_id).all()
    return hist

@router.post("/{trans_id}/reject")
async def reject_transfer_request(trans_id,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    transf = db.query(AssetTransfers).filter(AssetTransfers.id == trans_id).first()
    if not transf:
        raise HTTPException(status_code=404, detail="transfer record not found")
    transf.status = TransferStatusEnum.REJECTED
    db.commit()
    db.refresh(transf)
    return {"msg":"transfer rejected"}

    
@router.post("/{trans_id}/cancel")
async def cancel_a_transfer_request(trans_id,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)) :
    transf = db.query(AssetTransfers).filter(AssetTransfers.id == trans_id).first()
    if not transf:
        raise HTTPException(status_code=404, detail="transfer record not found")
    transf.status = TransferStatusEnum.CANCELLED
    db.commit()
    db.refresh(transf)
    return {"msg":"transfer cancelled"}  
  
@router.get("/pending")
async def list_all_pending_transfers(curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    p = db.query(AssetTransfers).filter(AssetTransfers.status == TransferStatusEnum.PENDING).all()

    return p

@router.get("/by-user/{user_id}")
async def show_all_user_transers(user_id,curr_user: User = Depends(get_current_user),db: Session = Depends(get_db)):

    p = db.query(AssetTransfers).filter(or_( AssetTransfers.to_user_id == user_id,AssetTransfers.from_user_id == user_id)).all()


    return p
/routers/other_supp_routes.py
from fastapi import APIRouter,Depends
from ..models import User,EntityType,GovLevel
from typing import Dict,List
from ..utilities import get_current_user

router = APIRouter(
    prefix="/api/v1/user/supp",
    tags=["GEneral Supporting routes"]
    )



@router.get("/entitytype",status_code=200,response_model=Dict[str, str])
async def list_entitiy_types(curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in EntityType}


@router.get("/govlevel",status_code=200,response_model=Dict[str, str])
async def show_goverment_levels (curr: User = Depends(get_current_user)):

    return {x.name: x.value for x in GovLevel}
/routers/a_crude.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_, func, desc, asc
from typing import  Optional, Dict
from sqlalchemy.exc import IntegrityError

import uuid

from decimal import Decimal
from ..database import get_db
from ..models import User, Departments,Assets, AssetLifecycleEvents
from ..schemas.assets import (
    AssetCreate, AssetUpdate, AssetResponse, AssetListResponse,
    AssetSearchParams, AssetStatusUpdate
)
from ..asset_utils import (
    validate_category_attributes,
    calculate_depreciation,
    generate_tag_number,get_required_fields,StandardAssetAttributes,LandAttributes,BuildingAttributes
)

from ..asset_utils import add_namedep_asset
from ..utilities import get_current_user

router = APIRouter(
    prefix="/api/v1/assets",
    tags=["Assets CRUD"]
    )



def create_lifecycle_event(
    db: Session, 
    asset_id: str, 
    event_type: str, 
    user_id: str, 
    details: Optional[Dict] = None,
    remarks: Optional[str] = None
):

    event = AssetLifecycleEvents(
        asset_id=asset_id,
        event_type=event_type,
        performed_by=user_id,
        details=details or {},
        remarks=remarks
    )
    db.add(event)
    return event

def gen_asset_tag(db: Session, category: str, department_id: str) -> str:
    dept = db.query(Departments).filter(Departments.dept_id == department_id).first()
    dept_code = dept.name[:3].upper() if dept else "DEP"
    
    # Get nxt seq no
    last_asset = db.query(Assets).filter(
        Assets.department_id == department_id,
        Assets.category == category,
        Assets.is_deleted == False
    ).count()
    
    sequence = last_asset + 1
    return generate_tag_number(category, dept_code, sequence)




@router.post("/")# response_model=AssetResponse)
async def create_a_new_asset(asset_data: AssetCreate,db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):

    if asset_data.specific_attributes:
        try:
            validated_attrs = validate_category_attributes(
                asset_data.category, 
                asset_data.specific_attributes
            )
            asset_data.specific_attributes = validated_attrs
        except ValueError as e:
            raise HTTPException(status_code=400, detail=str(e))
    
    if not asset_data.tag_number:
        asset_data.tag_number = gen_asset_tag(
            db, asset_data.category, asset_data.department_id
        )

    existing_asset = db.query(Assets).filter(Assets.tag_number == asset_data.tag_number, Assets.is_deleted == False).first()
    if existing_asset:
        raise HTTPException(status_code=400, detail="Tag number already exists")
    
    asset = Assets(id=str(uuid.uuid4()), created_by=current_user.id, **asset_data.dict())
    
    if asset.acquisition_cost and asset.depreciation_rate and asset.acquisition_date:

        depreciation = calculate_depreciation(asset.acquisition_cost, asset.depreciation_rate, asset.acquisition_date)
        asset.current_value = depreciation["net_book_value"]
    else:
        asset.current_value = asset.acquisition_cost
    try:
        db.add(asset)
        # db.refresh(asset)  # Get the ID
    except IntegrityError:
        raise HTTPException(status_code=400, detail="Department Does not exist")

    #like logging
    # create_lifecycle_event(
        
    #     db, asset.id, "created", current_user.id,id = generate_id(),
    #     details={"category": asset.category, "initial_value": str(asset.acquisition_cost)},
    #     remarks="Asset created in system"
    # )
    
    db.commit()
    db.refresh(asset)
    
    return AssetResponse(**add_namedep_asset(asset))



@router.get("/categories", status_code=200)
def list_asset_categories_simple():   
    categories = {
        "Standard Assets": StandardAssetAttributes,
        "Land": LandAttributes,
        "Buildings and building improvements": BuildingAttributes,
    } 
    result = {}
    for c_name, schema_class in categories.items():
        required_fields = get_required_fields(c_name)
        
        all = list(schema_class.__annotations__.keys())
        
        result[c_name] = {
            "required_fields": required_fields,
            "all_fields": all
        }
    return result


@router.get("/", response_model=AssetListResponse)
async def list_assets_search_func(
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    category: Optional[str] = None,
    status: Optional[str] = None,
    department_id: Optional[str] = None,
    search: Optional[str] = None,
    db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):
    query = db.query(Assets).filter(Assets.is_deleted == False)

    if category:
        query = query.filter(Assets.category == category)
    if status:
        query = query.filter(Assets.status == status)
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if search:
        search_term = f"%{search}%"
        query = query.filter(
            or_(
                Assets.description.ilike(search_term),
                Assets.tag_number.ilike(search_term),
                Assets.serial_number.ilike(search_term),
                Assets.location.ilike(search_term)
            )
        )
    
    total = query.count()
    offset = (page - 1) * size
    assets = query.options(
        joinedload(Assets.department),
        joinedload(Assets.responsible_officer)
    ).offset(offset).limit(size).all()
    
    total_pages = (total + size - 1) // size
    
    return AssetListResponse(assets=assets, total=total, page=page, size=size, total_pages=total_pages)

@router.get("/{asset_id}", response_model=AssetResponse)
async def get_asset_by_id(
    asset_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):  
    asset = db.query(Assets).options(
        joinedload(Assets.department),
        joinedload(Assets.responsible_officer)
    ).filter(Assets.id == asset_id, Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    return AssetResponse(**add_namedep_asset(asset))



@router.put("/{asset_id}", response_model=AssetResponse)
async def update_asset(asset_id: str, asset_data: AssetUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)
):    
    asset = db.query(Assets).filter(Assets.id == asset_id, Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")

    if asset_data.specific_attributes:
        try:
            validated_attrs = validate_category_attributes(
                asset.category, 
                asset_data.specific_attributes
            )
            asset_data.specific_attributes = validated_attrs
        except ValueError as e:
            raise HTTPException(status_code=400, detail=str(e))
    
    changes = {}
    update_data = asset_data.dict(exclude_none=True)
    
    for field, nval in update_data.items():
        oval = getattr(asset, field)
        if oval != nval:
            changes[field] = {"old": str(oval), "new": str(nval)}
            setattr(asset, field, nval)
    
    # Recalculate depreciation if changes
    if any(field in changes for field in ['acquisition_cost', 'depreciation_rate', 'acquisition_date']):
        if asset.acquisition_cost and asset.depreciation_rate and asset.acquisition_date:
            depreciation = calculate_depreciation(asset.acquisition_cost,  asset.depreciation_rate,  asset.acquisition_date)
            asset.current_value = depreciation["net_book_value"]
            changes['current_value'] = {"new": str(asset.current_value)}
    
    if changes:
        create_lifecycle_event(
            db, asset.id, "updated", current_user.id,
            details={"changes": changes},
            remarks="Asset information updated"
        )
    
    db.commit()
    db.refresh(asset)
    
    return AssetResponse(**add_namedep_asset(asset))

@router.patch("/{asset_id}/status", response_model=AssetResponse)
async def update_asset_status(asset_id: str, status_data: AssetStatusUpdate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):

    asset = db.query(Assets).filter(Assets.id == asset_id, Assets.is_deleted == False).first()


    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    old_status = asset.status
    asset.status = status_data.status
    
    create_lifecycle_event(db, asset.id, "status_changed", current_user.id,
        details={
            "old_status": old_status,
            "new_status": status_data.status
        },
        remarks=status_data.remarks or f"Status changed from {old_status} to {status_data.status}"
    )
    
    db.commit()
    db.refresh(asset)
    
    return AssetResponse(**add_namedep_asset(asset))

@router.delete("/{asset_id}")
async def delete_asset(asset_id: str, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    asset = db.query(Assets).filter(Assets.id == asset_id, Assets.is_deleted == False).first()
    
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    
    asset.is_deleted = True
    
    create_lifecycle_event(db, asset.id, "deleted", current_user.id, remarks="Asset deleted from system")
    db.commit()
    
    return {"message": "Asset deleted successfully"}

@router.get("/a/search/advanced", response_model=AssetListResponse)
async def advanced_asset_search_adm(params: AssetSearchParams = Depends(),db: Session = Depends(get_db), cu: User =  Depends(get_current_user)):
 
    query = db.query(Assets).filter(Assets.is_deleted == False)

    if params.query:
        search_term = f"%{params.query}%"
        query = query.filter(
            or_(
                Assets.description.ilike(search_term),
                Assets.tag_number.ilike(search_term),
                Assets.serial_number.ilike(search_term)
       
            )
        )
    
    if params.category:
        query = query.filter(Assets.category == params.category)
    if params.status:
        query = query.filter(Assets.status == params.status)
    if params.condition:
        query = query.filter(Assets.condition == params.condition)
    if params.department_id:
        query = query.filter(Assets.department_id == params.department_id)
    if params.responsible_officer_id:
        query = query.filter(Assets.responsible_officer_id == params.responsible_officer_id)
    if params.location:
        query = query.filter(Assets.location.ilike(f"%{params.location}%"))
    if params.min_value:
        query = query.filter(Assets.current_value >= params.min_value)
    if params.max_value:
        query = query.filter(Assets.current_value <= params.max_value)
    if params.acquisition_date_from:
        query = query.filter(Assets.acquisition_date >= params.acquisition_date_from)
    if params.acquisition_date_to:
        query = query.filter(Assets.acquisition_date <= params.acquisition_date_to)
    
    sort_column = getattr(Assets, params.sort_by, Assets.created_at)
    if params.sort_order == "asc":
        query = query.order_by(asc(sort_column))
    else:
        query = query.order_by(desc(sort_column))
    
    total = query.count()
    
    offset = (params.page - 1) * params.size
    assets = query.options(joinedload(Assets.department),joinedload(Assets.responsible_officer)).offset(offset).limit(params.size).all()
    
    total_pages = (total + params.size - 1) // params.size
    
    return AssetListResponse(assets=assets, total=total, page=params.page, size=params.size, total_pages=total_pages)

/routers/departments.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional,Union,Any,Dict
from ..database import get_db
from ..models import Role, User, Departments
from ..utilities import generate_id,get_current_user,get_changes
from ..system_vars import sys_logger,debugging,default_new_department_status
from ..services.logger_queue import enqueue_log
from ..schemas.main import DepartmentDetails,DepartmentDetailsSimple, DepartmentStatus, CreateDepartment, UserStatus,NoChangesResponse,DepartmentUsers,DepartmentDetailsPublic,UserStatus
from ..services.policy_eval import check_simple_permission,check_full_permission,get_user_perms
from sqlalchemy import or_, func
from datetime import datetime, timezone
from sqlalchemy.orm import joinedload

router = APIRouter(
    prefix="/api/v1/departments", 
    tags=["Departments "]
    )



@router.post("/", status_code=status.HTTP_201_CREATED, response_model=DepartmentDetails)
async def create_department(dep: CreateDepartment,curr: User = Depends(get_current_user),db:Session = Depends(get_db)):
    
    id = generate_id(40)
    det = Departments(
        dept_id = id,
        name = dep.name,
        parent_dept_id = dep.parent_dept_id ,
        entity_type = dep.entity_type ,
        description = dep.description ,
        status = default_new_department_status 
    )
    db.add(det)
    db.commit()
    db.refresh(det)
    return det

@router.get("/",status_code=status.HTTP_200_OK,response_model=List[DepartmentDetails])
async def list_all_departments(curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    
    deps = db.query(Departments).all()
    return deps

@router.get("/simple",status_code=status.HTTP_200_OK,response_model=List[DepartmentDetailsSimple])
async def list_all_departments_simple(curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    
    deps = db.query(Departments).all()
    return deps


@router.get("/public",status_code=status.HTTP_200_OK,response_model=List[DepartmentDetailsPublic])
async def list_all_departments_public(db: Session = Depends(get_db)):
    """Lists all active departments"""
    
    deps = db.query(Departments).filter(Departments.status == UserStatus.active).all()
    return deps

@router.get("/heads",status_code=status.HTTP_200_OK,response_model=List[DepartmentDetailsPublic])
async def list_all_departments_public(db: Session = Depends(get_db)):
    """Lists all  departments Heads"""
    
    deps = db.query(Departments).filter(Departments.status == UserStatus.active).all()
    return deps


@router.get("/{dep_id}/users",status_code=status.HTTP_200_OK,response_model=List[DepartmentUsers])
async def get_department_members(dep_id,curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    users = db.query(User).filter(User.department_id == dep_id).all()
    return users

@router.get("/{dep_id}/hierarchy",status_code=status.HTTP_200_OK )
async def get_department_hierachy(dep_id,curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    def build_hierarchy(dept) -> Dict[str, Any]:
        return {
            "dept_id": dept.dept_id,
            "name": dept.name,
            "entity_type": dept.entity_type.name if dept.entity_type else None,
            "description": dept.description,
            "status": dept.status.name if dept.status else None,
            "sub_departments": [build_hierarchy(sub) for sub in dept.sub_departments]
        }
    
    dept = db.query(Departments).filter(Departments.dept_id == dep_id).first()
    if not dept:
        raise HTTPException(status_code=404, detail="Department not found")
    
    return build_hierarchy(dept)

@router.post("/{dep_id}/status",status_code=status.HTTP_200_OK,response_model=Union[dict ,NoChangesResponse])
async def change_department_status(dep_id,stats: DepartmentStatus,curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    
    dep = db.query(Departments).filter(Departments.dept_id == dep_id).first()

    if dep.status == stats.status:
        return {"details": "No change applied"}

    dep.status = stats.status

    db.commit()
    db.refresh(dep)
    return {"detail": f"changed status to: {dep.status.value}"}



@router.get("/{dep_id}",status_code=status.HTTP_200_OK,response_model=DepartmentDetails)
async def get_department_by_id(dep_id,curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    
    
    deps = db.query(Departments).filter(Departments.dept_id == dep_id).first()
    if not deps:
         raise HTTPException(status_code=404, detail="Department not found")
    return deps


@router.delete("/{dep_id}",status_code=status.HTTP_200_OK,response_model=dict)
async def delete_a_department(dep_id,curr: User = Depends(get_current_user),db: Session = Depends(get_db)):

    deps = db.query(Departments).filter(Departments.dept_id == dep_id).first()
    if not deps:
        raise HTTPException(status_code=404, detail="Department not found")
    deps.status = UserStatus.deleted
    db.commit()
    db.refresh(deps)
    return {"detail": "Successfully Deleted"}


@router.put("/{dep_id}",status_code=status.HTTP_200_OK,response_model=Union[dict ,NoChangesResponse])
async def patch_department_details(dep_id,det:CreateDepartment, curr: User = Depends(get_current_user),db: Session = Depends(get_db)):
    

    deps = db.query(Departments).filter(Departments.dept_id == dep_id).first()
    if not deps:
         raise HTTPException(status_code=404, detail="Department not found")

    upd ,changes= get_changes(deps,det)
    
    if changes:
        
        db.commit()
        db.refresh(upd)
        return {"changes": changes}
    
    return {"detail": "No changes supplied"}


/routers/auth22.py
from fastapi import Depends, HTTPException, status, APIRouter, Query, Request, BackgroundTasks
from ..models import User, DeviceFingerprint, IPWhitelist, LoginAttempt, MFACode,TempDisableLog
from ..utilities import get_current_user, pwd_context, generate_id, create_access_token, create_refresh_token, oauth2_scheme, check_token, revoke_tokens, SECRET_KEY, ALGORITHM, get_user_id, revoke_tokens_byid
from ..schemas.secc import LoginRequestSecurity, TokenOutSecurity, MFAVerifyRequest, WhitelistIPRequest, DeviceOut, LoginAttemptOut, ForcePasswordChangeRequest, UnlockAccountRequest
from ..schemas.main import UserStatus
from sqlalchemy.orm import Session
from ..database import get_db
from datetime import datetime, timedelta, timezone
from ..system_vars import ACCESS_TOKEN_EXPIERY, send_emails, sys_logger
from ..services.emailsender import AssetFlowEmailService
from ..sec_utils import *


from ..system_vars import (
    KNOWN_DEVICE_MAX_ATTEMPTS, UNKNOWN_DEVICE_MAX_ATTEMPTS, TEMP_DISABLE_DURATION_HOURS, 
    FINAL_ATTEMPTS_BEFORE_LOCK, FRAUD_SCORE_LIMIT,
    EXPECTED_TIMEZONE, EXPECTED_LANGUAGE, 
    IP_WHITELIST_THRESHOLD, MFA_CODE_EXPIRY_MINUTES
)
from ..services.logger_queue import enqueue_log
from ..schemas.main import  ActionType, LogLevel
import os
from typing import List
from dotenv import load_dotenv

load_dotenv(dotenv_path="./fapi/.env")

if send_emails:
    email_service = AssetFlowEmailService(api_key=os.getenv("SENDINBLUE_API_KEY", "kk"))

router = APIRouter(tags=['Authentication New'], prefix="/api/v1/auth/2")

def get_client_ip(request: Request) -> str:
    if "x-forwarded-for" in request.headers:
        return request.headers["x-forwarded-for"].split(",")[0].strip()
    return request.client.host if request.client else "unknown"

def extract_device_info(request: Request) -> dict:
    user_agent = request.headers.get("user-agent", "")
    return {
        "user_agent": user_agent,
        "accept_language": request.headers.get("accept-language", ""),
        "accept_encoding": request.headers.get("accept-encoding", "")
    }

@router.post("/login", response_model=TokenOutSecurity, status_code=status.HTTP_200_OK)
async def login(login_req: LoginRequestSecurity, request: Request, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    ip_address = get_client_ip(request)
    device_info = extract_device_info(request)
    
    fingerprint_hash = hash_fingerprint(login_req.fingerprint)
    user_timezone = login_req.timezone or "unknown"
    user_language = login_req.language or "unknown"
    
    user = db.query(User).filter(User.email == login_req.email).first()
    
    if not user or not pwd_context.verify(login_req.password, user.password_hash):
        if user:
            login_attempt = LoginAttempt(
                id=generate_id(),
                user_id=user.id,
                email=login_req.email,
                ip_address=ip_address,
                fingerprint_hash=fingerprint_hash,
                success=False,
                failure_reason="Invalid credentials",
                device_info=device_info,
                timezone=user_timezone,
                language=user_language
            )
            db.add(login_attempt)
            
            user.login_attempts += 1
            
            device_known = is_device_known(user.id, fingerprint_hash, db)
            
            if device_known:
                if user.login_attempts >= KNOWN_DEVICE_MAX_ATTEMPTS:
                    if user.status != UserStatus.temp_disabled:
                        temp_disable_account(user, "Too many failed login attempts from known device", db)
                        if send_emails:
                            background_tasks.add_task(email_service.send_account_temp_disabled_email, user.email, user.first_name, TEMP_DISABLE_DURATION_HOURS)
                        if sys_logger:
                            await enqueue_log(user_id=user.id, action=ActionType.ACCOUNT_LOCKED, target_table="users", target_id=user.id, details={"reason": "max_attempts_known_device", "ip": ip_address}, level=LogLevel.WARNING)
                    else:
                        temp_disabled_count = get_failed_attempts_count(user.id, user.temp_disabled_until - timedelta(hours=TEMP_DISABLE_DURATION_HOURS), db) if user.temp_disabled_until else 0
                        if temp_disabled_count >= FINAL_ATTEMPTS_BEFORE_LOCK:
                            deactivate_account(user, "Failed login attempts after temp disable", db)
                            if send_emails:
                                background_tasks.add_task(email_service.send_account_suspended_email, user.email, user.first_name)
                            if sys_logger:
                                await enqueue_log(user_id=user.id, action=ActionType.ACCOUNT_LOCKED, target_table="users", target_id=user.id, details={"reason": "max_attempts_after_temp_disable", "ip": ip_address}, level=LogLevel.CRITICAL)
            else:
                if user.login_attempts >= UNKNOWN_DEVICE_MAX_ATTEMPTS:
                    deactivate_account(user, "Failed login attempts from unknown device", db)
                    if send_emails:
                        background_tasks.add_task(email_service.send_account_suspended_email, user.email, user.first_name)
                    if sys_logger:
                        await enqueue_log(user_id=user.id, action=ActionType.ACCOUNT_LOCKED, target_table="users", target_id=user.id, details={"reason": "max_attempts_unknown_device", "ip": ip_address}, level=LogLevel.CRITICAL)
            
            db.commit()
        
        raise HTTPException(status_code=401, detail="Invalid email or password")
    
    if is_account_temp_disabled(user):
        hours_remaining = (user.temp_disabled_until - datetime.now(timezone.utc)).total_seconds() / 3600
        raise HTTPException(status_code=403, detail=f"Account temporarily disabled. Try again in {hours_remaining:.1f} hours")
    
    if user.status == UserStatus.temp_disabled and user.temp_disabled_until and datetime.now(timezone.utc) >= user.temp_disabled_until:
        user.status = UserStatus.active
        user.login_attempts = 0
        db.query(TempDisableLog).filter(TempDisableLog.user_id == user.id, TempDisableLog.is_active == True).update({"is_active": False})
        db.commit()
    
    if user.status == UserStatus.deleted:
        raise HTTPException(status_code=401, detail="Account no longer exists, contact support")
    
    if user.status == UserStatus.inactive and user.last_login is None:
        raise HTTPException(status_code=401, detail="Account awaiting activation, contact support")
    
    if user.status == UserStatus.suspended:
        raise HTTPException(status_code=401, detail="Account suspended, contact support")
    
    if user.status != UserStatus.active:
        raise HTTPException(status_code=401, detail="Account not active, contact support")
    
    is_suspicious, ip_det_reason = check_ip_det(ip_address)
    fraud_score = 0
    
    if is_suspicious:
        fraud_score = 100
        login_attempt = LoginAttempt(
            id=generate_id(),
            user_id=user.id,
            email=login_req.email,
            ip_address=ip_address,
            fingerprint_hash=fingerprint_hash,
            success=False,
            failure_reason=f"Suspicious IP detected: {ip_det_reason}",
            device_info=device_info,
            timezone=user_timezone,
            language=user_language,
            ip_details={"suspicious": True, "reason": ip_det_reason},
            fraud_score=fraud_score
        )
        db.add(login_attempt)
        
        temp_disable_account(user, f"Login from suspicious IP: {ip_det_reason}", db)
        
        if send_emails:
            background_tasks.add_task(email_service.send_suspicious_login_blocked_email, user.email, user.first_name, ip_address, ip_det_reason)
        
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.SUSPICIOUS_ACTIVITY, target_table="users", target_id=user.id, details={"ip": ip_address, "reason": ip_det_reason}, level=LogLevel.CRITICAL)
        
        raise HTTPException(status_code=403, detail="Login blocked due to suspicious activity. Account temporarily disabled.")
    
    device_known = is_device_known(user.id, fingerprint_hash, db)
    ip_whitelisted = is_ip_whitelisted(user.id, ip_address, db)
    
    require_mfa = False
    mfa_reason = ""
    
    if not device_known:
        require_mfa = True
        mfa_reason = "new_device"
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.NEW_DEVICE_DETECTED, target_table="device_fingerprints", target_id=fingerprint_hash, details={"ip": ip_address, "device_info": device_info}, level=LogLevel.WARNING)
    
    if check_last_login_expiry(user):
        require_mfa = True
        mfa_reason = "last_login_30_days"
    
    if user_timezone != EXPECTED_TIMEZONE and user_timezone != "unknown":
        require_mfa = True
        mfa_reason = "timezone_mismatch"
        
        temp_disable_account(user, f"Login from unexpected timezone: {user_timezone}", db)
        
        unlock_token = create_unlock_account_token(user.id, user.email)
        
        if send_emails:
            background_tasks.add_task(email_service.send_timezone_mismatch_email, user.email, user.first_name, user_timezone, ip_address, device_info, unlock_token)
        
        dept_heads = get_dept_heads(user, db)
        system_notification_handler(["security", "dept_head"], f"User {user.email} attempted login from timezone {user_timezone}")
        
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.SUSPICIOUS_ACTIVITY, target_table="users", target_id=user.id, details={"ip": ip_address, "timezone": user_timezone, "expected": EXPECTED_TIMEZONE}, level=LogLevel.WARNING)
        
        raise HTTPException(status_code=403, detail="Login blocked due to timezone mismatch. Check your email for unlock instructions.")
    
    if user_language != EXPECTED_LANGUAGE and user_language != "unknown":
        require_mfa = True
        mfa_reason = "language_mismatch"
    
    if not is_within_working_hours():
        require_mfa = True
        mfa_reason = "outside_working_hours"
        
        dept_heads = get_dept_heads(user, db)
        
        if send_emails:
            background_tasks.add_task(email_service.send_out_of_hours_login_notification, user.email, user.first_name, ip_address, device_info)
            for head in dept_heads:
                background_tasks.add_task(email_service.send_out_of_hours_login_notification_admin, head.email, head.first_name, user.email, ip_address, device_info)
        
        system_notification_handler(["me", "dept_head"], f"Out of hours login attempt by {user.email} from {ip_address}")
        
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.WORKING_HOURS_VIOLATION, target_table="users", target_id=user.id, details={"ip": ip_address, "time": datetime.now(timezone.utc).isoformat()}, level=LogLevel.WARNING)
    
    if fraud_score > FRAUD_SCORE_LIMIT:
        require_mfa = True
        mfa_reason = "high_fraud_score"
    
    password_expired = check_password_expiry(user)
    
    login_attempt = LoginAttempt(
        id=generate_id(),
        user_id=user.id,
        email=login_req.email,
        ip_address=ip_address,
        fingerprint_hash=fingerprint_hash,
        success=True,
        device_info=device_info,
        timezone=user_timezone,
        language=user_language,
        ip_details={"suspicious": is_suspicious, "reason": ip_det_reason},
        fraud_score=fraud_score
    )
    db.add(login_attempt)
    
    user.login_attempts = 0
    
    if not ip_whitelisted:
        successful_logins = count_successful_logins_from_ip(user.id, ip_address, db)
        if successful_logins >= IP_WHITELIST_THRESHOLD:
            whitelist_entry = IPWhitelist(
                id=generate_id(),
                user_id=user.id,
                ip_address=ip_address,
                whitelist_type="auto"
            )
            db.add(whitelist_entry)
            if sys_logger:
                await enqueue_log(user_id=user.id, action=ActionType.CREATE, target_table="ip_whitelist", target_id=whitelist_entry.id, details={"ip": ip_address, "type": "auto"}, level=LogLevel.INFO)
    
    db.commit()
    
    if require_mfa or password_expired:
        temp_session_token = create_temp_session_token(user.id, user.email)
        
        if require_mfa:
            mfa_code = generate_mfa_code()
            mfa_expires = datetime.now(timezone.utc) + timedelta(minutes=MFA_CODE_EXPIRY_MINUTES)
            
            mfa_record = MFACode(
                id=generate_id(),
                user_id=user.id,
                code=mfa_code,
                temp_session_token=temp_session_token,
                expires_at=mfa_expires,
                ip_address=ip_address
            )
            db.add(mfa_record)
            db.commit()
            
            if send_emails:
                background_tasks.add_task(email_service.send_mfa_code_email, user.email, user.first_name, mfa_code, MFA_CODE_EXPIRY_MINUTES)
            
            if sys_logger:
                await enqueue_log(user_id=user.id, action=ActionType.TWO_FA_SENT, target_table="mfa_codes", target_id=mfa_record.id, details={"reason": mfa_reason, "ip": ip_address}, level=LogLevel.INFO)
            
            if not device_known:
                if send_emails:
                    background_tasks.add_task(email_service.send_new_device_login_notification, user.email, user.first_name, ip_address, device_info)
        
        return TokenOutSecurity(
            token_type="temp_session",
            req_mfa=1 if require_mfa else 0,
            pass_change=password_expired,
            temp_session_token=temp_session_token
        )
    
    if user.position_title == 'member':
        rolem = user.position_title
    elif user.role_id == '3fef8a21e7f53606402fcd4f692746':
        rolem = "superadmin"
    elif user.role_id == 'role_006':
        rolem = "admin"
    else:
        rolem = "member"
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIERY)
    access_token = create_access_token(
        data={"sub": user.email, "id": user.id, "role": rolem, "username": user.first_name, "dept_id": user.department_id},
        expires_delta=access_token_expires,
        db=db
    )
    
    if login_req.remember_me:
        refresh_token_expiery = timedelta(days=7)
    else:
        refresh_token_expiery = access_token_expires
    
    refresh_token = create_refresh_token(
        data={"sub": user.email, "user_id": user.id},
        expires_delta=refresh_token_expiery,
        db=db
    )
    
    if not device_known:
        device = DeviceFingerprint(
            id=generate_id(),
            user_id=user.id,
            fingerprint_hash=fingerprint_hash,
            device_info=device_info,
            ip_at_registration=ip_address,
            is_trusted=True
        )
        db.add(device)
    else:
        db.query(DeviceFingerprint).filter(
            DeviceFingerprint.user_id == user.id,
            DeviceFingerprint.fingerprint_hash == fingerprint_hash
        ).update({"last_seen": datetime.now(timezone.utc)})
    
    user.last_login = datetime.now(timezone.utc)
    db.commit()
    
    if sys_logger:
        await enqueue_log(user_id=user.id, action=ActionType.LOGIN, target_table="users", target_id=user.id, details={"ip": ip_address, "device": device_info}, level=LogLevel.INFO)
    
    return TokenOutSecurity(
        access_token=access_token,
        refresh_token=refresh_token,
        role=rolem,
        dept_id=user.department_id,
        token_type="bearer",
        a_expires=ACCESS_TOKEN_EXPIERY * 60,
        req_mfa=0,
        pass_change=False
    )

@router.post("/verify-mfa", response_model=TokenOutSecurity, status_code=status.HTTP_200_OK)
async def verify_mfa(mfa_req: MFAVerifyRequest, request: Request, db: Session = Depends(get_db)):
    ip_address = get_client_ip(request)
    
    payload = decode_temp_session_token(mfa_req.temp_session_token)
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired session token")
    
    user = db.query(User).filter(User.id == payload["user_id"]).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    mfa_record = db.query(MFACode).filter(
        MFACode.temp_session_token == mfa_req.temp_session_token,
        MFACode.used == False
    ).first()
    
    if not mfa_record:
        raise HTTPException(status_code=401, detail="Invalid MFA session")
    
    if datetime.now(timezone.utc) > mfa_record.expires_at:
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.TWO_FA_FAILED, target_table="mfa_codes", target_id=mfa_record.id, details={"reason": "expired", "ip": ip_address}, level=LogLevel.WARNING)
        raise HTTPException(status_code=401, detail="MFA code expired")
    
    if mfa_record.code != mfa_req.mfa_code:
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.TWO_FA_FAILED, target_table="mfa_codes", target_id=mfa_record.id, details={"reason": "invalid_code", "ip": ip_address}, level=LogLevel.WARNING)
        raise HTTPException(status_code=401, detail="Invalid MFA code")
    
    mfa_record.used = True
    db.commit()
    
    if user.position_title == 'member':
        rolem = user.position_title
    elif user.role_id == '3fef8a21e7f53606402fcd4f692746':
        rolem = "superadmin"
    elif user.role_id == 'role_006':
        rolem = "admin"
    else:
        rolem = "member"
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIERY)
    access_token = create_access_token(
        data={"sub": user.email, "id": user.id, "role": rolem, "username": user.first_name, "dept_id": user.department_id},
        expires_delta=access_token_expires,
        db=db
    )
    
    refresh_token = create_refresh_token(
        data={"sub": user.email, "user_id": user.id},
        expires_delta=access_token_expires,
        db=db
    )
    
    user.last_login = datetime.now(timezone.utc)
    db.commit()
    
    if sys_logger:
        await enqueue_log(user_id=user.id, action=ActionType.TWO_FA_VERIFIED, target_table="mfa_codes", target_id=mfa_record.id, details={"ip": ip_address}, level=LogLevel.INFO)
    
    return TokenOutSecurity(
        access_token=access_token,
        refresh_token=refresh_token,
        role=rolem,
        dept_id=user.department_id,
        token_type="bearer",
        a_expires=ACCESS_TOKEN_EXPIERY * 60,
        req_mfa=0,
        pass_change=False
    )

@router.post("/force-password-change", status_code=status.HTTP_200_OK)
async def force_password_change(pass_req: ForcePasswordChangeRequest, request: Request, db: Session = Depends(get_db)):
    ip_address = get_client_ip(request)
    
    payload = decode_temp_session_token(pass_req.temp_session_token)
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired session token")
    
    user = db.query(User).filter(User.id == payload["user_id"]).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    hashed_pass = pwd_context.hash(pass_req.new_password)
    user.password_hash = hashed_pass
    user.last_password_change = datetime.now(timezone.utc)
    user.login_attempts = 0
    
    revoke_tokens_byid(user.id, db)
    
    db.commit()
    
    if sys_logger:
        await enqueue_log(user_id=user.id, action=ActionType.PASSWORD_CHANGE, target_table="users", target_id=user.id, details={"ip": ip_address, "forced": True}, level=LogLevel.INFO)
    
    return {"message": "Password changed successfully. Please login again."}

@router.post("/whitelist-ip", status_code=status.HTTP_200_OK)
async def whitelist_ip(whitelist_req: WhitelistIPRequest, request: Request, background_tasks: BackgroundTasks, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    ip_address = get_client_ip(request)
    
    mfa_record = db.query(MFACode).filter(
        MFACode.user_id == current_user.id,
        MFACode.code == whitelist_req.mfa_code,
        MFACode.used == False
    ).order_by(MFACode.created_at.desc()).first()
    
    if not mfa_record:
        raise HTTPException(status_code=401, detail="Invalid MFA code")
    
    if datetime.now(timezone.utc) > mfa_record.expires_at:
        raise HTTPException(status_code=401, detail="MFA code expired")
    
    mfa_record.used = True
    
    existing = db.query(IPWhitelist).filter(
        IPWhitelist.user_id == current_user.id,
        IPWhitelist.ip_address == ip_address
    ).first()
    
    if existing:
        raise HTTPException(status_code=400, detail="IP already whitelisted")
    
    whitelist_entry = IPWhitelist(
        id=generate_id(),
        user_id=current_user.id,
        ip_address=ip_address,
        whitelist_type="manual"
    )
    db.add(whitelist_entry)
    db.commit()
    
    if sys_logger:
        await enqueue_log(user_id=current_user.id, action=ActionType.CREATE, target_table="ip_whitelist", target_id=whitelist_entry.id, details={"ip": ip_address, "type": "manual"}, level=LogLevel.INFO)
    
    return {"message": "IP address whitelisted successfully"}

@router.get("/devices", response_model=List[DeviceOut], status_code=status.HTTP_200_OK)
async def list_devices(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    devices = db.query(DeviceFingerprint).filter(
        DeviceFingerprint.user_id == current_user.id,
        DeviceFingerprint.is_deleted == False
    ).order_by(DeviceFingerprint.last_seen.desc()).all()
    
    return devices

@router.delete("/devices/{fingerprint_hash}", status_code=status.HTTP_200_OK)
async def forget_device(fingerprint_hash: str, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    device = db.query(DeviceFingerprint).filter(
        DeviceFingerprint.user_id == current_user.id,
        DeviceFingerprint.fingerprint_hash == fingerprint_hash,
        DeviceFingerprint.is_deleted == False
    ).first()
    
    if not device:
        raise HTTPException(status_code=404, detail="Device not found")
    
    device.is_deleted = True
    db.commit()
    
    if sys_logger:
        await enqueue_log(user_id=current_user.id, action=ActionType.DELETE, target_table="device_fingerprints", target_id=device.id, details={"fingerprint_hash": fingerprint_hash}, level=LogLevel.INFO)
    
    return {"message": "Device forgotten successfully"}

@router.get("/login-history", response_model=List[LoginAttemptOut], status_code=status.HTTP_200_OK)
async def get_login_history(limit: int = Query(20, le=100), current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    attempts = db.query(LoginAttempt).filter(
        LoginAttempt.user_id == current_user.id
    ).order_by(LoginAttempt.timestamp.desc()).limit(limit).all()
    
    return attempts

@router.post("/unlock-account", status_code=status.HTTP_200_OK)
async def unlock_account(unlock_req: UnlockAccountRequest, request: Request, db: Session = Depends(get_db)):
    ip_address = get_client_ip(request)
    
    payload = decode_unlock_account_token(unlock_req.token)
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired unlock token")
    
    user = db.query(User).filter(User.id == payload["user_id"]).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    if user.status == UserStatus.temp_disabled:
        user.status = UserStatus.active
        user.temp_disabled_until = None
        user.login_attempts = 0
        
        db.query(TempDisableLog).filter(
            TempDisableLog.user_id == user.id,
            TempDisableLog.is_active == True
        ).update({"is_active": False})
        
        db.commit()
        
        if sys_logger:
            await enqueue_log(user_id=user.id, action=ActionType.ACCOUNT_UNLOCKED, target_table="users", target_id=user.id, details={"ip": ip_address, "method": "unlock_token"}, level=LogLevel.INFO)
        
        return {"message": "Account unlocked successfully. You can now login."}
    
    return {"message": "Account is already active"}/routers/__init__.py
/routers/a_assignment.py
from fastapi import APIRouter, Depends,HTTPException,status
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from ..models import Assets,User,Departments,AssetLifecycleEvents
from ..database import get_db
from ..utilities import get_current_user,generate_id
from ..schemas.assets import AssignAssetUserDep,AssetResponse
from ..system_vars import sys_logger,debugging
from ..services.logger_queue import enqueue_log
from ..schemas.main import  ActionType, LogLevel, UserStatus
from ..services.policy_eval import check_simple_permission, check_full_permission, build_asset_resource,require_specific_role
from ..asset_utils import add_namedep_asset


router = APIRouter(
    prefix="/api/v1/assets",
    tags=["Assets Assignment"]
    )

@router.post("/{asset_id}/assign")
async def assign_user_an_asset(asset_id: str, resp: AssignAssetUserDep, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="assets",
                target_id=asset_id,
                details="Asset not found for assignment",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Asset not found")
    
    try:
        resource = build_asset_resource(asset)
        # check_full_permission(current_user, "asset", "assign", db, resource=resource)

    except HTTPException as e:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="assets",
                target_id=asset_id,
                details=f"Assignment denied: {e.detail}",
                level=LogLevel.CRITICAL
            )
        raise
    
    if not resp.user_id and not resp.dept_id:
        raise HTTPException(status_code=400, detail="User or department must be specified")
    
    if asset.department_id is not None or asset.responsible_officer_id is not None:
        raise HTTPException(
            status_code=409,
            detail="Asset already assigned to department or user"
        )
    
    usr = None
    dep = None
    assignment_details = {}
    
    if resp.user_id and resp.dept_id:
        usr = db.query(User).filter(User.id == resp.user_id).first()
            
        if not usr.status == UserStatus.active:
            raise HTTPException(status_code=400, detail="USer not active")
        

        dep = db.query(Departments).filter(Departments.dept_id == resp.dept_id).first()
        
        if not usr or not dep:
            raise HTTPException(status_code=400, detail="User or department not found")
        
        if usr.department_id != resp.dept_id:
            raise HTTPException(status_code=400, detail="User not in specified department")
        
        asset.responsible_officer_id = resp.user_id
        asset.department_id = resp.dept_id
        assignment_details = {
            "type": "user_and_department",
            "user_name": f"{usr.first_name} {usr.last_name}",
            "department_name": dep.name
        }
    
    elif resp.user_id:
        usr = db.query(User).filter(User.id == resp.user_id).first()
        if not usr:
            raise HTTPException(status_code=400, detail="User not found")
        if not usr.status == UserStatus.active:
            raise HTTPException(status_code=400, detail="USer not active")
        
        
        asset.responsible_officer_id = resp.user_id
        asset.department_id = usr.department_id
        assignment_details = {
            "type": "user_only",
            "user_name": f"{usr.first_name} {usr.last_name}",
            "department_id": usr.department_id
        }
    
    elif resp.dept_id:
        dep = db.query(Departments).filter(Departments.dept_id == resp.dept_id).first()
        if not dep:
            raise HTTPException(status_code=400, detail="Department not found")
        
        asset.department_id = resp.dept_id
        assignment_details = {
            "type": "department_only",
            "department_name": dep.name
        }
    
    try:
        db.commit()
        db.refresh(asset)
        
        lifecycle_event = AssetLifecycleEvents(
            id=generate_id(60),
            asset_id=asset_id,
            event_type="assigned",
            performed_by=current_user.id,
            details=assignment_details,
            remarks=f"Asset assigned by {current_user.first_name} {current_user.last_name}"
        )
        db.add(lifecycle_event)
        db.commit()
        
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="assets",
                target_id=asset_id,
                details=assignment_details,
                level=LogLevel.INFO
            )
        
        return {"detail": "Asset assigned successfully", "assignment": assignment_details}
        
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Assignment failed due to db err")

@router.delete("/{asset_id}/unassign", status_code=status.HTTP_200_OK)
async def unassign_asset_from_usr(asset_id: str, current_user: User = Depends(get_current_user),  db: Session = Depends(get_db)):
    
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="assets",
                target_id=asset_id,
                details="Asset not found for unassignment",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Asset not found")
    
    try:
        resource = build_asset_resource(asset)
        check_full_permission(current_user, "asset", "unassign", db, resource=resource)
    except HTTPException as e:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="assets",
                target_id=asset_id,
                details=f"Unassignment denied: {e.detail}",
                level=LogLevel.CRITICAL
            )
        raise
    
    if asset.department_id is None and asset.responsible_officer_id is None:
        raise HTTPException(status_code=400, detail="Asset not currently assigned")
    
    old_assignment = {
        "department_id": asset.department_id,
        "responsible_officer_id": asset.responsible_officer_id
    }
    
    asset.department_id = None
    asset.responsible_officer_id = None
    
    try:
        db.commit()
        db.refresh(asset)
        
        lifecycle_event = AssetLifecycleEvents(
            id=generate_id(60),
            asset_id=asset_id,
            event_type="unassigned",
            performed_by=current_user.id,
            details=old_assignment,
            remarks=f"Asset unassigned by {current_user.first_name} {current_user.last_name}"
        )
        db.add(lifecycle_event)
        db.commit()
        
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="assets",
                target_id=asset_id,
                details={"action": "unassigned", "previous_assignment": old_assignment},
                level=LogLevel.INFO
            )
        
        return {"detail": "Asset unassigned successfully"}
        
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Unassignment failed due to database constraint")

@router.put("/{asset_id}/reassign", status_code=status.HTTP_200_OK)
async def reassign_an_asset_to_user(asset_id: str, resp: AssignAssetUserDep,current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="assets",
                target_id=asset_id,
                details="Asset not found for reassignment",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Asset not found")
    
    try:
        resource = build_asset_resource(asset)
        check_full_permission(current_user, "asset", "reassign", db, resource=resource)
    except HTTPException as e:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="assets",
                target_id=asset_id,
                details=f"Reassignment denied: {e.detail}",
                level=LogLevel.CRITICAL
            )
        raise
    
    if not resp.user_id and not resp.dept_id:
        raise HTTPException(status_code=400, detail="User or department must be specified")
    
    old_assignment = {
        "department_id": asset.department_id,
        "responsible_officer_id": asset.responsible_officer_id
    }
    
    usr = None
    dep = None
    new_assignment_details = {}
    
    if resp.user_id and resp.dept_id:
        usr = db.query(User).filter(User.id == resp.user_id).first()

        dep = db.query(Departments).filter(Departments.dept_id == resp.dept_id).first()
        
        if not usr or not dep:
            raise HTTPException(status_code=400, detail="User or department not found")
        if not usr.status == UserStatus.active:
            raise HTTPException(status_code=400, detail="USer not active")
        
        
        if usr.department_id != resp.dept_id:
            raise HTTPException(status_code=400, detail="User not in specified department")
        
        asset.responsible_officer_id = resp.user_id
        asset.department_id = resp.dept_id
        new_assignment_details = {
            "type": "user_and_department",
            "user_name": f"{usr.first_name} {usr.last_name}",
            "department_name": dep.name
        }
    
    elif resp.user_id:
        usr = db.query(User).filter(User.id == resp.user_id).first()
        if not usr:
            raise HTTPException(status_code=400, detail="User not found")
        if not usr.status == UserStatus.active:
            raise HTTPException(status_code=400, detail="USer not active")
        
        asset.responsible_officer_id = resp.user_id
        asset.department_id = usr.department_id
        new_assignment_details = {
            "type": "user_only",
            "user_name": f"{usr.first_name} {usr.last_name}",
            "department_id": usr.department_id
        }
    
    elif resp.dept_id:
        dep = db.query(Departments).filter(Departments.dept_id == resp.dept_id).first()
        if not dep:
            raise HTTPException(status_code=400, detail="Department not found")
        
        asset.department_id = resp.dept_id
        asset.responsible_officer_id = None
        new_assignment_details = {
            "type": "department_only",
            "department_name": dep.name
        }
    
    try:
        db.commit()
        db.refresh(asset)
        
        lifecycle_event = AssetLifecycleEvents(
            id=generate_id(60),
            asset_id=asset_id,
            event_type="reassigned",
            performed_by=current_user.id,
            details={
                "old_assignment": old_assignment,
                "new_assignment": new_assignment_details
            },
            remarks=f"Asset reassigned by {current_user.first_name} {current_user.last_name}"
        )
        db.add(lifecycle_event)
        db.commit()
        
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.UPDATE,
                target_table="assets",
                target_id=asset_id,
                details={
                    "action": "reassigned",
                    "old_assignment": old_assignment,
                    "new_assignment": new_assignment_details
                },
                level=LogLevel.INFO
            )
        
        return {"detail": "Asset reassigned successfully", "assignment": new_assignment_details}
        
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Reassignment failed due to database constraint")


@router.get("/{asset_id}/assignment-history")
async def get_assignment_hist(asset_id: str,
                            current_user: User = Depends(get_current_user),
                            db: Session = Depends(get_db)):
    
    if not check_simple_permission(current_user, "asset", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="assets",
                target_id=asset_id,
                details="Attempt to view assignment history without permission",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")
    
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.VIEW,
                target_table="assets",
                target_id=asset_id,
                details="Asset not found for assignment history",
                level=LogLevel.INFO
            )
        raise HTTPException(status_code=404, detail="Asset not found")
    
    assignment_events = (
        db.query(AssetLifecycleEvents)
        .filter(
            AssetLifecycleEvents.asset_id == asset_id,
            AssetLifecycleEvents.event_type.in_(["assigned", "unassigned", "reassigned"])
        )
        .order_by(AssetLifecycleEvents.event_date.desc())
        .all()
    )
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="assets",
            target_id=asset_id,
            details={"view": "assignment_history", "events_count": len(assignment_events)},
            level=LogLevel.INFO
        )
    
    return assignment_events

@router.get("/m/myassets",status_code=200)
async def list_user_assigned_assets(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    
    user_assets = db.query(Assets).filter(Assets.responsible_officer_id == current_user.id).all()
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="assets",
            target_id=None,
            details={"view": "my_assigned_assets", "count": len(user_assets)},
            level=LogLevel.INFO
        )
    
    return user_assets

@router.get("/m/MyDepAssets",status_code=200)
async def list_my_department_assets(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    
    assets = db.query(Assets).filter(Assets.department_id == current_user.id).all()
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="assets",
            target_id=None,
            details={"view": "my_department_assets", "count": len(assets)},
            level=LogLevel.INFO
        )
    
    p  = [AssetResponse(**add_namedep_asset(i)) for i in assets]
    
    return p
    
@router.get("/assignments/all")
async def list_all_assignments(current_user: User = Depends(get_current_user),
                             db: Session = Depends(get_db)):
    
    if not check_simple_permission(current_user, "asset", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="assets",
                target_id=None,
                details="Attempt to list all assignments without permission",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")
    
    assigned_assets = (
        db.query(Assets)
        .filter(
            (Assets.responsible_officer_id.isnot(None)) |
            (Assets.department_id.isnot(None))
        )
        .all()
    )
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="assets",
            target_id=None,
            details={"view": "all_assignments", "count": len(assigned_assets)},
            level=LogLevel.INFO
        )
    
    return assigned_assets

@router.get("/assignments/unassigned")
async def list_unassigned_assets(current_user: User = Depends(get_current_user),
                               db: Session = Depends(get_db)):
    
    if not check_simple_permission(current_user, "asset", "read"):
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.SUSPICIOUS_ACTIVITY,
                target_table="assets",
                target_id=None,
                details="Attempt to list unassigned assets without permission",
                level=LogLevel.WARNING
            )
        raise HTTPException(status_code=403, detail="Not enough permissions")
    
    unassigned_assets = (
        db.query(Assets)
        .filter(
            Assets.responsible_officer_id.is_(None),
            Assets.department_id.is_(None)
        )
        .all()
    )
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="assets",
            target_id=None,
            details={"view": "unassigned_assets", "count": len(unassigned_assets)},
            level=LogLevel.INFO
        )
    
    return unassigned_assets
/routers/reports/maintainance_r.py
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from typing import Optional
from decimal import Decimal
from datetime import datetime, date, timedelta
from collections import defaultdict

from ...database import get_db
from ...models import  Assets, User, MaintenanceRequests
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel

router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Maintainance Reports"])

@router.get("/maintenance-summary")
async def get_maintenance_summary_report(
    department_id: Optional[str] = None,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """8. Maintenance Summary Report"""
    
    query = db.query(MaintenanceRequests)
    
    if department_id:
        query = query.join(Assets).filter(Assets.department_id == department_id)
    if date_from:
        query = query.filter(MaintenanceRequests.request_date >= date_from)
    if date_to:
        query = query.filter(MaintenanceRequests.request_date <= date_to)
    
    requests = query.all()
    
    by_status = defaultdict(int)
    for req in requests:
        by_status[req.status.value] += 1
    
    by_priority = defaultdict(int)
    for req in requests:
        by_priority[req.priority.value] += 1
    
    by_type = defaultdict(int)
    for req in requests:
        by_type[req.maintenance_type.value] += 1
    
    total_cost = sum(req.cost or Decimal(0) for req in requests)
    completed_requests = [r for r in requests if r.status.value == "completed"]
    avg_cost = total_cost / len(completed_requests) if completed_requests else Decimal(0)
    
    asset_request_count = defaultdict(int)
    for req in requests:
        asset_request_count[req.asset_id] += 1
    
    high_maintenance = [
        {
            "asset_id": asset_id,
            "request_count": count,
            "asset": db.query(Assets).filter(Assets.id == asset_id).first().description
        }
        for asset_id, count in asset_request_count.items() if count >= 3
    ]
    high_maintenance.sort(key=lambda x: x["request_count"], reverse=True)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="maintenance_summary",
            details={"filters": {"department_id": department_id, "date_from": str(date_from), "date_to": str(date_to)}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_requests": len(requests),
            "total_cost": float(total_cost),
            "average_cost": float(avg_cost),
            "completed": by_status.get("completed", 0),
            "pending": by_status.get("initiated", 0) + by_status.get("scheduled", 0),
            "in_progress": by_status.get("in_progress", 0)
        },
        "by_status": dict(by_status),
        "by_priority": dict(by_priority),
        "by_type": dict(by_type),
        "high_maintenance_assets": high_maintenance[:10],
        "generated_at": datetime.now()
    }


@router.get("/upcoming-maintenance")
async def get_upcoming_maintenance_report(
    days_ahead: int = Query(30, ge=1, le=365),
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """9. Upcoming Maintenance Schedule"""
    
    end_date = datetime.now().date() + timedelta(days=days_ahead)
    
    query = db.query(MaintenanceRequests).filter(
        MaintenanceRequests.status.in_(["scheduled", "approved"]),
        MaintenanceRequests.maintenance_date.isnot(None),
        MaintenanceRequests.maintenance_date <= end_date
    )
    
    if department_id:
        query = query.join(Assets).filter(Assets.department_id == department_id)
    
    scheduled = query.order_by(MaintenanceRequests.maintenance_date).all()
    
    scheduled_list = [
        {
            "id": req.id,
            "asset_id": req.asset_id,
            "asset_description": req.asset.description if req.asset else None,
            "asset_tag": req.asset.tag_number if req.asset else None,
            "department": req.asset.department.name if req.asset and req.asset.department else None,
            "maintenance_date": req.maintenance_date,
            "priority": req.priority.value,
            "type": req.maintenance_type.value,
            "status": req.status.value,
            "assigned_to": f"{req.assignee.first_name} {req.assignee.last_name}" if req.assignee else None
        }
        for req in scheduled
    ]
    
    by_date = defaultdict(list)
    for item in scheduled_list:
        by_date[str(item["maintenance_date"])].append(item)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="upcoming_maintenance",
            details={"filters": {"department_id": department_id, "days_ahead": days_ahead}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_scheduled": len(scheduled),
            "days_ahead": days_ahead,
            "date_range": {
                "from": datetime.now().date(),
                "to": end_date
            }
        },
        "scheduled_maintenance": scheduled_list,
        "by_date": dict(by_date),
        "generated_at": datetime.now()
    }


@router.get("/maintenance-backlog")
async def get_maintenance_backlog_report(
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """10. Maintenance Backlog - Overdue and aging requests"""
    
    query = db.query(MaintenanceRequests).filter(
        MaintenanceRequests.status.in_(["initiated", "scheduled", "approved"])
    )
    
    if department_id:
        query = query.join(Assets).filter(Assets.department_id == department_id)
    
    pending = query.all()
    
    now = datetime.now()
    overdue = []
    aging = []
    
    for req in pending:
        days_pending = (now - req.request_date).days if req.request_date else 0
        
        item = {
            "id": req.id,
            "asset_id": req.asset_id,
            "asset_description": req.asset.description if req.asset else None,
            "asset_tag": req.asset.tag_number if req.asset else None,
            "department": req.asset.department.name if req.asset and req.asset.department else None,
            "request_date": req.request_date,
            "days_pending": days_pending,
            "priority": req.priority.value,
            "status": req.status.value,
            "maintenance_type": req.maintenance_type.value
        }
        
        if req.maintenance_date and req.maintenance_date < now.date():
            item["days_overdue"] = (now.date() - req.maintenance_date).days
            overdue.append(item)
        elif days_pending > 14:
            aging.append(item)
    
    overdue.sort(key=lambda x: x.get("days_overdue", 0), reverse=True)
    aging.sort(key=lambda x: x["days_pending"], reverse=True)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="maintenance_backlog",
            details={"filters": {"department_id": department_id}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_pending": len(pending),
            "overdue_count": len(overdue),
            "aging_count": len(aging)
        },
        "overdue_maintenance": overdue,
        "aging_maintenance": aging,
        "generated_at": datetime.now()
    }

/routers/reports/departments_r.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Optional
from decimal import Decimal
from datetime import datetime
from collections import defaultdict

from ...database import get_db
from ...models import (
    Assets, User, Departments
)
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel

router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Departments Reports"])

@router.get("/department-assets/{dept_id}")
async def get_department_asset_report(
    dept_id: str,
    include_top_assets: bool = Query(True),
    top_assets_limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """6. Department Asset Report"""
    
    department = db.query(Departments).filter(Departments.dept_id == dept_id).first()
    if not department:
        raise HTTPException(status_code=404, detail="Department not found")
    
    assets = db.query(Assets).filter(
        Assets.department_id == dept_id,
        Assets.is_deleted == False
    ).all()
    
    total_assets = len(assets)
    total_value = sum(asset.current_value or asset.acquisition_cost or Decimal(0) for asset in assets)
    
    by_category = defaultdict(int)
    for asset in assets:
        by_category[asset.category.value] += 1
    
    by_status = defaultdict(int)
    for asset in assets:
        by_status[asset.status.value] += 1
    
    top_assets = []
    if include_top_assets:
        sorted_assets = sorted(
            assets,
            key=lambda x: x.current_value or x.acquisition_cost or Decimal(0),
            reverse=True
        )[:top_assets_limit]
        top_assets = [
            {
                "id": a.id,
                "tag_number": a.tag_number,
                "description": a.description,
                "category": a.category.value,
                "value": float(a.current_value or a.acquisition_cost or 0)
            }
            for a in sorted_assets
        ]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id=f"department_assets_{dept_id}",
            details=None,
            level=LogLevel.INFO
        )
    
    return {
        "department_id": dept_id,
        "department_name": department.name,
        "total_assets": total_assets,
        "total_value": float(total_value),
        "by_category": dict(by_category),
        "by_status": dict(by_status),
        "top_assets": top_assets,
        "generated_at": datetime.now()
    }


@router.get("/user-responsibility")
async def get_user_responsibility_report(
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """7. User Responsibility Report - Assets assigned per user"""
    
    query = db.query(Assets).filter(
        Assets.is_deleted == False,
        Assets.responsible_officer_id.isnot(None)
    )
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    
    assets = query.all()
    
    user_assets = defaultdict(lambda: {"count": 0, "value": Decimal(0), "assets": []})
    for asset in assets:
        if asset.responsible_officer:
            user_id = asset.responsible_officer.id
            user_name = f"{asset.responsible_officer.first_name} {asset.responsible_officer.last_name}"
            user_assets[user_id]["user_name"] = user_name
            user_assets[user_id]["email"] = asset.responsible_officer.email
            user_assets[user_id]["department"] = asset.department.name if asset.department else None
            user_assets[user_id]["count"] += 1
            user_assets[user_id]["value"] += asset.current_value or asset.acquisition_cost or Decimal(0)
            user_assets[user_id]["assets"].append({
                "id": asset.id,
                "tag_number": asset.tag_number,
                "description": asset.description,
                "value": float(asset.current_value or asset.acquisition_cost or 0)
            })
    
    user_list = [
        {
            "user_id": user_id,
            "user_name": data["user_name"],
            "email": data["email"],
            "department": data["department"],
            "asset_count": data["count"],
            "total_value": float(data["value"]),
            "assets": data["assets"]
        }
        for user_id, data in user_assets.items()
    ]
    user_list.sort(key=lambda x: x["total_value"], reverse=True)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="user_responsibility",
            details={"filters": {"department_id": department_id}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_users": len(user_list),
            "total_assets": sum(u["asset_count"] for u in user_list),
            "total_value": sum(u["total_value"] for u in user_list)
        },
        "users": user_list,
        "generated_at": datetime.now()
    }
/routers/reports/utils_r.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import Optional
from decimal import Decimal
from datetime import datetime, date, timedelta
from collections import defaultdict

from ...database import get_db
from ...models import (Assets, User, Departments, MaintenanceRequests, AssetLifecycleEvents, AssetStatus)
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel

router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset  Reports Utils"])

@router.get("/asset-age-analysis")
async def get_asset_age_analysis_report(
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Asset Age Analysis - Distribution of assets by age"""
    
    query = db.query(Assets).filter(
        Assets.is_deleted == False,
        Assets.acquisition_date.isnot(None)
    )
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    
    assets = query.all()
    
    age_brackets = {
        "0-1 years": {"count": 0, "value": Decimal(0), "assets": []},
        "1-3 years": {"count": 0, "value": Decimal(0), "assets": []},
        "3-5 years": {"count": 0, "value": Decimal(0), "assets": []},
        "5-10 years": {"count": 0, "value": Decimal(0), "assets": []},
        "10+ years": {"count": 0, "value": Decimal(0), "assets": []}
    }
    
    for asset in assets:
        years_old = (datetime.now().date() - asset.acquisition_date).days / 365.25
        value = asset.current_value or asset.acquisition_cost or Decimal(0)
        
        asset_info = {
            "id": asset.id,
            "tag_number": asset.tag_number,
            "description": asset.description,
            "age_years": round(years_old, 1),
            "value": float(value)
        }
        
        if years_old < 1:
            age_brackets["0-1 years"]["count"] += 1
            age_brackets["0-1 years"]["value"] += value
            if len(age_brackets["0-1 years"]["assets"]) < 5:
                age_brackets["0-1 years"]["assets"].append(asset_info)
        elif years_old < 3:
            age_brackets["1-3 years"]["count"] += 1
            age_brackets["1-3 years"]["value"] += value
            if len(age_brackets["1-3 years"]["assets"]) < 5:
                age_brackets["1-3 years"]["assets"].append(asset_info)
        elif years_old < 5:
            age_brackets["3-5 years"]["count"] += 1
            age_brackets["3-5 years"]["value"] += value
            if len(age_brackets["3-5 years"]["assets"]) < 5:
                age_brackets["3-5 years"]["assets"].append(asset_info)
        elif years_old < 10:
            age_brackets["5-10 years"]["count"] += 1
            age_brackets["5-10 years"]["value"] += value
            if len(age_brackets["5-10 years"]["assets"]) < 5:
                age_brackets["5-10 years"]["assets"].append(asset_info)
        else:
            age_brackets["10+ years"]["count"] += 1
            age_brackets["10+ years"]["value"] += value
            if len(age_brackets["10+ years"]["assets"]) < 5:
                age_brackets["10+ years"]["assets"].append(asset_info)
    
    approaching_eol = []
    for asset in assets:
        if asset.useful_life_years:
            years_old = (datetime.now().date() - asset.acquisition_date).days / 365.25
            remaining = asset.useful_life_years - years_old
            if 0 < remaining <= 2:
                approaching_eol.append({
                    "id": asset.id,
                    "tag_number": asset.tag_number,
                    "description": asset.description,
                    "age_years": round(years_old, 1),
                    "useful_life_years": asset.useful_life_years,
                    "remaining_years": round(remaining, 1)
                })
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="asset_age_analysis",
            details={"filters": {"department_id": department_id}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_assets": len(assets),
            "approaching_end_of_life": len(approaching_eol)
        },
        "by_age_bracket": {
            bracket: {
                "count": data["count"],
                "value": float(data["value"]),
                "sample_assets": data["assets"]
            }
            for bracket, data in age_brackets.items()
        },
        "approaching_end_of_life": approaching_eol,
        "generated_at": datetime.now()
    }


@router.get("/department-comparison")
async def get_department_comparison_report(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Department Comparison - Compare asset metrics across departments"""
    
    departments = db.query(Departments).filter(
        Departments.status == "active"
    ).all()
    
    dept_metrics = []
    
    for dept in departments:
        assets = db.query(Assets).filter(
            Assets.department_id == dept.dept_id,
            Assets.is_deleted == False
        ).all()
        
        total_value = sum(a.current_value or a.acquisition_cost or Decimal(0) for a in assets)
        operational = len([a for a in assets if a.status == AssetStatus.OPERATIONAL])
        
        thirty_days_ago = datetime.now() - timedelta(days=30)
        maintenance_count = db.query(MaintenanceRequests).join(Assets).filter(
            Assets.department_id == dept.dept_id,
            MaintenanceRequests.request_date >= thirty_days_ago
        ).count()
        
        unassigned = len([a for a in assets if not a.responsible_officer_id])
        
        dept_metrics.append({
            "department_id": dept.dept_id,
            "department_name": dept.name,
            "asset_count": len(assets),
            "total_value": float(total_value),
            "operational_count": operational,
            "operational_percentage": round((operational / len(assets) * 100) if assets else 0, 2),
            "maintenance_requests_30d": maintenance_count,
            "unassigned_assets": unassigned,
            "avg_asset_value": float(total_value / len(assets)) if assets else 0
        })
    
    dept_metrics.sort(key=lambda x: x["total_value"], reverse=True)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="department_comparison",
            details=None,
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_departments": len(dept_metrics),
            "total_assets": sum(d["asset_count"] for d in dept_metrics),
            "total_value": sum(d["total_value"] for d in dept_metrics)
        },
        "departments": dept_metrics,
        "generated_at": datetime.now()
    }


@router.get("/asset-utilization")
async def get_asset_utilization_report(
    category: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Asset Utilization Report - Track asset usage and idle assets"""
    
    query = db.query(Assets).filter(Assets.is_deleted == False)
    
    if category:
        query = query.filter(Assets.category == category)
    
    assets = query.all()
    
    assigned = [a for a in assets if a.responsible_officer_id]
    unassigned = [a for a in assets if not a.responsible_officer_id]
    operational = [a for a in assets if a.status == AssetStatus.OPERATIONAL]
    
    idle_assets = []
    for asset in assets:
        if asset.status == AssetStatus.OPERATIONAL and not asset.responsible_officer_id:
            recent_events = db.query(AssetLifecycleEvents).filter(
                AssetLifecycleEvents.asset_id == asset.id,
                AssetLifecycleEvents.event_date >= datetime.now() - timedelta(days=90)
            ).count()
            
            if recent_events == 0:
                idle_assets.append({
                    "id": asset.id,
                    "tag_number": asset.tag_number,
                    "description": asset.description,
                    "category": asset.category.value,
                    "value": float(asset.current_value or asset.acquisition_cost or 0),
                    "last_activity": asset.updated_at or asset.created_at
                })
    
    location_usage = defaultdict(lambda: {"assigned": 0, "unassigned": 0})
    for asset in assets:
        location = "Unknown"
        if asset.location and isinstance(asset.location, dict):
            location = asset.location.get("county", "Unknown")
        
        if asset.responsible_officer_id:
            location_usage[location]["assigned"] += 1
        else:
            location_usage[location]["unassigned"] += 1
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="asset_utilization",
            details={"filters": {"category": category}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_assets": len(assets),
            "assigned": len(assigned),
            "unassigned": len(unassigned),
            "operational": len(operational),
            "idle_assets": len(idle_assets),
            "utilization_rate": round((len(assigned) / len(assets) * 100) if assets else 0, 2)
        },
        "idle_assets": idle_assets,
        "by_location": {
            loc: {
                "assigned": data["assigned"],
                "unassigned": data["unassigned"],
                "utilization_rate": round((data["assigned"] / (data["assigned"] + data["unassigned"]) * 100) if (data["assigned"] + data["unassigned"]) > 0 else 0, 2)
            }
            for loc, data in location_usage.items()
        },
        "generated_at": datetime.now()
    }


@router.get("/maintenance-cost-analysis")
async def get_maintenance_cost_analysis_report(
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Maintenance Cost Analysis - Detailed cost breakdown"""
    
    query = db.query(MaintenanceRequests).filter(
        MaintenanceRequests.cost.isnot(None)
    )
    
    if date_from:
        query = query.filter(MaintenanceRequests.request_date >= date_from)
    if date_to:
        query = query.filter(MaintenanceRequests.request_date <= date_to)
    if department_id:
        query = query.join(Assets).filter(Assets.department_id == department_id)
    
    requests = query.all()
    
    total_cost = sum(r.cost for r in requests)
    
    by_type = defaultdict(lambda: {"count": 0, "total_cost": Decimal(0)})
    for req in requests:
        by_type[req.maintenance_type.value]["count"] += 1
        by_type[req.maintenance_type.value]["total_cost"] += req.cost
    
    by_category = defaultdict(lambda: {"count": 0, "total_cost": Decimal(0)})
    for req in requests:
        if req.asset:
            category = req.asset.category.value
            by_category[category]["count"] += 1
            by_category[category]["total_cost"] += req.cost
    
    expensive_requests = sorted(requests, key=lambda x: x.cost, reverse=True)[:10]
    expensive_list = [
        {
            "id": r.id,
            "asset_id": r.asset_id,
            "asset_description": r.asset.description if r.asset else None,
            "cost": float(r.cost),
            "maintenance_type": r.maintenance_type.value,
            "request_date": r.request_date,
            "completed_at": r.completed_at
        }
        for r in expensive_requests
    ]
    
    asset_costs = defaultdict(lambda: {"cost": Decimal(0), "count": 0, "asset": None})
    for req in requests:
        if req.asset:
            asset_costs[req.asset_id]["cost"] += req.cost
            asset_costs[req.asset_id]["count"] += 1
            asset_costs[req.asset_id]["asset"] = req.asset
    
    high_cost_assets = sorted(
        [
            {
                "asset_id": asset_id,
                "asset_description": data["asset"].description,
                "asset_tag": data["asset"].tag_number,
                "total_maintenance_cost": float(data["cost"]),
                "maintenance_count": data["count"],
                "avg_cost_per_maintenance": float(data["cost"] / data["count"])
            }
            for asset_id, data in asset_costs.items() if data["asset"]
        ],
        key=lambda x: x["total_maintenance_cost"],
        reverse=True
    )[:10]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="maintenance_cost_analysis",
            details={"filters": {"department_id": department_id, "date_from": str(date_from), "date_to": str(date_to)}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_requests": len(requests),
            "total_cost": float(total_cost),
            "average_cost": float(total_cost / len(requests)) if requests else 0
        },
        "by_maintenance_type": {
            mtype: {
                "count": data["count"],
                "total_cost": float(data["total_cost"]),
                "avg_cost": float(data["total_cost"] / data["count"]) if data["count"] > 0 else 0
            }
            for mtype, data in by_type.items()
        },
        "by_category": {
            cat: {
                "count": data["count"],
                "total_cost": float(data["total_cost"]),
                "avg_cost": float(data["total_cost"] / data["count"]) if data["count"] > 0 else 0
            }
            for cat, data in by_category.items()
        },
        "most_expensive_requests": expensive_list,
        "high_cost_assets": high_cost_assets,
        "generated_at": datetime.now()
    }


@router.get("/available-reports")
async def list_available_reports(
    current_user: User = Depends(get_current_user)
):
    """List all available reports with descriptions"""
    
    reports = [
        {
            "id": "asset-summary-dashboard",
            "name": "Asset Summary Dashboard",
            "description": "Complete overview of all assets with breakdowns by category, status, condition, and department",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/asset-summary-dashboard"
        },
        {
            "id": "depreciation",
            "name": "Depreciation Report",
            "description": "Asset values and depreciation analysis with assets nearing full depreciation",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/depreciation"
        },
        {
            "id": "asset-status-condition",
            "name": "Asset Status & Condition",
            "description": "Status and condition breakdowns with assets requiring attention",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/asset-status-condition"
        },
        {
            "id": "category-specific",
            "name": "Category-Specific Reports",
            "description": "Detailed reports for Land, Buildings, and Standard Assets",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/category-specific/{category}"
        },
        {
            "id": "unassigned-assets",
            "name": "Unassigned Assets",
            "description": "Assets without responsible officers or department assignments",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/unassigned-assets"
        },
        {
            "id": "asset-age-analysis",
            "name": "Asset Age Analysis",
            "description": "Distribution of assets by age and approaching end of life",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/asset-age-analysis"
        },
        {
            "id": "asset-utilization",
            "name": "Asset Utilization",
            "description": "Track asset usage, idle assets, and utilization rates",
            "category": "Asset Reports",
            "endpoint": "/api/v1/r/reports/asset-utilization"
        },
        {
            "id": "department-assets",
            "name": "Department Asset Report",
            "description": "Comprehensive per-department breakdown with top assets",
            "category": "Department Reports",
            "endpoint": "/api/v1/r/reports/department-assets/{dept_id}"
        },
        {
            "id": "user-responsibility",
            "name": "User Responsibility",
            "description": "Assets assigned per user with total values under care",
            "category": "Department Reports",
            "endpoint": "/api/v1/r/reports/user-responsibility"
        },
        {
            "id": "department-comparison",
            "name": "Department Comparison",
            "description": "Compare asset metrics across all departments",
            "category": "Department Reports",
            "endpoint": "/api/v1/r/reports/department-comparison"
        },
        {
            "id": "maintenance-summary",
            "name": "Maintenance Summary",
            "description": "Complete maintenance overview with costs and high-maintenance assets",
            "category": "Maintenance Reports",
            "endpoint": "/api/v1/r/reports/maintenance-summary"
        },
        {
            "id": "upcoming-maintenance",
            "name": "Upcoming Maintenance",
            "description": "Scheduled maintenance with date grouping",
            "category": "Maintenance Reports",
            "endpoint": "/api/v1/r/reports/upcoming-maintenance"
        },
        {
            "id": "maintenance-backlog",
            "name": "Maintenance Backlog",
            "description": "Overdue and aging maintenance requests",
            "category": "Maintenance Reports",
            "endpoint": "/api/v1/r/reports/maintenance-backlog"
        },
        {
            "id": "maintenance-cost-analysis",
            "name": "Maintenance Cost Analysis",
            "description": "Detailed cost breakdown by type, category, and asset",
            "category": "Maintenance Reports",
            "endpoint": "/api/v1/r/reports/maintenance-cost-analysis"
        },
        {
            "id": "pending-transfers-disposals",
            "name": "Pending Transfers & Disposals",
            "description": "All pending transfers and disposals awaiting approval",
            "category": "Transfer & Disposal Reports",
            "endpoint": "/api/v1/r/reports/pending-transfers-disposals"
        },
        {
            "id": "transfer-disposal-history",
            "name": "Transfer & Disposal History",
            "description": "Completed transactions with financial details",
            "category": "Transfer & Disposal Reports",
            "endpoint": "/api/v1/r/reports/transfer-disposal-history"
        },
        {
            "id": "activity-log",
            "name": "Activity Log",
            "description": "System activities with critical operation tracking",
            "category": "Security & Audit Reports",
            "endpoint": "/api/v1/r/reports/activity-log"
        },
        {
            "id": "failed-login-attempts",
            "name": "Failed Login Attempts",
            "description": "Suspicious patterns and excessive login failures",
            "category": "Security & Audit Reports",
            "endpoint": "/api/v1/r/reports/failed-login-attempts"
        },
        {
            "id": "data-modifications",
            "name": "Data Modifications",
            "description": "Audit trail with high-frequency user detection",
            "category": "Security & Audit Reports",
            "endpoint": "/api/v1/r/reports/data-modifications"
        },
        {
            "id": "missing-data",
            "name": "Missing Data",
            "description": "Assets with incomplete information and data quality scores",
            "category": "Compliance Reports",
            "endpoint": "/api/v1/r/reports/missing-data"
        },
        {
            "id": "geographic-distribution",
            "name": "Geographic Distribution",
            "description": "Assets by county and entity type",
            "category": "Compliance Reports",
            "endpoint": "/api/v1/r/reports/geographic-distribution"
        },
        {
            "id": "executive-summary",
            "name": "Executive Summary",
            "description": "High-level KPIs with critical alerts and trends",
            "category": "Executive Report",
            "endpoint": "/api/v1/r/reports/executive-summary"
        }
    ]
    
    by_category = defaultdict(list)
    for report in reports:
        by_category[report["category"]].append(report)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="available_reports_list",
            details=None,
            level=LogLevel.INFO
        )
    
    return {
        "total_reports": len(reports),
        "categories": list(by_category.keys()),
        "reports_by_category": dict(by_category),
        "all_reports": reports
    }/routers/reports/transdispo_r.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import Optional
from datetime import datetime, date


from ...database import get_db
from ...models import Assets, User,AssetTransfers, AssetDisposals
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel
from sqlalchemy import  or_
router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Transfers n Disposals Reports"])

@router.get("/pending-transfers-disposals")
async def get_pending_transfers_disposals_report(
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """11. Pending Transfers & Disposals Report"""
    
    transfer_query = db.query(AssetTransfers).filter(
        AssetTransfers.status.in_(["initiated", "pending", "approved"])
    )
    if department_id:
        transfer_query = transfer_query.filter(
            or_(
                AssetTransfers.from_dept_id == department_id,
                AssetTransfers.to_dept_id == department_id
            )
        )
    
    pending_transfers = transfer_query.all()
    
    transfer_list = [
        {
            "id": t.id,
            "asset_id": t.asset_id,
            "asset_description": t.asset.description if t.asset else None,
            "asset_tag": t.asset.tag_number if t.asset else None,
            "from_department": t.from_dept_id,
            "to_department": t.to_dept_id,
            "initiated_by": f"{t.initiated_by_user.first_name} {t.initiated_by_user.last_name}" if t.initiated_by_user else None,
            "initiated_date": t.initiated_date,
            "status": t.status.value,
            "transfer_reason": t.transfer_reason,
            "value": float(t.asset.current_value or t.asset.acquisition_cost or 0) if t.asset else 0
        }
        for t in pending_transfers
    ]
    
    disposal_query = db.query(AssetDisposals).filter(
        AssetDisposals.status.in_(["initiated", "scheduled", "approved"])
    )
    if department_id:
        disposal_query = disposal_query.join(Assets).filter(Assets.department_id == department_id)
    
    pending_disposals = disposal_query.all()
    
    disposal_list = [
        {
            "id": d.id,
            "asset_id": d.asset_id,
            "asset_description": d.asset.description if d.asset else None,
            "asset_tag": d.asset.tag_number if d.asset else None,
            "department": d.asset.department.name if d.asset and d.asset.department else None,
            "disposal_method": d.disposal_method,
            "disposal_date": d.disposal_date,
            "status": d.status.value,
            "value": float(d.asset.current_value or d.asset.acquisition_cost or 0) if d.asset else 0
        }
        for d in pending_disposals
    ]
    
    total_transfer_value = sum(t["value"] for t in transfer_list)
    total_disposal_value = sum(d["value"] for d in disposal_list)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="pending_transfers_disposals",
            details={"filters": {"department_id": department_id}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "pending_transfers": len(transfer_list),
            "pending_disposals": len(disposal_list),
            "total_transfer_value": total_transfer_value,
            "total_disposal_value": total_disposal_value
        },
        "pending_transfers": transfer_list,
        "pending_disposals": disposal_list,
        "generated_at": datetime.now()
    }


@router.get("/transfer-disposal-history")
async def get_transfer_disposal_history_report(
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """12. Transfer & Disposal History Report"""
    
    transfer_query = db.query(AssetTransfers).filter(
        AssetTransfers.status == "completed"
    )
    if date_from:
        transfer_query = transfer_query.filter(AssetTransfers.completed_date >= date_from)
    if date_to:
        transfer_query = transfer_query.filter(AssetTransfers.completed_date <= date_to)
    if department_id:
        transfer_query = transfer_query.filter(
            or_(
                AssetTransfers.from_dept_id == department_id,
                AssetTransfers.to_dept_id == department_id
            )
        )
    
    completed_transfers = transfer_query.all()
    
    transfer_list = [
        {
            "id": t.id,
            "asset_id": t.asset_id,
            "asset_description": t.asset.description if t.asset else None,
            "from_department": t.from_dept_id,
            "to_department": t.to_dept_id,
            "completed_date": t.completed_date,
            "value": float(t.asset.current_value or t.asset.acquisition_cost or 0) if t.asset else 0
        }
        for t in completed_transfers
    ]
    
    disposal_query = db.query(AssetDisposals).filter(
        AssetDisposals.status == "executed"
    )
    if date_from:
        disposal_query = disposal_query.filter(AssetDisposals.disposal_date >= date_from)
    if date_to:
        disposal_query = disposal_query.filter(AssetDisposals.disposal_date <= date_to)
    if department_id:
        disposal_query = disposal_query.join(Assets).filter(Assets.department_id == department_id)
    
    executed_disposals = disposal_query.all()
    
    disposal_list = [
        {
            "id": d.id,
            "asset_id": d.asset_id,
            "asset_description": d.asset.description if d.asset else None,
            "disposal_method": d.disposal_method,
            "disposal_date": d.disposal_date,
            "proceeds_amount": float(d.proceeds_amount or 0),
            "disposal_cost": float(d.disposal_cost or 0),
            "net_proceeds": float((d.proceeds_amount or 0) - (d.disposal_cost or 0))
        }
        for d in executed_disposals
    ]
    
    total_proceeds = sum(d["proceeds_amount"] for d in disposal_list)
    total_disposal_costs = sum(d["disposal_cost"] for d in disposal_list)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="transfer_disposal_history",
            details={"filters": {"department_id": department_id, "date_from": str(date_from), "date_to": str(date_to)}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "completed_transfers": len(transfer_list),
            "executed_disposals": len(disposal_list),
            "total_proceeds": total_proceeds,
            "total_disposal_costs": total_disposal_costs,
            "net_proceeds": total_proceeds - total_disposal_costs
        },
        "completed_transfers": transfer_list,
        "executed_disposals": disposal_list,
        "generated_at": datetime.now()
    }
/routers/reports/complience_r.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import Optional
from decimal import Decimal
from datetime import datetime
from collections import defaultdict

from ...database import get_db
from ...models import Assets, User
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel


router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Complience Reports"])

@router.get("/missing-data")
async def get_missing_data_report(
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """16. Missing Data Report - Assets with incomplete information"""
    
    query = db.query(Assets).filter(Assets.is_deleted == False)
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    
    assets = query.all()
    
    issues = []
    for asset in assets:
        missing_fields = []
        
        if not asset.acquisition_cost:
            missing_fields.append("acquisition_cost")
        if not asset.acquisition_date:
            missing_fields.append("acquisition_date")
        if not asset.responsible_officer_id:
            missing_fields.append("responsible_officer")
        if not asset.department_id:
            missing_fields.append("department")
        if not asset.location:
            missing_fields.append("location")
        if not asset.serial_number and asset.category.value not in ["Land", "Buildings and building improvements"]:
            missing_fields.append("serial_number")
        
        if missing_fields:
            issues.append({
                "asset_id": asset.id,
                "tag_number": asset.tag_number,
                "description": asset.description,
                "category": asset.category.value,
                "department": asset.department.name if asset.department else None,
                "missing_fields": missing_fields,
                "completeness_score": round((1 - len(missing_fields) / 6) * 100, 2)
            })
    
    if assets:
        avg_completeness = sum(i["completeness_score"] for i in issues) / len(issues) if issues else 100
        overall_score = round(((len(assets) - len(issues)) / len(assets) * 100 + avg_completeness) / 2, 2)
    else:
        overall_score = 100
    
    by_field = defaultdict(int)
    for issue in issues:
        for field in issue["missing_fields"]:
            by_field[field] += 1
    
    issues.sort(key=lambda x: len(x["missing_fields"]), reverse=True)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="missing_data",
            details={"filters": {"department_id": department_id}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_assets": len(assets),
            "assets_with_issues": len(issues),
            "overall_data_quality_score": overall_score,
            "by_missing_field": dict(by_field)
        },
        "assets_with_missing_data": issues,
        "generated_at": datetime.now()
    }


@router.get("/geographic-distribution")
async def get_geographic_distribution_report(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """17. Geographic Distribution Report"""
    
    assets = db.query(Assets).filter(Assets.is_deleted == False).all()
    
    by_county = defaultdict(lambda: {"count": 0, "value": Decimal(0)})
    by_entity = defaultdict(lambda: {"count": 0, "value": Decimal(0)})
    
    for asset in assets:
        county = "Unknown"
        if asset.location and isinstance(asset.location, dict):
            county = asset.location.get("county", "Unknown")
        
        value = asset.current_value or asset.acquisition_cost or Decimal(0)
        by_county[county]["count"] += 1
        by_county[county]["value"] += value
        
        if asset.department and asset.department.entity_type:
            entity = asset.department.entity_type.value
            by_entity[entity]["count"] += 1
            by_entity[entity]["value"] += value
    
    county_list = [
        {
            "county": county,
            "asset_count": data["count"],
            "total_value": float(data["value"])
        }
        for county, data in by_county.items()
    ]
    county_list.sort(key=lambda x: x["total_value"], reverse=True)
    
    entity_list = [
        {
            "entity_type": entity,
            "asset_count": data["count"],
            "total_value": float(data["value"])
        }
        for entity, data in by_entity.items()
    ]
    entity_list.sort(key=lambda x: x["total_value"], reverse=True)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="geographic_distribution",
            details=None,
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_assets": len(assets),
            "counties_covered": len(by_county),
            "entity_types": len(by_entity)
        },
        "by_county": county_list,
        "by_entity_type": entity_list,
        "generated_at": datetime.now()
    }
/routers/reports/exec_r.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from decimal import Decimal
from datetime import datetime, date, timedelta
from collections import defaultdict

from ...database import get_db
from ...models import (
    Assets, User, MaintenanceRequests, AssetTransfers, 
    AssetDisposals,AssetStatus
)
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel

router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Executive Reports"])

@router.get("/executive-summary")
async def get_executive_summary_report(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """18. Executive Summary - High-level overview for decision makers"""
    
    assets = db.query(Assets).filter(Assets.is_deleted == False).all()
    
    total_assets = len(assets)
    total_value = sum(a.current_value or a.acquisition_cost or Decimal(0) for a in assets)
    
    operational_count = len([a for a in assets if a.status == AssetStatus.OPERATIONAL])
    operational_pct = (operational_count / total_assets * 100) if total_assets > 0 else 0
    
    under_maintenance = len([a for a in assets if a.status == AssetStatus.UNDER_MAINTENANCE])
    
    thirty_days_ago = datetime.now() - timedelta(days=30)
    recent_maintenance = db.query(MaintenanceRequests).filter(
        MaintenanceRequests.request_date >= thirty_days_ago
    ).all()
    maintenance_rate = len(recent_maintenance)
    
    recent_disposals = db.query(AssetDisposals).filter(
        AssetDisposals.disposal_date >= thirty_days_ago.date()
    ).count()
    
    last_month_start = (datetime.now() - timedelta(days=60)).date()
    last_month_end = (datetime.now() - timedelta(days=30)).date()
    this_month_start = (datetime.now() - timedelta(days=30)).date()
    
    last_month_assets = db.query(Assets).filter(
        Assets.acquisition_date.between(last_month_start, last_month_end),
        Assets.is_deleted == False
    ).count()
    
    this_month_assets = db.query(Assets).filter(
        Assets.acquisition_date >= this_month_start,
        Assets.is_deleted == False
    ).count()
    
    mom_change = this_month_assets - last_month_assets
    
    category_values = defaultdict(Decimal)
    for asset in assets:
        category_values[asset.category.value] += asset.current_value or asset.acquisition_cost or Decimal(0)
    
    top_categories = sorted(
        [{"category": cat, "value": float(val)} for cat, val in category_values.items()],
        key=lambda x: x["value"],
        reverse=True
    )[:5]
    
    alerts = []
    
    attention_needed = [
        a for a in assets 
        if (a.condition and a.condition.value in ["poor", "fair"]) or 
           a.status.value in ["Impaired", "Lost/Stolen"]
    ]
    if attention_needed:
        alerts.append({
            "type": "warning",
            "message": f"{len(attention_needed)} assets require immediate attention",
            "count": len(attention_needed)
        })
    
    pending_transfers = db.query(AssetTransfers).filter(
        AssetTransfers.status.in_(["initiated", "pending"])
    ).count()
    if pending_transfers > 0:
        alerts.append({
            "type": "info",
            "message": f"{pending_transfers} transfers pending approval",
            "count": pending_transfers
        })
    
    overdue_maintenance = db.query(MaintenanceRequests).filter(
        MaintenanceRequests.status.in_(["scheduled", "approved"]),
        MaintenanceRequests.maintenance_date < datetime.now().date()
    ).count()
    if overdue_maintenance > 0:
        alerts.append({
            "type": "critical",
            "message": f"{overdue_maintenance} maintenance requests overdue",
            "count": overdue_maintenance
        })
    
    unassigned = len([a for a in assets if not a.responsible_officer_id])
    if unassigned > 10:
        alerts.append({
            "type": "warning",
            "message": f"{unassigned} assets without responsible officers",
            "count": unassigned
        })
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="executive_summary",
            details=None,
            level=LogLevel.INFO
        )
    
    return {
        "overview": {
            "total_assets": total_assets,
            "total_value": float(total_value),
            "operational_percentage": round(operational_pct, 2),
            "under_maintenance": under_maintenance
        },
        "key_metrics": {
            "operational_count": operational_count,
            "maintenance_rate_30d": maintenance_rate,
            "disposal_rate_30d": recent_disposals,
            "month_over_month_change": mom_change
        },
        "top_5_categories": top_categories,
        "critical_alerts": alerts,
        "generated_at": datetime.now()
    }

/routers/reports/reports.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import  Optional
from decimal import Decimal
from datetime import datetime, date

from ...database import get_db
from ...models import Assets,User,Departments
from ...schemas.assets import AssetSummaryReport, DepartmentAssetReport
from ...utilities import get_current_user
from ...asset_utils import get_category_specific_reports_fields, format_attributes_for_display

router = APIRouter(prefix="/api/v1/reports", tags=["Asset Reports general"])

@router.get("/assets-summary", response_model=AssetSummaryReport)
async def get_assets_summary_report(
    department_id: Optional[str] = None,
    category: Optional[str] = None,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """a comprehensive assets summary report"""

    query = db.query(Assets).filter(Assets.is_deleted == False)
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if category:
        query = query.filter(Assets.category == category)
    if date_from:
        query = query.filter(Assets.acquisition_date >= date_from)
    if date_to:
        query = query.filter(Assets.acquisition_date <= date_to)
    
    assets = query.all()

    total_assets = len(assets)
    total_value = sum(asset.current_value or asset.acquisition_cost or Decimal(0) for asset in assets)
    
    by_category = {}
    for asset in assets:
        category_name = asset.category
        if category_name not in by_category:
            by_category[category_name] = {
                "count": 0,
                "total_value": Decimal(0),
                "avg_value": Decimal(0),
                "operational_count": 0,
                "impaired_count": 0
            }
        
        by_category[category_name]["count"] += 1
        asset_value = asset.current_value or asset.acquisition_cost or Decimal(0)
        by_category[category_name]["total_value"] += asset_value
        
        if asset.status == "Operational":
            by_category[category_name]["operational_count"] += 1
        elif asset.status in ["Impaired", "Under Maintenance"]:
            by_category[category_name]["impaired_count"] += 1

    for category_data in by_category.values():
        if category_data["count"] > 0:
            category_data["avg_value"] = category_data["total_value"] / category_data["count"]

    by_status = {}
    for asset in assets:
        status = asset.status
        if status not in by_status:
            by_status[status] = {"count": 0, "total_value": Decimal(0)}
        
        by_status[status]["count"] += 1
        asset_value = asset.current_value or asset.acquisition_cost or Decimal(0)
        by_status[status]["total_value"] += asset_value

    by_condition = {}
    for asset in assets:
        condition = asset.condition or "unknown"
        if condition not in by_condition:
            by_condition[condition] = {"count": 0, "total_value": Decimal(0)}
        
        by_condition[condition]["count"] += 1
        asset_value = asset.current_value or asset.acquisition_cost or Decimal(0)
        by_condition[condition]["total_value"] += asset_value
    
    return AssetSummaryReport(
        total_assets=total_assets,
        total_value=total_value,
        by_category=by_category,
        by_status=by_status,
        by_condition=by_condition
    )

@router.get("/department-assets/{dept_id}", response_model=DepartmentAssetReport)
async def get_department_asset_report(dept_id: str,
    include_top_assets: bool = Query(True),
    top_assets_limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db),current_user: User = Depends(get_current_user)
):
    """Get detailed asset report for a specific department"""

    department = db.query(Departments).filter(Departments.dept_id == dept_id).first()
    if not department:
        raise HTTPException(status_code=404, detail="Department not found")
    
    assets = db.query(Assets).filter( Assets.department_id == dept_id, Assets.is_deleted == False).all()
    
    total_assets = len(assets)
    total_value = sum(asset.current_value or asset.acquisition_cost or Decimal(0) for asset in assets)
    
    assets_by_category = {}
    for asset in assets:
        category = asset.category
        assets_by_category[category] = assets_by_category.get(category, 0) + 1
    
    assets_by_status = {}
    for asset in assets:
        status = asset.status
        assets_by_status[status] = assets_by_status.get(status, 0) + 1

    top_assets = []
    if include_top_assets:
        top_assets_query = sorted(
            assets,
            key=lambda x: x.current_value or x.acquisition_cost or Decimal(0),
            reverse=True
        )[:top_assets_limit]
        top_assets = top_assets_query
    
    return DepartmentAssetReport(
        department_id=dept_id,
        department_name=department.name,
        total_assets=total_assets,
        total_value=total_value,
        assets_by_category=assets_by_category,
        assets_by_status=assets_by_status,
        top_assets=top_assets
    )

@router.get("/assets-by-condition")
async def get_assets_by_condition_report(
    department_id: Optional[str] = None,
    category: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    query = db.query(Assets).filter(Assets.is_deleted == False)
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if category:
        query = query.filter(Assets.category == category)
    
    assets = query.all()
    
    assets_by_condition = {
        "new": [],
        "excellent": [],
        "good": [],
        "fair": [],
        "poor": [],
        "unknown": []
    }
    
    condition_stats = {
        "new": {"count": 0, "total_value": Decimal(0)},
        "excellent": {"count": 0, "total_value": Decimal(0)},
        "good": {"count": 0, "total_value": Decimal(0)},
        "fair": {"count": 0, "total_value": Decimal(0)},
        "poor": {"count": 0, "total_value": Decimal(0)},
        "unknown": {"count": 0, "total_value": Decimal(0)}
    }
    
    for asset in assets:
        condition = asset.condition or "unknown"
        
        asset_info = {
            "id": asset.id,
            "description": asset.description,
            "tag_number": asset.tag_number,
            "category": asset.category,
            "current_value": asset.current_value or asset.acquisition_cost,
            "acquisition_date": asset.acquisition_date,
            "location": asset.location
        }
        
        assets_by_condition[condition].append(asset_info)
        condition_stats[condition]["count"] += 1
        condition_stats[condition]["total_value"] += asset.current_value or asset.acquisition_cost or Decimal(0)
    
    return {
        "summary": condition_stats,
        "assets_by_condition": assets_by_condition,
        "generated_at": datetime.now(),
        "filters_applied": {
            "department_id": department_id,
            "category": category
        }
    }

@router.get("/depreciation-report")
async def get_depreciation_report(
    department_id: Optional[str] = None,
    category: Optional[str] = None,
    min_depreciation_rate: Optional[float] = None,
    db: Session = Depends(get_db),current_user: User = Depends(get_current_user)
):
    """Get depreciation report showing assets with depreciation details"""
    
    query = db.query(Assets).filter(Assets.is_deleted == False, Assets.depreciation_rate.isnot(None), Assets.acquisition_date.isnot(None))
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if category:
        query = query.filter(Assets.category == category)
    if min_depreciation_rate:
        query = query.filter(Assets.depreciation_rate >= min_depreciation_rate)
    
    assets = query.all()
    
    depreciation_report = []
    total_original_value = Decimal(0)
    total_current_value = Decimal(0)
    total_depreciated_amount = Decimal(0)
    
    for asset in assets:
        if asset.acquisition_cost and asset.depreciation_rate and asset.acquisition_date:
            original_value = asset.acquisition_cost
            current_value = asset.current_value or original_value
            depreciated_amount = original_value - current_value
            depreciation_percentage = (depreciated_amount / original_value * 100) if original_value > 0 else 0
            
            years_owned = (datetime.now().date() - asset.acquisition_date).days / 365.25
            
            asset_report = {
                "asset_id": asset.id,
                "description": asset.description,
                "tag_number": asset.tag_number,
                "category": asset.category,
                "acquisition_date": asset.acquisition_date,
                "years_owned": round(years_owned, 2),
                "original_value": original_value,
                "current_value": current_value,
                "depreciation_rate": asset.depreciation_rate,
                "depreciated_amount": depreciated_amount,
                "depreciation_percentage": round(depreciation_percentage, 2),
                "useful_life_years": asset.useful_life_years,
                "remaining_life_years": max(0, (asset.useful_life_years or 0) - years_owned) if asset.useful_life_years else None
            }
            
            depreciation_report.append(asset_report)
            total_original_value += original_value
            total_current_value += current_value
            total_depreciated_amount += depreciated_amount

    depreciation_report.sort(key=lambda x: x["depreciation_percentage"], reverse=True)
    
    summary = {
        "total_assets": len(depreciation_report),
        "total_original_value": total_original_value,
        "total_current_value": total_current_value,
        "total_depreciated_amount": total_depreciated_amount,
        "overall_depreciation_percentage": round(
            (total_depreciated_amount / total_original_value * 100) if total_original_value > 0 else 0, 2
        )
    }
    
    return {
        "summary": summary,
        "assets": depreciation_report,
        "generated_at": datetime.now(),
        "filters_applied": {
            "department_id": department_id,
            "category": category,
            "min_depreciation_rate": min_depreciation_rate
        }
    }

@router.get("/category-specific-report/{category}")
async def get_category_specific_report(
    category: str,
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    query = db.query(Assets).filter( Assets.category == category, Assets.is_deleted == False)
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    
    assets = query.all()
    
    if not assets:
        return {
            "category": category,
            "assets": [],
            "total_count": 0,
            "message": "No assets found for this category"
        }
    
    category_fields = get_category_specific_reports_fields(category)
    
    formatted_assets = []
    for asset in assets:
        asset_data = {
            "id": asset.id,
            "description": asset.description,
            "tag_number": asset.tag_number,
            "status": asset.status,
            "condition": asset.condition,
            "location": asset.location,
            "acquisition_date": asset.acquisition_date,
            "current_value": asset.current_value or asset.acquisition_cost,
        }
        
        if asset.specific_attributes:
            formatted_specific = format_attributes_for_display(category, asset.specific_attributes)
            asset_data["specific_attributes"] = formatted_specific

            for field_info in category_fields:
                field_name = field_info["field"]
                if field_name in asset.specific_attributes:
                    asset_data[field_info["label"]] = asset.specific_attributes[field_name]
        
        formatted_assets.append(asset_data)
    
    total_value = sum(asset.current_value or asset.acquisition_cost or Decimal(0) for asset in assets)
    avg_value = total_value / len(assets) if assets else Decimal(0)
    
    status_distribution = {}
    for asset in assets:
        status = asset.status
        status_distribution[status] = status_distribution.get(status, 0) + 1
    
    return {
        "category": category,
        "total_count": len(assets),
        "total_value": total_value,
        "average_value": avg_value,
        "status_distribution": status_distribution,
        "category_specific_fields": category_fields,
        "assets": formatted_assets,
        "generated_at": datetime.now(),
        "filters_applied": {
            "department_id": department_id
        }
    }/routers/reports/__init__.py
/routers/reports/assets_r.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import Optional
from decimal import Decimal
from datetime import datetime, date
from collections import defaultdict

from ...database import get_db
from ...models import Assets, User
from ...utilities import get_current_user
from ...asset_utils import format_attributes_for_display, get_category_specific_reports_fields
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel
from sqlalchemy import  or_

router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Basic Reports"])

@router.get("/asset-summary-dashboard")
async def get_asset_summary_dashboard(
    department_id: Optional[str] = None,
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """1. Asset Summary Dashboard - Overview of all assets"""
    
    query = db.query(Assets).filter(Assets.is_deleted == False)
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if date_from:
        query = query.filter(Assets.acquisition_date >= date_from)
    if date_to:
        query = query.filter(Assets.acquisition_date <= date_to)
    
    assets = query.all()
    
    total_assets = len(assets)
    total_value = sum(asset.current_value or asset.acquisition_cost or Decimal(0) for asset in assets)
    
    by_category = defaultdict(lambda: {"count": 0, "value": Decimal(0)})
    for asset in assets:
        by_category[asset.category]["count"] += 1
        by_category[asset.category]["value"] += asset.current_value or asset.acquisition_cost or Decimal(0)
    
    by_status = defaultdict(lambda: {"count": 0, "value": Decimal(0)})
    for asset in assets:
        by_status[asset.status.value]["count"] += 1
        by_status[asset.status.value]["value"] += asset.current_value or asset.acquisition_cost or Decimal(0)
    
    by_condition = defaultdict(lambda: {"count": 0, "value": Decimal(0)})
    for asset in assets:
        condition = asset.condition.value if asset.condition else "unknown"
        by_condition[condition]["count"] += 1
        by_condition[condition]["value"] += asset.current_value or asset.acquisition_cost or Decimal(0)
    
    dept_breakdown = defaultdict(lambda: {"count": 0, "value": Decimal(0)})
    for asset in assets:
        if asset.department:
            dept_breakdown[asset.department.name]["count"] += 1
            dept_breakdown[asset.department.name]["value"] += asset.current_value or asset.acquisition_cost or Decimal(0)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="asset_summary_dashboard",
            details={"filters": {"department_id": department_id, "date_from": str(date_from), "date_to": str(date_to)}},
            level=LogLevel.INFO
        )
    
    return {
        "total_assets": total_assets,
        "total_value": float(total_value),
        "by_category": {k: {"count": v["count"], "value": float(v["value"])} for k, v in by_category.items()},
        "by_status": {k: {"count": v["count"], "value": float(v["value"])} for k, v in by_status.items()},
        "by_condition": {k: {"count": v["count"], "value": float(v["value"])} for k, v in by_condition.items()},
        "by_department": {k: {"count": v["count"], "value": float(v["value"])} for k, v in dept_breakdown.items()},
        "generated_at": datetime.now(),
        "filters_applied": {
            "department_id": department_id,
            "date_from": date_from,
            "date_to": date_to
        }
    }


@router.get("/depreciation")
async def get_depreciation_report(
    department_id: Optional[str] = None,
    category: Optional[str] = None,
    min_depreciation_rate: Optional[float] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """2. Depreciation Report - Asset values and depreciation analysis"""
    
    query = db.query(Assets).filter(
        Assets.is_deleted == False,
        Assets.depreciation_rate.isnot(None),
        Assets.acquisition_date.isnot(None)
    )
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if category:
        query = query.filter(Assets.category == category)
    if min_depreciation_rate:
        query = query.filter(Assets.depreciation_rate >= min_depreciation_rate)
    
    assets = query.all()
    
    depreciation_details = []
    total_original_value = Decimal(0)
    total_current_value = Decimal(0)
    total_depreciated = Decimal(0)
    
    for asset in assets:
        if asset.acquisition_cost:
            original_value = asset.acquisition_cost
            current_value = asset.current_value or original_value
            depreciated_amount = original_value - current_value
            depreciation_pct = (depreciated_amount / original_value * 100) if original_value > 0 else 0
            
            years_owned = (datetime.now().date() - asset.acquisition_date).days / 365.25 if asset.acquisition_date else 0
            
            depreciation_details.append({
                "asset_id": asset.id,
                "tag_number": asset.tag_number,
                "description": asset.description,
                "category": asset.category.value,
                "department": asset.department.name if asset.department else None,
                "acquisition_date": asset.acquisition_date,
                "years_owned": round(years_owned, 2),
                "original_value": float(original_value),
                "current_value": float(current_value),
                "depreciation_rate": float(asset.depreciation_rate),
                "depreciated_amount": float(depreciated_amount),
                "depreciation_percentage": round(float(depreciation_pct), 2),
                "useful_life_years": asset.useful_life_years,
                "remaining_life_years": max(0, (asset.useful_life_years or 0) - years_owned) if asset.useful_life_years else None
            })
            
            total_original_value += original_value
            total_current_value += current_value
            total_depreciated += depreciated_amount
    
    depreciation_details.sort(key=lambda x: x["depreciation_percentage"], reverse=True)
    
    nearly_depreciated = [a for a in depreciation_details if a["depreciation_percentage"] > 80]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="depreciation_report",
            details={"filters": {"department_id": department_id, "category": category}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_assets": len(depreciation_details),
            "total_original_value": float(total_original_value),
            "total_current_value": float(total_current_value),
            "total_depreciated_amount": float(total_depreciated),
            "overall_depreciation_percentage": round(
                float((total_depreciated / total_original_value * 100) if total_original_value > 0 else 0), 2
            ),
            "assets_near_full_depreciation": len(nearly_depreciated)
        },
        "assets": depreciation_details,
        "assets_near_full_depreciation": nearly_depreciated[:10],
        "generated_at": datetime.now()
    }


@router.get("/asset-status-condition")
async def get_asset_status_condition_report(
    department_id: Optional[str] = None,
    category: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """3. Asset Status & Condition Report"""
    
    query = db.query(Assets).filter(Assets.is_deleted == False)
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    if category:
        query = query.filter(Assets.category == category)
    
    assets = query.all()
    
    status_breakdown = defaultdict(lambda: {"count": 0, "value": Decimal(0), "assets": []})
    for asset in assets:
        status = asset.status.value
        value = asset.current_value or asset.acquisition_cost or Decimal(0)
        status_breakdown[status]["count"] += 1
        status_breakdown[status]["value"] += value
        if len(status_breakdown[status]["assets"]) < 5:
            status_breakdown[status]["assets"].append({
                "id": asset.id,
                "tag_number": asset.tag_number,
                "description": asset.description
            })
    
    condition_breakdown = defaultdict(lambda: {"count": 0, "value": Decimal(0), "assets": []})
    for asset in assets:
        condition = asset.condition.value if asset.condition else "unknown"
        value = asset.current_value or asset.acquisition_cost or Decimal(0)
        condition_breakdown[condition]["count"] += 1
        condition_breakdown[condition]["value"] += value
        if len(condition_breakdown[condition]["assets"]) < 5:
            condition_breakdown[condition]["assets"].append({
                "id": asset.id,
                "tag_number": asset.tag_number,
                "description": asset.description
            })
    
    requiring_attention = [
        {
            "id": a.id,
            "tag_number": a.tag_number,
            "description": a.description,
            "status": a.status.value,
            "condition": a.condition.value if a.condition else None,
            "department": a.department.name if a.department else None
        }
        for a in assets
        if (a.condition and a.condition.value in ["poor", "fair"]) or 
           a.status.value in ["Under Maintenance", "Impaired", "Lost/Stolen"]
    ]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="asset_status_condition",
            details={"filters": {"department_id": department_id, "category": category}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_assets": len(assets),
            "requiring_attention": len(requiring_attention)
        },
        "by_status": {k: {"count": v["count"], "value": float(v["value"]), "sample_assets": v["assets"]} 
                      for k, v in status_breakdown.items()},
        "by_condition": {k: {"count": v["count"], "value": float(v["value"]), "sample_assets": v["assets"]} 
                         for k, v in condition_breakdown.items()},
        "assets_requiring_attention": requiring_attention,
        "generated_at": datetime.now()
    }


@router.get("/category-specific/{category}")
async def get_category_specific_report(
    category: str,
    department_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """4. Category-Specific Reports (Land, Buildings, Standard Assets)"""
    
    query = db.query(Assets).filter(
        Assets.category == category,
        Assets.is_deleted == False
    )
    
    if department_id:
        query = query.filter(Assets.department_id == department_id)
    
    assets = query.all()
    
    if not assets:
        if sys_logger:
            await enqueue_log(
                user_id=current_user.id,
                action=ActionType.VIEW,
                target_table="reports",
                target_id=f"category_specific_{category}",
                details={"message": "No assets found"},
                level=LogLevel.INFO
            )
        return {
            "category": category,
            "assets": [],
            "total_count": 0,
            "message": "No assets found for this category"
        }
    
    category_fields = get_category_specific_reports_fields(category)
    
    formatted_assets = []
    for asset in assets:
        asset_data = {
            "id": asset.id,
            "tag_number": asset.tag_number,
            "description": asset.description,
            "status": asset.status.value,
            "condition": asset.condition.value if asset.condition else None,
            "location": asset.location,
            "department": asset.department.name if asset.department else None,
            "acquisition_date": asset.acquisition_date,
            "current_value": float(asset.current_value or asset.acquisition_cost or 0),
        }
        
        if asset.specific_attributes:
            formatted_specific = format_attributes_for_display(category, asset.specific_attributes)
            asset_data["specific_attributes"] = formatted_specific
        
        formatted_assets.append(asset_data)
    
    total_value = sum(asset.current_value or asset.acquisition_cost or Decimal(0) for asset in assets)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id=f"category_specific_{category}",
            details={"filters": {"department_id": department_id}},
            level=LogLevel.INFO
        )
    
    return {
        "category": category,
        "total_count": len(assets),
        "total_value": float(total_value),
        "category_specific_fields": category_fields,
        "assets": formatted_assets,
        "generated_at": datetime.now()
    }


@router.get("/unassigned-assets")
async def get_unassigned_assets_report(
    category: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """5. Unassigned Assets +++
    
    
    Report"""
    
    query = db.query(Assets).filter(
        Assets.is_deleted == False,
        or_(
            Assets.responsible_officer_id.is_(None),
            Assets.department_id.is_(None)
        )
    )
    
    if category:
        query = query.filter(Assets.category == category)
    
    assets = query.all()
    
    no_officer = [a for a in assets if a.responsible_officer_id is None]
    no_department = [a for a in assets if a.department_id is None]
    no_both = [a for a in assets if a.responsible_officer_id is None and a.department_id is None]
    
    total_value = sum(a.current_value or a.acquisition_cost or Decimal(0) for a in assets)
    
    asset_details = [
        {
            "id": a.id,
            "tag_number": a.tag_number,
            "description": a.description,
            "category": a.category.value,
            "status": a.status.value,
            "current_value": float(a.current_value or a.acquisition_cost or 0),
            "missing": {
                "responsible_officer": a.responsible_officer_id is None,
                "department": a.department_id is None
            }
        }
        for a in assets
    ]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="unassigned_assets",
            details={"filters": {"category": category}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_unassigned": len(assets),
            "no_officer": len(no_officer),
            "no_department": len(no_department),
            "no_both": len(no_both),
            "total_value": float(total_value)
        },
        "assets": asset_details,
        "generated_at": datetime.now()
    }





/routers/reports/sec_r.py
from fastapi import APIRouter, Depends,Query
from sqlalchemy.orm import Session
from typing import Optional

from datetime import datetime
from collections import defaultdict

from ...database import get_db
from ...models import (
     User, ActivityLog
)
from ...utilities import get_current_user
from ...system_vars import sys_logger
from ...services.logger_queue import enqueue_log
from ...schemas.main import ActionType, LogLevel
from sqlalchemy import desc

router = APIRouter(prefix="/api/v1/r/reports", tags=["Asset Security Reports"])

@router.get("/activity-log")
async def get_activity_log_report(
    user_id: Optional[str] = None,
    action_type: Optional[str] = None,
    date_from: Optional[datetime] = None,
    date_to: Optional[datetime] = None,
    limit: int = Query(100, ge=1, le=1000),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """13. Activity Log Report"""
    
    query = db.query(ActivityLog)
    
    if user_id:
        query = query.filter(ActivityLog.user_id == user_id)
    if action_type:
        query = query.filter(ActivityLog.action == action_type)
    if date_from:
        query = query.filter(ActivityLog.created_at >= date_from)
    if date_to:
        query = query.filter(ActivityLog.created_at <= date_to)
    
    logs = query.order_by(desc(ActivityLog.created_at)).limit(limit).all()
    
    action_summary = defaultdict(int)
    for log in logs:
        action_summary[log.action] += 1
    
    user_summary = defaultdict(int)
    for log in logs:
        if log.user:
            user_name = f"{log.user.first_name} {log.user.last_name}"
            user_summary[user_name] += 1
    
    critical = [log for log in logs if log.logg_level == "CRITICAL"]
    
    log_list = [
        {
            "id": str(log.id),
            "user": f"{log.user.first_name} {log.user.last_name}" if log.user else None,
            "action": log.action,
            "target_table": log.target_table,
            "target_id": log.target_id,
            "level": log.logg_level,
            "details": log.details,
            "created_at": log.created_at
        }
        for log in logs
    ]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="activity_log",
            details={"filters": {"user_id": user_id, "action_type": action_type}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_activities": len(logs),
            "critical_count": len(critical),
            "by_action": dict(action_summary),
            "by_user": dict(user_summary)
        },
        "activities": log_list,
        "generated_at": datetime.now()
    }


@router.get("/failed-login-attempts")
async def get_failed_login_report(
    date_from: Optional[datetime] = None,
    date_to: Optional[datetime] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """14. Failed Login Attempts Report"""
    
    query = db.query(ActivityLog).filter(
        ActivityLog.action == "LOGIN_FAILED"
    )
    
    if date_from:
        query = query.filter(ActivityLog.created_at >= date_from)
    if date_to:
        query = query.filter(ActivityLog.created_at <= date_to)
    
    failed_logins = query.order_by(desc(ActivityLog.created_at)).all()
    
    user_failures = defaultdict(lambda: {"count": 0, "attempts": []})
    for log in failed_logins:
        user_email = log.details.get("email") if log.details else "Unknown"
        user_failures[user_email]["count"] += 1
        user_failures[user_email]["attempts"].append({
            "timestamp": log.created_at,
            "details": log.details
        })
    
    excessive_failures = [
        {"email": email, "count": data["count"], "latest_attempts": data["attempts"][:5]}
        for email, data in user_failures.items() if data["count"] > 5
    ]
    excessive_failures.sort(key=lambda x: x["count"], reverse=True)
    
    suspicious = []
    for email, data in user_failures.items():
        if data["count"] >= 3:
            attempts = sorted(data["attempts"], key=lambda x: x["timestamp"], reverse=True)
            if len(attempts) >= 3:
                time_diff = (attempts[0]["timestamp"] - attempts[2]["timestamp"]).total_seconds() / 60
                if time_diff <= 10:
                    suspicious.append({
                        "email": email,
                        "count": data["count"],
                        "time_window_minutes": round(time_diff, 2)
                    })
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="failed_login_attempts",
            details={"filters": {"date_from": str(date_from), "date_to": str(date_to)}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_failed_attempts": len(failed_logins),
            "unique_users": len(user_failures),
            "users_with_excessive_failures": len(excessive_failures),
            "suspicious_patterns": len(suspicious)
        },
        "by_user": [
            {"email": email, "failure_count": data["count"]}
            for email, data in sorted(user_failures.items(), key=lambda x: x[1]["count"], reverse=True)
        ],
        "excessive_failures": excessive_failures,
        "suspicious_patterns": suspicious,
        "generated_at": datetime.now()
    }


@router.get("/data-modifications")
async def get_data_modification_audit_report(
    target_table: Optional[str] = None,
    user_id: Optional[str] = None,
    date_from: Optional[datetime] = None,
    date_to: Optional[datetime] = None,
    limit: int = Query(100, ge=1, le=500),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """15. Data Modification Audit Report"""
    
    query = db.query(ActivityLog).filter(
        ActivityLog.action.in_(["CREATE", "UPDATE", "DELETE"])
    )
    
    if target_table:
        query = query.filter(ActivityLog.target_table == target_table)
    if user_id:
        query = query.filter(ActivityLog.user_id == user_id)
    if date_from:
        query = query.filter(ActivityLog.created_at >= date_from)
    if date_to:
        query = query.filter(ActivityLog.created_at <= date_to)
    
    modifications = query.order_by(desc(ActivityLog.created_at)).limit(limit).all()
    
    by_action = defaultdict(int)
    for mod in modifications:
        by_action[mod.action] += 1
    
    by_table = defaultdict(int)
    for mod in modifications:
        by_table[mod.target_table or "unknown"] += 1
    
    by_user = defaultdict(int)
    for mod in modifications:
        if mod.user:
            user_name = f"{mod.user.first_name} {mod.user.last_name}"
            by_user[user_name] += 1
    
    high_frequency = []
    for user_name, count in by_user.items():
        if count > 20:
            high_frequency.append({"user": user_name, "modification_count": count})
    high_frequency.sort(key=lambda x: x["modification_count"], reverse=True)
    
    modification_list = [
        {
            "id": str(mod.id),
            "user": f"{mod.user.first_name} {mod.user.last_name}" if mod.user else None,
            "action": mod.action,
            "target_table": mod.target_table,
            "target_id": mod.target_id,
            "details": mod.details,
            "created_at": mod.created_at
        }
        for mod in modifications
    ]
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="reports",
            target_id="data_modifications",
            details={"filters": {"target_table": target_table, "user_id": user_id}},
            level=LogLevel.INFO
        )
    
    return {
        "summary": {
            "total_modifications": len(modifications),
            "by_action": dict(by_action),
            "by_table": dict(by_table),
            "high_frequency_users": len(high_frequency)
        },
        "modifications": modification_list,
        "high_frequency_users": high_frequency,
        "generated_at": datetime.now()
    }

/routers/a_disposal.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, date
from typing import List
import uuid
from ..models import Assets,User,AssetDisposals,AssetStatus,DisposalStatus
from ..utilities import get_current_user
from ..database import get_db
from ..schemas.maintain_dispose import DisposalApproveReq,DisposalExecuteReq,DisposalInitiateReq,DisposalResp,DisposalScheduleReq ,DisposalUndoReq,DisposalHistResp

router = APIRouter(
    prefix="/api/v1/assets",
    tags=["Assets Disposal"]
    )
@router.post("/{asset_id}/disposal/initiate", status_code=201, response_model=DisposalResp)
async def init_disposal(asset_id: str, req: DisposalInitiateReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if not asset:
        raise HTTPException(status_code=404, detail="asset not found")
    
    disposal = AssetDisposals(
        id=str(uuid.uuid4()),
        asset_id=asset_id,
        disposal_method="collected by garbage collection services",
        remarks=req.reason,
        status="initiated"
    )
    
    db.add(disposal)
    db.commit()
    db.refresh(disposal)
    
    return {"msg": "disposal initiated"}

@router.post("/{asset_id}/disposal/schedule", status_code=200, response_model=DisposalResp)
async def schedule_disposal(asset_id: str, req: DisposalScheduleReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    disposal = db.query(AssetDisposals).filter(AssetDisposals.asset_id == asset_id, AssetDisposals.status == "initiated").first()
    if not disposal:
        raise HTTPException(status_code=404, detail="disposal request not found")
    
    disposal.disposal_date = req.disposal_date
    disposal.status = "scheduled"
    if req.disposal_method:
        disposal.disposal_method = req.disposal_method
    
    db.commit()
    db.refresh(disposal)
    
    return {"msg": "disposal scheduled"}

@router.post("/{asset_id}/disposal/approve", status_code=200, response_model=DisposalResp)
async def approve_disposal(asset_id: str, req: DisposalApproveReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    disposal = db.query(AssetDisposals).filter(AssetDisposals.asset_id == asset_id, AssetDisposals.status == "scheduled").first()
    if not disposal:
        raise HTTPException(status_code=404, detail="scheduled disposal not found")
    
    disposal.status = "approved"
    disposal.approved_by = curr_user.id
    
    db.commit()
    db.refresh(disposal)
    
    return {"msg": "disposal approved"}

@router.post("/{asset_id}/disposal/execute", status_code=200, response_model=DisposalResp)
async def execute_disposal(asset_id: str, req: DisposalExecuteReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    disposal = db.query(AssetDisposals).filter(AssetDisposals.asset_id == asset_id, AssetDisposals.status == "approved").first()
    if not disposal:
        raise HTTPException(status_code=404, detail="approved disposal not found")
    
    disposal.status = "executed"
    if req.proceeds_amount:
        disposal.proceeds_amount = req.proceeds_amount
    if req.disposal_cost:
        disposal.disposal_cost = req.disposal_cost
    if req.disposal_method:
        disposal.disposal_method = req.disposal_method
    if req.remarks:
        disposal.remarks = req.remarks
    
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if asset:
        asset.status = AssetStatus.DISPOSED
        asset.disposal_date = disposal.disposal_date
        asset.disposal_value = disposal.proceeds_amount
        asset.disposal_method = disposal.disposal_method
    
    db.commit()
    db.refresh(disposal)
    
    return {"msg": "disposal executed"}

@router.post("/{asset_id}/disposal/undo", status_code=200, response_model=DisposalResp)
async def undo_disposal(asset_id: str, req: DisposalUndoReq, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    disposal = db.query(AssetDisposals).filter(AssetDisposals.asset_id == asset_id, AssetDisposals.status == "executed").first()
    if not disposal:
        raise HTTPException(status_code=404, detail="executed disposal not found")
    
    disposal.status = "undone"
    disposal.remarks = f"{disposal.remarks or ''} | UNDONE: {req.justification}"
    
    asset = db.query(Assets).filter(Assets.id == asset_id).first()
    if asset:
        asset.status = AssetStatus.OPERATIONAL
        asset.disposal_date = None
        asset.disposal_value = None
        asset.disposal_method = None
    
    db.commit()
    db.refresh(disposal)
    
    return {"msg": "disposal undone"}

@router.get("/disposals", status_code=200, response_model=List[DisposalHistResp])
async def get_all_disposals(dept_id: str = None, stat: str = None, start_date: date = None, end_date: date = None, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    q = db.query(AssetDisposals)
    
    if dept_id:
        q = q.join(Assets).filter(Assets.department_id == dept_id)
    if stat:
        q = q.filter(AssetDisposals.status == stat)
    if start_date:
        q = q.filter(AssetDisposals.disposal_date >= start_date)
    if end_date:
        q = q.filter(AssetDisposals.disposal_date <= end_date)
    
    disposals = q.all()
    return disposals

@router.get("/{asset_id}/disposal/history", status_code=200, response_model=List[DisposalHistResp])
async def get_disposal_hist(asset_id: str, curr_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    hist = db.query(AssetDisposals).filter(AssetDisposals.asset_id == asset_id).all()
    return hist/routers/users.py
from fastapi import APIRouter, Depends, HTTPException, status,BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from typing import List, Optional,Union
from ..database import get_db
from ..models import Role, User,GovLevel,Departments
from ..schemas.main import CreateUserAdmin,AuthMethod
from ..utilities import generate_id,get_current_user,generate_id,pwd_context,get_changes
from ..system_vars import sys_logger,debugging,user_default_pass,default_new_user_status,send_emails,sys_logger
from ..services.logger_queue import enqueue_log
from ..schemas.main import  ActionType, LogLevel,GivePerms,UserStatus,UserOutWithRole, ModifyProfile,ChangeUserStatus,NoChangesResponse,UserOutProfile
from ..services.policy_eval import check_simple_permission,check_full_permission,get_user_perms
from sqlalchemy import or_, func
from datetime import datetime, timezone
from sqlalchemy.orm import joinedload

if send_emails:
    from .auth import email_service
router = APIRouter(
    prefix="/api/v1/users", 
    tags=["Users "]
    )

@router.get("/",status_code=status.HTTP_200_OK,response_model=List[UserOutWithRole])
async def get_all_users_param(current_user: User = Depends(get_current_user),db :Session = Depends(get_db),
                              status: Optional[UserStatus] = None,
                              namecontains: Optional[str] = None,
                              email:Optional[str] = None,
                              last_login:Optional[datetime] = None,
                              phone:Optional [str] = None,

                              location_code: Optional[str] =None,
                              department_id:Optional[str] =None,
                              gov_level: Optional[GovLevel] = None,
                              role_id: Optional[str] = None):
    """use is as a search function

    Args:

      - status (Optional[UserStatus], optional): active,inactive ... Defaults to None.
      - namecontains (Optional[str], optional): part of name. Defaults to None.
      - isactive (Optional[bool], optional): true, false,bool. Defaults to None.
      - email (Optional[str], optional): full email. Defaults to None.
      - last_login (Optional[datetime], optional): timestamp . Defaults to None.
      - phone (Optional[str], optional): 07xbhjb. Defaults to None.
      - role (Optional[str], optional): role name, not id. Defaults to None.

    Raises:
        HTTPException: not fround

    Returns:
        User: _description_
    """

    if not check_simple_permission(current_user, "users","read"):
        raise HTTPException(status_code=403, detail="Not enough permissions")
    

    # returns only users within checker scope
    # - check department or reginal access scope
    # - attribute/roles - department head/ hr/ analytics ==[to imp]
    users = db.query(User)


    if status:
        users= users.filter(User.status == status)
    if namecontains:
        term = namecontains.lower().strip()
        pattern = '%' + '%'.join(term) + '%'
        users = users.filter(
            or_(
                func.lower(User.first_name).like(pattern),
                func.lower(User.last_name).like(pattern),
                func.lower(func.concat(User.first_name, ' ', User.last_name)).like(pattern)
            )
        )
   
    if email:
        users = users.filter(User.email == email)
    if last_login:
        users = users.filter(User.last_login >= last_login)
    if phone:
        users = users.filter(User.phone == phone)
    if role_id:
        users = users.join(User.role).filter(Role.name == role_id)
    if gov_level:
        users = users.filter(User.gov_level == gov_level)
    
    if sys_logger:
        await enqueue_log(
            user_id=current_user.id,
            action=ActionType.VIEW,
            target_table="users",
            target_id=None,
            details={"msg": "search function"},
            level=LogLevel.INFO
            )  
    
    return users.all()

@router.get("/me",status_code=status.HTTP_200_OK,response_model=UserOutProfile)
async def get_my_profile(me :User = Depends(get_current_user),db: Session = Depends(get_db)):
    return me

@router.put("/me",status_code=status.HTTP_200_OK,response_model=Union[UserOutProfile ,NoChangesResponse])
async def patch_my_profile(newval: ModifyProfile, me :User = Depends(get_current_user),db: Session = Depends(get_db)):
    old = db.query(User).filter(User.id == me.id).first()
    newme ,changes= get_changes(old,newval)
    
    if changes:
        
        db.commit()
        db.refresh(newme)
        return newme
    
    return {"detail": "No changes supplied"}


@router.get("/me/permissions",status_code=status.HTTP_200_OK)
async def get_my_allowd_permissions(me :User = Depends(get_current_user),db: Session = Depends(get_db)):
    #acess scope check

    return get_user_perms(user=me,db=db)

@router.get("/me/permissions/{resource}",status_code=status.HTTP_200_OK)
async def get_my_allowed_actions_for_resource(resource ,me :User = Depends(get_current_user),db: Session = Depends(get_db)):
    #acess scope
    #permissions for assigned role= make helper func
    perms = get_user_perms(user=me,db=db)
    specific = [p for p in perms if p.startswith(f"{resource}.")]
    actions =sorted({p.split(".",1)[1] for p in specific})

    return actions

#----------------------------------
@router.get("/{user_id}/permissions",status_code=status.HTTP_200_OK)
async def get_user_permissions_adm(user_id,curr : User = Depends(get_current_user),db: Session = Depends(get_db)):
    #add checks, hr, permissision to check, scope, shouldnt check superior
    perms = get_user_perms(id=user_id,db=db)
    return perms

@router.get("/{user_id}/permissions/{resource}",status_code=status.HTTP_200_OK)
async def get_user_permissions_per_resource_adm(resource,user_id,curr : User = Depends(get_current_user),db: Session = Depends(get_db)):

    perms = get_user_perms(id=user_id,db=db)
    specific = [p for p in perms if p.startswith(f"{resource}.")]
    actions =sorted({p.split(".",1)[1] for p in specific})
    return actions

@router.put("/{user_id}/permissions",status_code=status.HTTP_200_OK)
async def give_user_permissions_adm(user_id ,pp: GivePerms,curr : User = Depends(get_current_user),db: Session = Depends(get_db)):
    #check fist if you have said permission, then give
    user = db.query(User).filter(User.id == user_id).first()

    role_perms = db.query(Role).filter(Role.id == user.role_id).first()
        
    if not role_perms:
        raise HTTPException(status_code=404, detail="Target not Assigned any role")

    rperm = set(role_perms.permissions or [])
    aperm = set(user.assigned_perms or [])

    nperm = []

    for p in pp.permissions:
        if p not in rperm and p not in aperm:
            nperm.append(p)
            aperm.add(p)

    user.assigned_perms = list(aperm)
    db.add(user)
    db.commit()
    db.refresh(user)

    return {"added": nperm,"now_has": user.assigned_perms}

@router.get("/{user_id}/permissions/{resource}",status_code=status.HTTP_200_OK)
async def get_user_permissions_by_resource_adm(user_id,resource,curr : User = Depends(get_current_user),db: Session = Depends(get_db)):
    #add checks, hr, permissision to check, scope, shouldnt check superior
    perms = get_user_perms(id=user_id,db=db)
    specific = [p for p in perms if p.startswith(f"{resource}.")]
    actions =sorted({p.split(".",1)[1] for p in specific})

    return actions


@router.get("/{user_id}", response_model=UserOutWithRole)
async def get_user_details(
    user_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get specific user details with resource-based access control"""
    # - confirm checker department below target
    #- checker attributes manage-attributes, HR
    # - else return not enoth perm to view this user
    
    target = db.query(User).options(
        joinedload(User.role),
        joinedload(User.department)
    ).filter(User.id == user_id).first()
    
    if not target:
        raise HTTPException(status_code=404, detail="User not found")

    # resource = {
    #     "target_id": target.id,
    #     "target_county": target.location_code,
    #     "target_department": target.department.name if target.department else None,
    #     "target_role": target.role.name if target.role else None,
    #     "is_self": current_user.id == user_id,
    #     "is_same_county": current_user.location_code == target.location_code,
    #     "is_same_department": current_user.department_id == target.department_id
    # }

    # if not check_permission(current_user, "users", "read", db, resource):
    #     raise HTTPException(status_code=403, detail="Not enough permissions")
    
    return target

@router.post("/", status_code=status.HTTP_201_CREATED,response_model=UserOutWithRole)

async def create_new_user_adm(user: CreateUserAdmin , db: Session = Depends(get_db)):
    # must be hr , has create-user attribute
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="User already exists")
 
    hashed_pass = pwd_context.hash(user_default_pass)
    user_id = generate_id()

    if user.entity_name:
        eval_ent_name=user.entity_name
    else:
        try:
            rl = db.query(Departments).filter(Departments.dept_id == user.department_id).first()
            eval_ent_name = rl.name
        except IntegrityError as e:
            raise HTTPException(status_code=status.HTTP_304_NOT_MODIFIED,detail = "invalid department id or entitiy name")

            

    new_user = User(
        id=user_id,
        profile_pic=user.profile_pic,
        first_name=user.first_name,
        last_name=user.last_name,
        email=user.email,
        phone_number=user.phone_number,
        department_id=user.department_id,
        position_title=user.position_title,
        is_accounting_officer=False,
        password_hash=hashed_pass,  
        role_id=user.role_id,
        status=user.status,
        created_at=datetime.now(timezone.utc),
        last_login=None,
        gov_level=user.gov_level,
        entity_type=user.entity_type,

        entity_name=eval_ent_name,
        location=user.location.dict(),
        access_scope='{}',
        is_two_factor_enabled=False,
        last_password_change=None,
        login_attempts=None,
        last_activity_at=None,
        notes=user.notes,
        auth_method=AuthMethod.password,
    )

    db.add(new_user)
    db.commit()
    
    db.refresh(new_user) 
    return new_user



@router.put("/{user_id}",status_code=status.HTTP_200_OK,response_model=Union[dict ,NoChangesResponse]) #UserOutWithRole
# hr, change doesnt escalate rank,
async def patch_user_details_adm(user_id,usernd:CreateUserAdmin ,current_user: User = Depends(get_current_user) ,db: Session = Depends(get_db)):

    usr = db.query(User).filter(User.id == user_id).first()

    new_usr, changes = get_changes(usr,usernd)
    if changes:
        
        db.commit()
        db.refresh(new_usr)
        return changes
    

    # raise HTTPException(detail="No changes applied", status_code=200)
    return {"detail": "No changes supplied"}



@router.put("/{user_id}/status", status_code=status.HTTP_200_OK,response_model=Union[dict,UserOutWithRole])
async def patch_user_status(user_id,usernd:ChangeUserStatus ,background_tasks: BackgroundTasks,current_user: User = Depends(get_current_user) ,db: Session = Depends(get_db)):
    #dep head, target subordinate, can update status, in scope,dep,coumty or national, ht

    usr = db.query(User).filter(User.id == user_id).first()
    if not usr:
        raise HTTPException(detail="User not found",status_code=status.HTTP_400_BAD_REQUEST)
    if usr.status == usernd.status :
        return {"detail": "No changes supplied"}

    usr.status = usernd.status
    
    db.commit()
    db.refresh(usr)
    if send_emails:
        background_tasks.add_task(
            email_service.send_account_activated_email,
            str(usr.email),
            str(usr.first_name)
        )
    return {"detail": f"status changed to: {usr.status.value}"}


@router.delete("/{user_id}", status_code=status.HTTP_200_OK,response_model=dict)
async def delete_user(user_id,usernd:ChangeUserStatus ,current_user: User = Depends(get_current_user) ,db: Session = Depends(get_db)):
    #dep head, target subordinate, can update status, in scope,dep,coumty or national, ht

    usr = db.query(User).filter(User.id == user_id).first()
    if usr.status.value == "deleted":
        return {"detail": "User Already Deleted"}
    usr.status = UserStatus.deleted
    db.commit()
    db.refresh(usr)

    return {"detail":f"Success! delete user{usr.id}"}

/routers/location.py
from fastapi import APIRouter, HTTPException, Depends, Query
from typing import List, Optional
from ..services.location_service import LocationService
from ..schemas.location import *

router = APIRouter(prefix="/api/v1/locations",
                    tags=["locations"])
 

def get_location_service() -> LocationService:
    return LocationService()

@router.get("/counties/", response_model=List[CountySimple])
async def get_counties(service: LocationService = Depends(get_location_service)):
    """Get list of all counties"""
    return service.get_all_counties()

@router.get("/counties/{county_identifier}/", response_model=dict)
async def get_county_constituencies(
    county_identifier: str,
    service: LocationService = Depends(get_location_service)
):
    """Get constituencies for a specific county use ID or name"""
    return service.get_constituencies(county_identifier)

@router.get("/counties/{county_identifier}/constituencies/{constituency_name}/", response_model=WardResponse)
async def get_constituency_wards(
    county_identifier: str,
    constituency_name: str,
    service: LocationService = Depends(get_location_service)
):
    """Get wards for a specific constituency"""
    return service.get_wards(county_identifier, constituency_name)

@router.get("/counties/{county_identifier}/tree/", response_model=County)
async def get_county_tree(
    county_identifier: str,
    service: LocationService = Depends(get_location_service)
):
    """Get complete county hierarchy (constituencies and wards)"""
    return service.get_county_tree(county_identifier)

@router.get("/search/", response_model=SearchResult)
async def search_locations(
    q: str = Query(..., min_length=2, description="Search query"),
    service: LocationService = Depends(get_location_service)
):
    """Search across counties, constituencies, and wards"""
    return service.search_locations(q)

@router.get("/coordinates/reverse/", response_model=LocationDetails)
async def reverse_geocode(
    lat: float = Query(..., description="Latitude"),
    lng: float = Query(..., description="Longitude"),
    service: LocationService = Depends(get_location_service)
):
    """Get location details from coordinates"""
    if not (-90 <= lat <= 90):
        raise HTTPException(status_code=400, detail="Invalid latitude")
    if not (-180 <= lng <= 180):
        raise HTTPException(status_code=400, detail="Invalid longitude")
    
    return await service.reverse_geocode(lat, lng)

@router.get("/search/geocode/", response_model=List[LocationDetails])
async def forward_geocode(
    address: str = Query(..., min_length=3, description="Address or place name"),
    service: LocationService = Depends(get_location_service)
):
    """Get coordinates from address/place name"""
    return await service.forward_geocode(address)/models.py
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, Date, Text, JSON, ForeignKey, Enum as SQLEnum, DECIMAL, Index, MetaData, Numeric, Interval
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship,Mapped, mapped_column
from sqlalchemy.sql import func
from datetime import datetime
from .database import Base
import uuid
import enum
from sqlalchemy.dialects.postgresql import UUID,JSONB
from sqlalchemy.ext.hybrid import hybrid_property

class PasswordResetToken(Base):
    __tablename__ = "password_reset_tokens"
    
    token = Column(String(150), primary_key=True, index=True)
    user_email = Column(String(50), nullable=False)
    expires_at = Column(DateTime, nullable=False)
    is_used = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
  
class TokenBase(Base):
    __tablename__ = 'usertokens'

    jti = Column(String(40), primary_key=True, index=True)
    iat = Column(DateTime(timezone=True), nullable=False)
    user_id = Column(String(60), ForeignKey('users.id'))
    exp = Column(DateTime(timezone=True), nullable=False)
    token = Column(String(500), nullable=False)
    revoked = Column(Boolean)
    
    user = relationship("User", back_populates="tokens")

class UserStatus(str, enum.Enum):
    active = "active"
    inactive = "inactive"
    deleted = "deleted"
    suspended = "suspended"
    temp_disabled = "temp_disabled"

class GovLevel(str, enum.Enum):
    county = "county"
    national = "national"

class EntityType(str, enum.Enum):
    ministry = "ministry"
    department = "department"
    agency = "agency"
    county_assembly = "county_assembly"
    commission = "commission"
    SAGA = "SAGA"
    state_corporation = "state_corporation"
    county = "county"

class AuthMethod(str, enum.Enum):
    password = "password"
    oauth = "oauth"
    sso = "sso"

class Role(Base):
    __tablename__ = "roles"

    id = Column(String(60), primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False, index=True) # "admin", "auditor" c o staff,,
    description = Column(String(255))  
    permissions = Column(JSON, nullable=True)          
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    user = relationship("User", back_populates="role")

class DeviceFingerprint(Base):
    __tablename__ = "device_fingerprints"
    
    id = Column(String(60), primary_key=True, index=True)
    user_id = Column(String(60), ForeignKey('users.id'), nullable=False)
    fingerprint_hash = Column(String(255), nullable=False, index=True)
    device_info = Column(JSON, nullable=True)
    browser = Column(String(100), nullable=True)
    os = Column(String(100), nullable=True)
    ip_at_registration = Column(String(45), nullable=True)
    first_seen = Column(DateTime(timezone=True), server_default=func.now())
    last_seen = Column(DateTime(timezone=True), server_default=func.now())
    is_deleted = Column(Boolean, default=False, nullable=False)
    is_trusted = Column(Boolean, default=False, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User", back_populates="device_fingerprints")

class IPWhitelist(Base):
    __tablename__ = "ip_whitelist"
    
    id = Column(String(60), primary_key=True, index=True)
    user_id = Column(String(60), ForeignKey('users.id'), nullable=False)
    ip_address = Column(String(45), nullable=False, index=True)
    whitelist_type = Column(String(20), nullable=False)
    whitelisted_at = Column(DateTime(timezone=True), server_default=func.now())
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User", back_populates="ip_whitelists")

class LoginAttempt(Base):
    __tablename__ = "login_attempts"
    
    id = Column(String(60), primary_key=True, index=True)
    user_id = Column(String(60), ForeignKey('users.id'), nullable=True)
    email = Column(String(120), nullable=False, index=True)
    ip_address = Column(String(45), nullable=False)
    fingerprint_hash = Column(String(255), nullable=True)
    success = Column(Boolean, nullable=False)
    failure_reason = Column(String(255), nullable=True)
    location = Column(JSON, nullable=True)
    device_info = Column(JSON, nullable=True)
    browser = Column(String(100), nullable=True)
    os = Column(String(100), nullable=True)
    timezone = Column(String(50), nullable=True)
    language = Column(String(10), nullable=True)
    ip_details = Column(JSON, nullable=True)
    fraud_score = Column(Integer, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), index=True)
    
    user = relationship("User", back_populates="login_attempts")

class MFACode(Base):
    __tablename__ = "mfa_codes"
    
    id = Column(String(60), primary_key=True, index=True)
    user_id = Column(String(60), ForeignKey('users.id'), nullable=False)
    code = Column(String(10), nullable=False)
    temp_session_token = Column(String(500), nullable=False, unique=True, index=True)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    used = Column(Boolean, default=False, nullable=False)
    ip_address = Column(String(45), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User", back_populates="mfa_codes")

class TempDisableLog(Base):
    __tablename__ = "temp_disable_logs"
    
    id = Column(String(60), primary_key=True, index=True)
    user_id = Column(String(60), ForeignKey('users.id'), nullable=False)
    reason = Column(String(255), nullable=False)
    disabled_at = Column(DateTime(timezone=True), server_default=func.now())
    disabled_until = Column(DateTime(timezone=True), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User", back_populates="temp_disable_logs")



class User(Base):
    __tablename__ = "users"

    id = Column(String(60), primary_key=True, index=True)
    profile_pic=  Column(String(200), nullable=True)
    first_name = Column(String(100), nullable=False)
    last_name = Column(String(100), nullable=False)
    email = Column(String(120), unique=True, nullable=False, index=True)
    phone_number = Column(String(20), unique=True, index=True)
    department_id = Column(String(60), ForeignKey('departments.dept_id'), nullable=False)
    
    position_title = Column(String(255), default="member", nullable=False)
    is_accounting_officer = Column(Boolean, default=False, nullable=False)
    password_hash = Column(String, nullable=False)
    role_id = Column(String(50), ForeignKey('roles.id'),nullable=True)
    
    status = Column(SQLEnum(UserStatus), default=UserStatus.inactive, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    last_login = Column(DateTime(timezone=True))
    
    gov_level = Column(SQLEnum(GovLevel), default=GovLevel.county, nullable=False)
    entity_type = Column(SQLEnum(EntityType), default=EntityType.department, nullable=False)
    entity_name = Column(String(80), nullable=False)
    location = Column(JSON, nullable=True)
    assigned_perms = Column(JSON)
    access_scope = Column(JSON)
    is_two_factor_enabled = Column(Boolean, default=False)
    last_password_change = Column(DateTime(timezone=True))
    login_attempts = Column(Integer, default=0, nullable=False)
    last_activity_at = Column(DateTime(timezone=True))
    notes = Column(Text)
    auth_method = Column(SQLEnum(AuthMethod), default=AuthMethod.password, nullable=False)

    timezone = Column(String(50), default="EAT", nullable=False)
    temp_disabled_until = Column(DateTime(timezone=True), nullable=True)
    
    @hybrid_property
    def is_department_head(self):
        return bool(self.departments_headed or self.departments_deputy)

    @hybrid_property
    def headed_departments(self):
        return list(self.departments_headed + self.departments_deputy)

    @hybrid_property
    def full_name(self):
        return str(self.first_name +' '+ self.last_name)

    tokens = relationship("TokenBase", back_populates="user", cascade="all, delete-orphan")
    department = relationship("Departments", back_populates="users",foreign_keys=[department_id])
    role = relationship("Role", back_populates="user", uselist=False)
    activitylogs = relationship("ActivityLog",back_populates="user")
    assets_responsible_for = relationship("Assets", foreign_keys="Assets.responsible_officer_id", back_populates="responsible_officer")
    assets_checked = relationship("Assets", foreign_keys="Assets.checked_by", back_populates="checked_by_user")
    assets_authorized = relationship("Assets", foreign_keys="Assets.authorized_by", back_populates="authorized_by_user")
    assets_created = relationship("Assets", foreign_keys="Assets.created_by", back_populates="created_by_user")

    departments_headed = relationship("Departments", foreign_keys="Departments.department_head_id", back_populates="department_head")
    departments_deputy = relationship("Departments", foreign_keys="Departments.deputy_head_id", back_populates="deputy_head")

    device_fingerprints = relationship("DeviceFingerprint", back_populates="user", cascade="all, delete-orphan")
    ip_whitelists = relationship("IPWhitelist", back_populates="user", cascade="all, delete-orphan")
    login_attempts = relationship("LoginAttempt", back_populates="user", cascade="all, delete-orphan")
    mfa_codes = relationship("MFACode", back_populates="user", cascade="all, delete-orphan")
    temp_disable_logs = relationship("TempDisableLog", back_populates="user", cascade="all, delete-orphan")

class Departments(Base):
    __tablename__ = "departments"

    dept_id = Column(String(60), primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    parent_dept_id = Column(String(60), ForeignKey('departments.dept_id'), nullable=True)
    entity_type = Column(SQLEnum(EntityType), nullable=False)
    description = Column(Text)
    status = Column(SQLEnum(UserStatus), default=UserStatus.active,nullable=False)

    department_head_id = Column(String(60), ForeignKey('users.id'), nullable=True)
    deputy_head_id = Column(String(60), ForeignKey('users.id'), nullable=True)  # toa..
    county_code = Column(String(10), nullable=True)

    
    department_head = relationship("User", foreign_keys=[department_head_id], back_populates="departments_headed")
    deputy_head = relationship("User", foreign_keys=[deputy_head_id], back_populates="departments_deputy")

    parent = relationship("Departments", remote_side=[dept_id], backref="sub_departments")
    users = relationship("User", back_populates="department",foreign_keys="User.department_id")
    assets = relationship("Assets", back_populates="department")


class ActivityLog(Base):
    __tablename__ = "activity_logs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(String(50), ForeignKey('users.id'), nullable=True)  
    action  = Column(String, nullable=True) 
    target_table = Column(String, nullable=True) 
    target_id = Column(String, nullable=True) 
    logg_level =Column(String, nullable=True) 
    details =  Column(JSON, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User", back_populates="activitylogs")

class PolicyEffect(str, enum.Enum):
    ALLOW = "allow"
    DENY = "deny"

class ABACPolicy(Base):
    __tablename__ = "abac_policies"
    
    id = Column(Integer, primary_key=True)
    description = Column(Text, nullable=False)
    effect = Column(SQLEnum(PolicyEffect), nullable=False, default=PolicyEffect.ALLOW)
    
    user_attributes = Column(JSON, nullable=False) # e.g., {"position_title": "Accounting Officer"}
    action_names = Column(JSONB, nullable=False) # e.g., ["asset.approve_disposal", "asset.write_off"]
    resource_attributes = Column(JSON, nullable=False) # e.g., {"category": "ICT_EQUIPMENT", "status": "Operational"}
    
    priority = Column(Integer, default=0, nullable=False) # not sure if needed
    is_active = Column(Boolean, default=True, nullable=False)

class AssetCategory(str, enum.Enum):
    STANDARD_ASSETS = "Standard Assets"
    LAND = "Land"
    BUILDINGS = "Buildings and building improvements"
    ROAD_INFRASTRUCTURE = "Road infrastructure"
    RAILWAY_INFRASTRUCTURE = "Railway infrastructure"
    OTHER_INFRASTRUCTURE = "Other Infrastructure"
    MOTOR_VEHICLES = "Motor vehicles, other transport Equipment"
    ICT_EQUIPMENT = "Computers and other ICT equipment"
    FURNITURE_FITTINGS = "Furniture, fittings & equipment"
    INVESTMENT_PROPERTY = "Investment property"
    LEASED_ASSETS = "Leased Assets"
    HERITAGE_ASSETS = "Heritage assets"
    WORK_IN_PROGRESS = "Work in Progress"
    INTANGIBLE_ASSETS = "Intangible assets"
    BIOLOGICAL_ASSETS = "Biological assets"
    SUBSOIL_ASSETS = "Subsoil assets"
    PLANT_MACHINERY = "Plant and Machinery"
    PORTABLE_ATTRACTIVE = "Portable and attractive items"


class AssetStatus(str, enum.Enum):
    OPERATIONAL = "Operational"
    UNDER_MAINTENANCE = "Under Maintenance"
    IMPAIRED = "Impaired"
    DISPOSED = "Disposed"
    HELD_FOR_SALE = "Held for Sale"
    RETIRED = "Retired"
    LOST_STOLEN = "Lost/Stolen"
    WORK_IN_PROGRESS = "Work in Progress"
    

class AssetCondition(str, enum.Enum):
    NEW = "new"
    EXCELLENT = "excellent"
    GOOD = "good"
    FAIR = "fair"
    POOR = "poor"

class TransferStatus(str, enum.Enum):
    INITIATED = "initiated"
    APPROVED = "approved"
    REJECTED = "rejected"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    PENDING = "pending"

class MaintenanceStatus(str, enum.Enum):
    INITIATED = "initiated"
    SCHEDULED = "scheduled" 
    APPROVED = "approved"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class DisposalStatus(str, enum.Enum):
    INITIATED = "initiated"
    SCHEDULED = "scheduled"
    APPROVED = "approved" 
    EXECUTED = "executed"
    CANCELLED = "cancelled"
    UNDONE = "undone"

class Assets(Base):
    __tablename__ = "assets"

    id = Column(String(60), primary_key=True, index=True)
    pic =  Column(String(200), nullable=True)
    other_pics = Column(JSON,nullable=True,default='{}')
    name = Column(String(100), nullable=False)
    description = Column(Text, nullable=False)
    category = Column(SQLEnum(AssetCategory), nullable=False, index=True)
    tag_number = Column(String(100), unique=True, index=True)
    serial_number = Column(String(100), index=True)
    barcode = Column(String(100), unique=True, index=True, nullable=True)
    qr_code = Column(String(500), nullable=True)
    department_id = Column(String(60), ForeignKey('departments.dept_id'), nullable=True)
    responsible_officer_id = Column(String(60), ForeignKey('users.id'), nullable=True)
    location = Column(JSON,nullable = True)
    
    status = Column(SQLEnum(AssetStatus), default=AssetStatus.OPERATIONAL, nullable=False, index=True)
    condition = Column(SQLEnum(AssetCondition), default=AssetCondition.GOOD)

    #  finance info
    acquisition_date = Column(Date)
    acquisition_cost = Column(DECIMAL(18, 2), nullable=False)
    source_of_funds = Column(String(100))
    current_value = Column(DECIMAL(18, 2))# smthin called Net Book Value
    depreciation_rate = Column(DECIMAL(5, 2))
    useful_life_years = Column(Integer)
    
    # Dispose
    disposal_date = Column(Date)
    disposal_value = Column(DECIMAL(18, 2))
    disposal_method = Column(String(100))

    # Additional Information
    is_portable_attractive = Column(Boolean, default=False)
    insurance_details = Column(JSON)  # {"provider": "X", "policy_no": "Y", "expiry": "date"}
    maintenance_schedule = Column(JSON)
    revaluation_history = Column(JSON)
    specific_attributes = Column(JSON) 
    
    # audit
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    created_by = Column(String(60), ForeignKey('users.id'))
    is_deleted = Column(Boolean, default=False)
    checked_by = Column(String(60), ForeignKey('users.id'), nullable=True)
    authorized_by = Column(String(60), ForeignKey('users.id'), nullable=True)

    department = relationship("Departments", back_populates="assets")
    responsible_officer = relationship("User", foreign_keys=[responsible_officer_id], back_populates="assets_responsible_for")
    created_by_user = relationship("User", foreign_keys=[created_by],back_populates="assets_created")
    lifecycle_events = relationship("AssetLifecycleEvents", back_populates="asset")
    transfers = relationship("AssetTransfers", back_populates="asset")
    maintenance_requests = relationship("MaintenanceRequests", back_populates="asset")
    disposals = relationship("AssetDisposals", back_populates="asset")
    checked_by_user = relationship("User", foreign_keys=[checked_by], back_populates="assets_checked")
    authorized_by_user = relationship("User", foreign_keys=[authorized_by], back_populates="assets_authorized")

class AssetLifecycleEvents(Base): #logging 2, work alongside the other
    __tablename__ = "asset_lifecycle_events"

    id = Column(String(60), primary_key=True, index=True)
    asset_id = Column(String(60), ForeignKey("assets.id"), nullable=False)
    event_type = Column(String(50), nullable=False)  # like created, activated, transferred
    event_date = Column(DateTime, default=func.now())
    performed_by = Column(String(60), ForeignKey("users.id"))
    details = Column(JSON) 
    remarks = Column(Text)

    asset = relationship("Assets", back_populates="lifecycle_events")
    performed_by_user = relationship("User")

class AssetTransfers(Base):
    __tablename__ = "asset_transfers"

    id = Column(String(60), primary_key=True, index=True)
    asset_id = Column(String(60), ForeignKey("assets.id"), nullable=False)
    
    #details
    from_user_id = Column(String(60), ForeignKey("users.id"))
    to_user_id = Column(String(60), ForeignKey("users.id"))
    from_dept_id = Column(String(60), ForeignKey("departments.dept_id"))
    to_dept_id = Column(String(60), ForeignKey("departments.dept_id"))
    
    initiated_by = Column(String(60), ForeignKey("users.id"))
    initiated_date = Column(DateTime, default=func.now())
    approved_by = Column(String(60), ForeignKey("users.id"))
    approval_date = Column(DateTime)
    completed_date = Column(DateTime)
    
    status = Column(SQLEnum(TransferStatus), default=TransferStatus.INITIATED)
    transfer_reason = Column(Text)
    remarks = Column(Text)
 
    asset = relationship("Assets", back_populates="transfers")
    from_user = relationship("User", foreign_keys=[from_user_id])
    to_user = relationship("User", foreign_keys=[to_user_id])
    initiated_by_user = relationship("User", foreign_keys=[initiated_by])
    approved_by_user = relationship("User", foreign_keys=[approved_by])


# Add these Enums near your other enums
class MaintenanceType(str, enum.Enum):
    CORRECTIVE = "corrective" 
    PREVENTIVE = "preventive" 
    MAJOR = "major" 
    MANUFACTURER = "manufacturer" 
    REFURBISHMENT = "refurbishment"
    ENHANCEMENT = "enhancement"
    DEFERRED = "deferred"

class IssueCategory(str, enum.Enum):
    MECHANICAL_FAILURE = "mechanical_failure"
    MECHANICAL_ISSUE = "mechanical_issue"
    ELECTRICAL = "electrical"
    SOFTWARE = "software"
    PHYSICAL_DAMAGE = "physical_damage"
    THEFT_LOSS = "theft_loss"
    OBSOLESCENCE = "obsolescence"
    FIRE_NATURAL = "fire_or_natural_disaster"
    COMPLIANCE = "compliance"
    OTHER = "other"

class PriorityLevel(str, enum.Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

class SeverityLevel(str, enum.Enum):
    MINOR = "minor"
    MAJOR = "major"
    CRITICAL = "critical"
class MaintenanceOutcome(str, enum.Enum):
    FIXED = "fixed"
    NOT_FIXED = "not_fixed"

class MaintenanceRequests(Base):
    __tablename__ = "maintenance_requests"

    id = Column(String(60), primary_key=True, index=True)
    asset_id = Column(String(60), ForeignKey("assets.id"), nullable=False)
    requested_by = Column(String(60), ForeignKey("users.id"))
    request_date = Column(DateTime, default=func.now())
    issue_type = Column(String(50))
    description = Column(Text)
    status =  Column(SQLEnum(MaintenanceStatus), default=MaintenanceStatus.INITIATED, nullable=True, index=True)
    assigned_to = Column(String(60), ForeignKey("users.id"))
    resolved_date = Column(DateTime)
    maintenance_date = Column(DateTime)
    notes = Column(Text)

    maintenance_type = Column(SQLEnum(MaintenanceType), nullable=False, default=MaintenanceType.CORRECTIVE, index=True)
    issue_category = Column(SQLEnum(IssueCategory), nullable=False, index=True)
    priority = Column(SQLEnum(PriorityLevel), default=PriorityLevel.MEDIUM, nullable=False, index=True)
    severity = Column(SQLEnum(SeverityLevel), default=SeverityLevel.MINOR, nullable=True)

    cost = Column(Numeric(12, 2), nullable=True)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    duration = Column(Interval, nullable=True)

    outcome = Column(SQLEnum(MaintenanceOutcome),default=MaintenanceOutcome.FIXED, nullable=True)

    asset = relationship("Assets", back_populates="maintenance_requests")
    requester = relationship("User", foreign_keys=[requested_by])
    assignee = relationship("User", foreign_keys=[assigned_to])

class AssetDisposals(Base):# define further, saw donations etc for dispose
    __tablename__ = "asset_disposals"

    id = Column(String(60), primary_key=True, index=True)
    asset_id = Column(String(60), ForeignKey("assets.id"), nullable=False)
    status =  Column(SQLEnum(DisposalStatus), default=DisposalStatus.INITIATED, nullable=True, index=True)
    disposal_method = Column(String(100))
    disposal_date = Column(Date)
    approved_by = Column(String(60), ForeignKey("users.id"))
    proceeds_amount = Column(DECIMAL(18, 2))
    disposal_cost = Column(DECIMAL(18, 2))
    remarks = Column(Text)

    asset = relationship("Assets", back_populates="disposals")
    approver = relationship("User")

class AssetRevaluations(Base):
    __tablename__ = "asset_revaluations"

    id = Column(String(60), primary_key=True, index=True)
    asset_id = Column(String(60), ForeignKey("assets.id"), nullable=False)
    revaluation_date = Column(Date)
    previous_value = Column(DECIMAL(18, 2))
    new_value = Column(DECIMAL(18, 2))
    revaluation_method = Column(String(100))
    performed_by = Column(String(60), ForeignKey("users.id"))
    next_revaluation_date = Column(Date)
    remarks = Column(Text)

    asset = relationship("Assets")
    revaluator = relationship("User")
/system_vars.py
from .schemas.main import UserStatus

ACCESS_TOKEN_EXPIERY = 60

#response params
httponly=True
secure=False
samesite="none"

send_emails = True
sys_logger = True
debugging = True
user_default_pass = "ChangeMeNow"


default_new_user_status= UserStatus.active
default_new_department_status = UserStatus.active
default_role_id= "0a76806dc312733ae4dd271b271048"


KNOWN_DEVICE_MAX_ATTEMPTS = 5
UNKNOWN_DEVICE_MAX_ATTEMPTS = 2

UNLOCK_ACCOUNT_TOKEN_EXPIRY_MINUTES = 60 

TEMP_DISABLE_DURATION_HOURS = 24
FINAL_ATTEMPTS_BEFORE_LOCK = 2
PASSWORD_EXPIRY_DAYS = 90
FRAUD_SCORE_LIMIT = 70
WORKING_HOURS_START = 8
WORKING_HOURS_END = 17
EXPECTED_TIMEZONE = "EAT"
EXPECTED_LANGUAGE = "en"
IP_WHITELIST_THRESHOLD = 2
MFA_CODE_EXPIRY_MINUTES = 20
TEMP_SESSION_TOKEN_EXPIRY_MINUTES = 30
INACTIVE_ACCOUNT_DAYS = 60
MFA_CODE_LENGTH = 6/services/policy_eval.py
from typing import Dict, List, Optional, Tuple, Any
from sqlalchemy.orm import Session, Query
from fastapi import HTTPException
import logging
from ..models import ABACPolicy, User, Role, Assets
from ..system_vars import sys_logger,debugging
from ..services.logger_queue import enqueue_log
from ..schemas.main import  ActionType, LogLevel

logger = logging.getLogger(__name__)

def get_user_perms(db: Session, id: Optional[str] = None, user: Optional[User] = None):
    def get_u_p(user: User):
        role_perms = db.query(Role).filter(Role.id == user.role_id).first()
        
        if not role_perms:
            raise HTTPException(status_code=404, detail="Not Assigned role")

        rperm = role_perms.permissions or []
        aperm = user.assigned_perms or []
        perms = list(set(rperm) | set(aperm))
        perms = sorted(perms)
        return perms
    
    if user:
        return get_u_p(user)
    
    user = db.query(User).filter(User.id == id).first()
    return get_u_p(user)

def get_default_scope(user: User) -> Dict:
    default_scope = {
        "departments": [user.department_id],
        "geographic": [],
        "asset_categories": [],
        "value_limits": {}
    }
        #will expland for asset val and cat--future
    if user.location and isinstance(user.location, dict):
        admin_loc = user.location.get("administrative_location", {})
        if admin_loc.get("county"):
            county_name = admin_loc["county"].lower().replace(" ", "_")
            default_scope["geographic"] = [county_name]
    
    return default_scope

# def get_merged_scope(user: User) -> Dict:
#     default = get_default_scope(user)
    
#     if not user.access_scope:
#         return default
    
#     merged = default.copy()
#     for key, value in user.access_scope.items():
#         if key in merged:
#             merged[key] = value
    
#     return merged
import json
def get_merged_scope(user: User) -> dict:
    default = get_default_scope(user)
    if not user.access_scope:
        return default

    scope_data = user.access_scope
    if isinstance(scope_data, str):
        scope_data = json.loads(scope_data)  # convert JSON string  dict

    merged = default.copy()
    for key, value in scope_data.items():
        if key in merged:
            merged[key] = value
    return merged

def check_role_permission(user, action: str) -> Tuple[bool, str]:
    """1.check in (role + assigned) perms has the required perm

    Args:
        user (User): user obj
        action (str): fomat 'resource.action'

    Returns:
        Tuple[bool, str]: str for description
    """
    if not user.role:
        return False, "User has no role assigned" 
    
    r_perms = user.role.permissions or []
    assigned_perms = user.assigned_perms or []
    all_perms = list(set(r_perms) | set(assigned_perms))
    
    if action in all_perms:
        return True, "Permission granted by role or assigned permissions"
    if  "*.*" in r_perms:
        return True, "Permission granted by role or assigned permissions"
        
    
    return False, f"Action '{action}' not permitted"

def check_access_scope(user, resource: Optional[Dict] = None, action: str = None) -> Tuple[bool, str]:
    """ 2: Check user's access scope"""
    if not resource:
        return True, "No resource to check scope against"
    
    scope = get_merged_scope(user)

    if resource.get("department") and resource["department"] != user.department_id:
        allowed_deps = scope.get("departments", [])
        if allowed_deps and "*" not in allowed_deps:
            if resource["department"] not in allowed_deps:
                return False, f"Department access denied: {resource['department']}"
    # Geo
    if resource.get("county"):
        allowed_counties = scope.get("geographic", [])
        if allowed_counties:
            resource_county = resource["county"].lower().replace(" ", "_")
            if resource_county not in allowed_counties:
                return False, f"Geographic access denied for county: {resource['county']}"
    
    if resource.get("category"):
        allowed_categories = scope.get("asset_categories", [])
        if allowed_categories and "*" not in allowed_categories:
            if resource["category"] not in allowed_categories:
                return False, f"Asset category access denied: {resource['category']}"
    
    if resource.get("value"):
        value_limits = scope.get("value_limits", {})
        
        if action and "create" in action:
            threshold = value_limits.get("creation_threshold")
            if threshold and resource["value"] > threshold:
                return False, f"Value {resource['value']} exceeds creation threshold {threshold}"
        
        if action and "approve" in action:
            threshold = value_limits.get("approval_threshold")
            if threshold and resource["value"] > threshold:
                return False, f"Value {resource['value']} exceeds approval threshold {threshold}"
    
    return True, "Within access scope"

def matches_user_attributes(user, policy_user_attrs: Dict) -> bool:
    """Check if user matches the policy's user attribute requirements"""
    for attr_name, required_value in policy_user_attrs.items():
        if hasattr(user, attr_name):
            user_value = getattr(user, attr_name)
        else:
            # Computed attributes
            if attr_name == "is_accounting_officer":
                user_value = user.is_accounting_officer
            elif attr_name == "roles":
                user_value = [user.role.name] if user.role else []
            elif attr_name == "position_title":
                user_value = user.position_title
            else:
                return False 
        
        # Compare values
        if isinstance(required_value, list):
            if isinstance(user_value, list):
                if not any(val in required_value for val in user_value):
                    return False
            else:
                if user_value not in required_value:
                    return False
        else:
            if user_value != required_value:
                return False
    
    return True

def matches_resource_attributes(resource: Optional[Dict], policy_resource_attrs: Dict) -> bool:
    """Check if resource matches the policy's resource attribute requirements"""
    if not resource:
        return not policy_resource_attrs
    
    for attr_name, required_value in policy_resource_attrs.items():
        if attr_name not in resource:
            return False
        
        resource_value = resource[attr_name]
        
        # Handle comparison operators
        if isinstance(required_value, dict):
            for operator, threshold in required_value.items():
                if operator == ">=" and resource_value < threshold:
                    return False
                elif operator == "<=" and resource_value > threshold:
                    return False
                elif operator == ">" and resource_value <= threshold:
                    return False
                elif operator == "<" and resource_value >= threshold:
                    return False
                elif operator == "==" and resource_value != threshold:
                    return False
        elif isinstance(required_value, list):
            if resource_value not in required_value:
                return False
        else:
            if resource_value != required_value:
                return False
    
    return True

def evaluate_abac_policies(user, action: str, resource: Optional[Dict], db: Session) -> Tuple[str, Optional[str]]:
    applicable_policies = (
        db.query(ABACPolicy).filter(

            ABACPolicy.is_active == True,
            ABACPolicy.action_names.contains([action]) 
        ).order_by(ABACPolicy.priority.desc()).all()
    )
    
    deny_policies = []
    allow_policies = []
    
    for policy in applicable_policies:
        if not matches_user_attributes(user, policy.user_attributes):
            continue
        
        if not matches_resource_attributes(resource, policy.resource_attributes):
            continue
            
        if policy.effect.value == "DENY":
            deny_policies.append(policy)
        else:
            allow_policies.append(policy)
    
    # DENY policies override ALLOW policies
    if deny_policies:
        policy = deny_policies[0]  # Highest priority deny
        logger.warning(f"DENY policy {policy.id} matched for user {user.id}, action {action}")
        return "DENY", f"Policy denied: {policy.description}"
    
    if allow_policies:
        policy = allow_policies[0]  # Highest priority allow
        logger.info(f"ALLOW policy {policy.id} matched for user {user.id}, action {action}")
        return "ALLOW", f"Policy allowed: {policy.description}"

    return "ALLOW", "No policy restrictions"

def check_full_permission(user, resource_type: str, action: str, db: Session,
                      resource: Optional[Dict] = None) -> bool:
    """Main checker that combines all three layers"""
    full_action = f"{resource_type}.{action}"
    

    # Layer 1: Role-based permission check
    role_allowed, role_reason = check_role_permission(user, full_action)
    if not role_allowed:
        logger.warning(f"RBAC denied for user {user.id}: {role_reason}")
        raise HTTPException(
            status_code=403, 
            detail=f"Access denied - Role: {role_reason}"
        )
 
    # Layer 2: Access scope check
    scope_allowed, scope_reason = check_access_scope(user, resource, full_action)
    if not scope_allowed:
        logger.warning(f"Scope denied for user {user.id}: {scope_reason}")
        raise HTTPException(
            status_code=403, 
            detail=f"Access denied - Scope: {scope_reason}"
        )
    
    # Layer 3: ABAC policy evaluation
    policy_effect, policy_reason = evaluate_abac_policies(user, full_action, resource, db)
    if policy_effect == "DENY":
        logger.warning(f"Policy denied for user {user.id}: {policy_reason}")
        raise HTTPException(
            status_code=403, 
            detail=f"Access denied - Policy: {policy_reason}"
        )
    
    logger.info(f"Permission granted for user {user.id}, action {full_action}")
    return True
#----------------------------------------------------      
    # except HTTPException:
    #     raise 
    # except Exception as e:
    #     logger.error(f"Error checking permissions for user {user.id}: {str(e)}")
    #     raise HTTPException(
    #         status_code=500, 
    #         detail=f"Internal error during permission check :  {str(e)}"
    #     )

def check_simple_permission(user, resource_type: str, action: str) -> bool:
    full_action = f"{resource_type}.{action}"
    role_allowed, _ = check_role_permission(user, full_action)
    return role_allowed

def apply_scope_filter(db: Session, query: Query, user: User, resource_type: str) -> Query:
    scope = get_merged_scope(user)
    
    if resource_type == "asset":
        # Department filtering - skip if user can access all departments
        allowed_deps = scope.get("departments", [])
        if allowed_deps and "*" not in allowed_deps:
            query = query.filter(Assets.department_id.in_(allowed_deps))
        
        # Geo filtering
        allowed_counties = scope.get("geographic", [])
        if allowed_counties:
            county_filters = []
            for county in allowed_counties:
                county_filter = Assets.location.op('->>')('county_name').ilike(f'%{county}%')
                county_filters.append(county_filter)
            if county_filters:
                query = query.filter(db.or_(*county_filters))
        
        # Category filtering
        allowed_categories = scope.get("asset_categories", [])
        if allowed_categories and "*" not in allowed_categories:
            query = query.filter(Assets.category.in_(allowed_categories))
    
    return query

def build_asset_resource(asset: Assets) -> Dict:
    """Build resource dictionary for asset operations"""
    resource = {
        "category": asset.category.value if asset.category else None,
        "department": asset.department_id,
        "value": float(asset.current_value or asset.acquisition_cost or 0),
        "status": asset.status.value if asset.status else None
    }
    
    # Extract county from asset location
    if asset.location and isinstance(asset.location, dict):
        county_name = asset.location.get("county_name")
        if county_name:
            resource["county"] = county_name.lower().replace(" ", "_")
    
    return resource

def checkif_accounting_officer(user) -> bool:
    """Check if user is accounting officer"""
    if not user.is_accounting_officer:
        raise HTTPException(
            status_code=403, 
            detail="This action requires an Accounting Officer"
        )
    return True

def require_specific_role(user, required_roles: List[str]) -> Tuple[bool, str]:
    """Check if user has one of the specified roles, check only name of role"""
    if not user.role or user.role.name not in required_roles:
        detail = (f"This action requires one of these roles: {', '.join(required_roles)}" if debugging else f"not enough permissions")
        return False, detail
    return True ,f"allowed"/services/location_service.py
import json
import os
from typing import List, Optional
from fastapi import HTTPException
import requests
from ..schemas.location import *

class LocationService:
    def __init__(self):
        self.counties_data = self._load_counties_data()
    
    def _load_counties_data(self) -> List[County]:
        fpath = os.path.join(os.path.dirname(__file__),"counties.json")
       
        try:
            with open(fpath, "r", encoding="utf-8") as file:
                data = json.load(file)
                return [County(**county) for county in data]
        except FileNotFoundError:
            raise HTTPException(status_code=500, detail="Counties data file not found")
        except json.JSONDecodeError:
            raise HTTPException(status_code=500, detail="Counties Datafile invalid")
    
    def get_all_counties(self) -> List[CountySimple]:
        return [
            CountySimple(county_code=county.county_code, county_name=county.county_name)
            for county in self.counties_data
        ]
    
    def get_county_by_id_or_name(self, identifier: str) -> Optional[County]:
        try:
            county_id = int(identifier)
            for county in self.counties_data:
                if county.county_code == county_id:
                    return county
        except ValueError: #not int
            identifier_lower = identifier.lower().strip()
            for county in self.counties_data:
                if county.county_name.lower() == identifier_lower:
                    return county
        return None
    
    def get_constituencies(self, county_identifier: str) -> Dict:
        county = self.get_county_by_id_or_name(county_identifier)
        if not county:
            raise HTTPException(status_code=404, detail="County not found")
        
        return {
            "county_code": county.county_code,
            "county_name": county.county_name,
            "constituencies": [
                ConstituencySimple(constituency_name=const.constituency_name)
                for const in county.constituencies
            ]
        }
    
    def get_wards(self, county_identifier: str, constituency_name: str) -> WardResponse:
        county = self.get_county_by_id_or_name(county_identifier)
        if not county:
            raise HTTPException(status_code=404, detail="County not found")
        
        constituency_lower = constituency_name.lower().strip()
        for const in county.constituencies:
            if const.constituency_name.lower() == constituency_lower:
                return WardResponse(
                    county_name=county.county_name,
                    constituency_name=const.constituency_name,
                    wards=const.wards
                )
        
        raise HTTPException(status_code=404, detail="Constituency not found")
    
    def get_county_tree(self, county_identifier: str) -> County:
        county = self.get_county_by_id_or_name(county_identifier)
        if not county:
            raise HTTPException(status_code=404, detail="County not found")
        return county
    
    def search_locations(self, query: str) -> SearchResult:
        if not query or len(query.strip()) < 2:
            return SearchResult()
        
        query_lower = query.lower().strip()
        result = SearchResult()
        
        for county in self.counties_data:
            # counties
            if query_lower in county.county_name.lower():
                result.counties.append(
                    CountySimple(county_code=county.county_code, county_name=county.county_name)
                )
            # situency
            for const in county.constituencies:
                if query_lower in const.constituency_name.lower():
                    result.constituencies.append({
                        "constituency_name": const.constituency_name,
                        "county_name": county.county_name,
                        "county_code": county.county_code
                    })
                
                # ma word
                for ward in const.wards:
                    if query_lower in ward.lower():
                        result.wards.append({
                            "ward_name": ward,
                            "constituency_name": const.constituency_name,
                            "county_name": county.county_name,
                            "county_code": county.county_code
                        })
        
        return result
    
    async def reverse_geocode(self, lat: float, lng: float) -> LocationDetails:
        try:
            url = f"https://nominatim.openstreetmap.org/reverse"
            params = {
                "format": "json",
                "lat": lat,
                "lon": lng,
                "addressdetails": 1,
                "accept-language": "en"
            }
            headers = {"User-Agent": "AssetManagementApp/v1.0"}
            
            response = requests.get(url, params=params, headers=headers, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
     
            address = data.get("display_name", "")
            
            administrative = self._match_administrative_location(data.get("address", {}))
            
            return LocationDetails(
                coordinates=Coordinates(lat=lat, lng=lng),
                address=address,
                administrative=administrative
            )
            
        except requests.RequestException:
            return LocationDetails(
                coordinates=Coordinates(lat=lat, lng=lng),
                administrative=AdministrativeLocation()
            )
    
    async def forward_geocode(self, address: str) -> List[LocationDetails]:
        """Get coordinates from address/place name"""
        try:
            url = "https://nominatim.openstreetmap.org/search"
            params = {
                "format": "json",
                "q": f"{address}, Kenya",
                "limit": 5,
                "addressdetails": 1,
                "accept-language": "en"
            }
            headers = {"User-Agent": "AssetManagementApp/1.0"}
            
            response = requests.get(url, params=params, headers=headers, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            results = []
            
            for item in data:
                lat = float(item.get("lat", 0))
                lng = float(item.get("lon", 0))
                
                administrative = self._match_administrative_location(item.get("address", {}))
                
                results.append(LocationDetails(
                    coordinates=Coordinates(lat=lat, lng=lng),
                    address=item.get("display_name", ""),
                    administrative=administrative
                ))
            
            return results
            
        except requests.RequestException:
            raise HTTPException(status_code=503, detail="Geocoding service unavailable")
    
    def _match_administrative_location(self, address_data: dict) -> AdministrativeLocation:
        """Try to match OSM address data with Kenya administrative boundaries"""
        # Extract potential county/region names from OSM data
        potential_county = (
            address_data.get("county") or 
            address_data.get("state") or 
            address_data.get("region") or ""
        ).strip()
        
        matched_county = None
        matched_constituency = None
        matched_ward = None
        
        if potential_county:
            for county in self.counties_data:
                if county.county_name.lower() in potential_county.lower() or potential_county.lower() in county.county_name.lower():
                    matched_county = county.county_name
                    break
        
        if matched_county:
            county = next((c for c in self.counties_data if c.county_name == matched_county), None)
            if county: # try to match other compontents
                location_components = [
                    address_data.get("suburb", ""),
                    address_data.get("village", ""),
                    address_data.get("town", ""),
                    address_data.get("city_district", ""),
                    address_data.get("neighbourhood", "")
                ]
                
                for component in location_components:
                    if not component:
                        continue
                    
                    component_lower = component.lower()
                    
                    for const in county.constituencies:
                        if const.constituency_name.lower() in component_lower or component_lower in const.constituency_name.lower():
                            matched_constituency = const.constituency_name
                            
                           
                            for ward in const.wards: # Try to match ward within curr constituency
                                if ward.lower() in component_lower or component_lower in ward.lower():
                                    matched_ward = ward
                                    break
                            break
                    
                    if matched_constituency:
                        break
        
        return AdministrativeLocation(
            county=matched_county,
            constituency=matched_constituency,
            ward=matched_ward)/services/logger_queue.py
import asyncio
import time
from typing import List, Optional
from contextlib import asynccontextmanager
from sqlalchemy.orm import Session
from fastapi import FastAPI

from ..models import ActivityLog
from ..database import SessionLocal
from ..schemas.main import LogLevel, ActionType

# Global variables
log_buffer: List[dict] = []
buffer_lock = asyncio.Lock()
BATCH_SIZE = 50
MAX_WAIT = 5.0  # 5 seconds
_background_task: Optional[asyncio.Task] = None
_shutdown_event = asyncio.Event()

class LoggingService:
    def __init__(self):
        self.buffer: List[dict] = []
        self.last_flush = time.time()
        self.lock = asyncio.Lock()
        self.running = True
        
    async def enqueue_log(
        self,
        user_id, 
        action: ActionType, 
        target_table=None, 
        target_id=None, 
        details=None, 
        level: LogLevel = LogLevel.INFO
    ):
        """Add log entry to buffer"""
        log_data = {
            "user_id": str(user_id) if user_id else None,
            "action": action.value,
            "target_table": target_table,
            "target_id": target_id,
            "log_level": level.value,
            "details": details,
            "created_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        async with self.lock:
            self.buffer.append(log_data)
            
            # Check if we should flush immediately
            if len(self.buffer) >= BATCH_SIZE:
                await self._flush_buffer()
    
    async def _flush_buffer(self):
        """Internal method to flush buffer to database"""
        if not self.buffer:
            return
            
        buffer_copy = self.buffer.copy()
        self.buffer.clear()
        self.last_flush = time.time()
        
        # Run database operation in thread pool to avoid blocking
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, self._flush_to_db_sync, buffer_copy)
    
    def _flush_to_db_sync(self, buffer: List[dict]):
        """Synchronous database flush (runs in thread pool)"""
        if not buffer:
            return
            
        db: Session = SessionLocal()
        try:
            # Convert string values back to enums for database insertion
            for log_entry in buffer:
                log_entry["action"] = ActionType(log_entry["action"])
                log_entry["log_level"] = LogLevel(log_entry["log_level"])
                
            db.bulk_insert_mappings(ActivityLog, buffer)
            db.commit()
            print(f" Inserted {len(buffer)} logs to database")
        except Exception as e:
            db.rollback()
            print(f" Error inserting logs to database: {e}")
        finally:
            db.close()
    
    async def background_flush_task(self):
        """Background task that flushes buffer periodically"""
        print(" Background logging task started")
        
        while self.running:
            try:
                await asyncio.sleep(1)  # Check every second
                
                current_time = time.time()
                async with self.lock:
                    # Flush if we have logs and enough time has passed
                    if self.buffer and (current_time - self.last_flush >= MAX_WAIT):
                        await self._flush_buffer()
                        
            except asyncio.CancelledError:
                print(" Background logging task cancelled")
                break
            except Exception as e:
                print(f" Error in background flush task: {e}")
                await asyncio.sleep(1)
        
        # Final flush on shutdown
        async with self.lock:
            if self.buffer:
                print(" Final flush on shutdown...")
                await self._flush_buffer()
        
        print(" Background logging task completed")
    
    async def shutdown(self):
        """Graceful shutdown"""
        self.running = False

# Global logging service instance
logging_service = LoggingService()

# Public API functions
async def enqueue_log(
    user_id, 
    action: ActionType, 
    target_table=None, 
    target_id=None, 
    details=None, 
    level: LogLevel = LogLevel.INFO
):
    """Public function to enqueue a log entry"""
    await logging_service.enqueue_log(
        user_id, action, target_table, target_id, details, level
    )

# FastAPI Lifespan Context Manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    """FastAPI lifespan context manager for startup/shutdown"""
    # Startup
    print(" Starting logging service...")
    background_task = asyncio.create_task(logging_service.background_flush_task())
    
    yield  # Application runs here
    
    # Shutdown
    print(" Shutting down logging service...")
    await logging_service.shutdown()
    background_task.cancel()
    
    try:
        await background_task
    except asyncio.CancelledError:
        pass
    
    print(" Logging service shutdown complete")

# Alternative: If you prefer the old @app.on_event style
def setup_background_logging(app: FastAPI):
    """Alternative setup function for older FastAPI versions"""
    global _background_task
    
    @app.on_event("startup")
    async def startup_event():
        global _background_task
        print(" Starting background logging...")
        _background_task = asyncio.create_task(logging_service.background_flush_task())
    
    @app.on_event("shutdown")
    async def shutdown_event():
        global _background_task
        print(" Shutting down background logging...")
        await logging_service.shutdown()
        
        if _background_task:
            _background_task.cancel()
            try:
                await _background_task
            except asyncio.CancelledError:
                pass
        
        print(" Background logging shutdown complete")

/services/__init__.py
/services/emailsender.py
from sib_api_v3_sdk import TransactionalEmailsApi, SendSmtpEmail
from sib_api_v3_sdk.rest import ApiException
import sib_api_v3_sdk
from typing import Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AssetFlowEmailService:
    def __init__(self, api_key: str):
        """Initialize the email service with Sendinblue API key"""
        self.configuration = sib_api_v3_sdk.Configuration()
        self.configuration.api_key['api-key'] = api_key
        self.api_instance = TransactionalEmailsApi(sib_api_v3_sdk.ApiClient(self.configuration))
        self.sender = {
            "name": "AssetFlow System", 
            "email": "musauem98@gmail.com"
        }
    
    def send_account_created_email(self, user_email: str, username: str) -> bool:
        """Send account creation notification email"""
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Welcome to AssetFlow</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f4f4f4;">
            <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff;">
                <!-- Header -->
                <div style="background-color: #2563eb; padding: 20px; text-align: center;">
                    <img src="https://res.cloudinary.com/duboyr09q/image/upload/v1753869958/logo_niwpon.png" alt="AssetFlow Logo" style="max-height: 50px;">
                </div>
                
                <!-- Content -->
                <div style="padding: 40px 30px;">
                    <h1 style="color: #333333; font-size: 28px; margin-bottom: 20px; text-align: center;">
                        Welcome to AssetFlow! 
                    </h1>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                        Hi <strong>{username}</strong>,
                    </p>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                        Great news! Your AssetFlow account has been successfully created and is now awaiting activation by our administrators.
                    </p>
                    
                    <div style="background-color: #f8fafc; border-left: 4px solid #2563eb; padding: 20px; margin: 30px 0;">
                        <h3 style="color: #2563eb; margin: 0 0 10px 0; font-size: 18px;">What's Next?</h3>
                        <p style="color: #666666; margin: 0; font-size: 14px; line-height: 1.5;">
                            Our team will review and activate your account shortly. Once activated, you'll receive another email confirmation, and you'll be able to:
                        </p>
                    </div>
                    
                    <ul style="color: #666666; font-size: 16px; line-height: 1.8; margin: 20px 0; padding-left: 20px;">
                        <li>Book chairs, rooms, and projectors</li>
                        <li>Manage your equipment reservations</li>
                        <li>Access our full range of facility assets</li>
                        <li>Track your booking history</li>
                    </ul>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 30px;">
                        If you have any questions while waiting for activation, feel free to contact our support team.
                    </p>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <p style="color: #999999; font-size: 14px; margin: 0;">
                            Thank you for choosing AssetFlow for your equipment booking needs!
                        </p>
                    </div>
                </div>
                
                <!-- Footer -->
                <div style="background-color: #f8fafc; padding: 20px; text-align: center; border-top: 1px solid #e5e7eb;">
                    <p style="color: #999999; font-size: 12px; margin: 0;">
                         2025 AssetFlow. All rights reserved.<br>
                        This email was sent to {user_email}
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        email = SendSmtpEmail(
            to=[{"email": user_email}],
            sender=self.sender,
            subject="Welcome to AssetFlow - Account Created Successfully!",
            html_content=html_content
        )
        
        return self._send_email(email)
    
    def send_account_activated_email(self, user_email: str, username: str) -> bool:
        """Send account activation confirmation email"""
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>AssetFlow Account Activated</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f4f4f4;">
            <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff;">
                <!-- Header -->
                <div style="background-color: #059669; padding: 20px; text-align: center;">
                    <img src="https://res.cloudinary.com/duboyr09q/image/upload/v1753869958/logo_niwpon.png" alt="AssetFlow Logo" style="max-height: 50px;">
                </div>
                
                <!-- Content -->
                <div style="padding: 40px 30px;">
                    <h1 style="color: #333333; font-size: 28px; margin-bottom: 20px; text-align: center;">
                        Your Account is Now Active! 
                    </h1>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                        Hi <strong>{username}</strong>,
                    </p>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                        Excellent news! Your AssetFlow account has been successfully activated by our administrators. You can now start booking equipment and managing your reservations.
                    </p>
                    
                    <div style="background-color: #ecfdf5; border-left: 4px solid #059669; padding: 20px; margin: 30px 0;">
                        <h3 style="color: #059669; margin: 0 0 10px 0; font-size: 18px;">You Can Now:</h3>
                        <ul style="color: #666666; margin: 10px 0 0 0; font-size: 14px; line-height: 1.5; padding-left: 20px;">
                            <li>Book chairs, meeting rooms, and projectors</li>
                            <li>View available equipment in real-time</li>
                            <li>Manage and modify your reservations</li>
                            <li>Access your booking history and reports</li>
                        </ul>
                    </div>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="localhost:5173/login" style="background-color: #059669; color: #ffffff; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold; display: inline-block;">
                            Login to AssetFlow
                        </a>
                    </div>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 30px;">
                        If you need any assistance getting started or have questions about using AssetFlow, our support team is here to help.
                    </p>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <p style="color: #999999; font-size: 14px; margin: 0;">
                            Ready to streamline your equipment booking experience!
                        </p>
                    </div>
                </div>
                
                <!-- Footer -->
                <div style="background-color: #f8fafc; padding: 20px; text-align: center; border-top: 1px solid #e5e7eb;">
                    <p style="color: #999999; font-size: 12px; margin: 0;">
                         2025 AssetFlow. All rights reserved.<br>
                        This email was sent to {user_email}
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        email = SendSmtpEmail(
            to=[{"email": user_email}],
            sender=self.sender,
            subject=" Your AssetFlow Account is Now Active!",
            html_content=html_content
        )
        
        return self._send_email(email)
    
    def send_password_reset_email(self, user_email: str, username: str, reset_token: str) -> bool:
        """Send password reset email with token"""
        
        reset_link = f"localhost:5173/password-reset?token={reset_token}"
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>AssetFlow Password Reset</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f4f4f4;">
            <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff;">
                <!-- Header -->
                <div style="background-color: #dc2626; padding: 20px; text-align: center;">
                    <img src="https://res.cloudinary.com/duboyr09q/image/upload/v1753869958/logo_niwpon.png" alt="AssetFlow Logo" style="max-height: 50px;">
                </div>
                
                <!-- Content -->
                <div style="padding: 40px 30px;">
                    <h1 style="color: #333333; font-size: 28px; margin-bottom: 20px; text-align: center;">
                        Password Reset Request 
                    </h1>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                        Hi <strong>{username}</strong>,
                    </p>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
                        We received a request to reset the password for your AssetFlow account. If you made this request, click the button below to reset your password.
                    </p>
                    
                    <div style="background-color: #fef2f2; border-left: 4px solid #dc2626; padding: 20px; margin: 30px 0;">
                        <h3 style="color: #dc2626; margin: 0 0 10px 0; font-size: 18px;">Important Security Information:</h3>
                        <ul style="color: #666666; margin: 10px 0 0 0; font-size: 14px; line-height: 1.5; padding-left: 20px;">
                            <li>This reset link will expire in 24 hours</li>
                            <li>If you didn't request this reset, please ignore this email</li>
                            <li>Your password will remain unchanged until you create a new one</li>
                        </ul>
                    </div>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="{reset_link}" style="background-color: #dc2626; color: #ffffff; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold; display: inline-block;">
                            Reset My Password
                        </a>
                    </div>
                    
                    <p style="color: #666666; font-size: 14px; line-height: 1.6; margin-bottom: 20px;">
                        If the button doesn't work, copy and paste this link into your browser:
                    </p>
                    
                    <div style="background-color: #f8fafc; border: 1px solid #e5e7eb; border-radius: 5px; padding: 15px; margin: 20px 0; word-break: break-all;">
                        <code style="color: #374151; font-size: 14px;">{reset_link}</code>
                    </div>
                    
                    <p style="color: #666666; font-size: 16px; line-height: 1.6; margin-bottom: 30px;">
                        If you continue to have problems, please contact our support team for assistance.
                    </p>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <p style="color: #999999; font-size: 14px; margin: 0;">
                            Stay secure with AssetFlow!
                        </p>
                    </div>
                </div>
                
                <!-- Footer -->
                <div style="background-color: #f8fafc; padding: 20px; text-align: center; border-top: 1px solid #e5e7eb;">
                    <p style="color: #999999; font-size: 12px; margin: 0;">
                         2025 AssetFlow. All rights reserved.<br>
                        This email was sent to {user_email}<br>
                        For security reasons, this email was automatically generated.
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
        
        email = SendSmtpEmail(
            to=[{"email": user_email}],
            sender=self.sender,
            subject="AssetFlow - Reset Your Password",
            html_content=html_content
        )
        
        return self._send_email(email)

    def send_mfa_code_email(self, user_email: str, username: str, mfa_code: str, expiry_minutes: int):
        subject = "Your MFA Code"
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>Your MFA code is: <strong>{mfa_code}</strong></p>
                <p>This code will expire in {expiry_minutes} minutes.</p>
                <p>If you did not request this code, please contact support immediately.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_new_device_login_notification(self, user_email: str, username: str, ip_address: str, device_info: dict):
        subject = "New Device Login Detected"
        device_str = device_info.get('user_agent', 'Unknown device')
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>A new device has logged into your account.</p>
                <p><strong>IP Address:</strong> {ip_address}</p>
                <p><strong>Device:</strong> {device_str}</p>
                <p>If this wasn't you, please reset your password immediately and contact support.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_account_temp_disabled_email(self, user_email: str, username: str, hours: int):
        subject = "Account Temporarily Disabled"
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>Your account has been temporarily disabled due to too many failed login attempts.</p>
                <p>Your account will be automatically reactivated in {hours} hours.</p>
                <p>If you did not attempt to login, please contact support immediately.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_account_suspended_email(self, user_email: str, username: str):
        subject = "Account Suspended"
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>Your account has been suspended due to suspicious activity or too many failed login attempts.</p>
                <p>Please contact support to reactivate your account.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_suspicious_login_blocked_email(self, user_email: str, username: str, ip_address: str, reason: str):
        subject = "Suspicious Login Blocked"
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>A suspicious login attempt to your account was blocked.</p>
                <p><strong>IP Address:</strong> {ip_address}</p>
                <p><strong>Reason:</strong> {reason}</p>
                <p>Your account has been temporarily disabled for security. If this was you, please contact support.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_timezone_mismatch_email(self, user_email: str, username: str, timezone: str, ip_address: str, device_info: dict, unlock_token: str):
        subject = "Login from Unexpected Timezone Detected"
        device_str = device_info.get('user_agent', 'Unknown device')
        unlock_url = f"https://your-domain.com/auth/unlock?token={unlock_token}"
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>A login attempt was detected from an unexpected timezone.</p>
                <p><strong>Timezone:</strong> {timezone}</p>
                <p><strong>IP Address:</strong> {ip_address}</p>
                <p><strong>Device:</strong> {device_str}</p>
                <p>If this was you, click the link below to unlock your account:</p>
                <p><a href="{unlock_url}">Unlock My Account</a></p>
                <p>If this wasn't you, please contact support immediately.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_out_of_hours_login_notification(self, user_email: str, username: str, ip_address: str, device_info: dict):
        subject = "Out of Hours Login Detected"
        device_str = device_info.get('user_agent', 'Unknown device')
        html_content = f"""
        <html>
            <body>
                <h2>Hello {username},</h2>
                <p>A login to your account was detected outside of normal working hours.</p>
                <p><strong>IP Address:</strong> {ip_address}</p>
                <p><strong>Device:</strong> {device_str}</p>
                <p>If this wasn't you, please contact support immediately.</p>
            </body>
        </html>
        """
        return self.send_email(user_email, subject, html_content)

    def send_out_of_hours_login_notification_admin(self, adm_email: str, admin_name: str, user_email: str, ip_address: str, device_info: dict):
        subject = "Out of Hours Login Alert"
        device_str = device_info.get('user_agent', 'Unknown device')
        html_content = f"""
        <html>
            <body>
                <h2>Hello {admin_name},</h2>
                <p>An out of hours login was detected for user: <strong>{user_email}</strong></p>
                <p><strong>IP Address:</strong> {ip_address}</p>
                <p><strong>Device:</strong> {device_str}</p>
                <p>Please review this activity if necessary.</p>
            </body>
        </html>
        """
        return self.send_email(adm_email, subject, html_content)




    def _send_email(self, email: SendSmtpEmail) -> bool:
        """Helper method to send email and handle exceptions"""
        try:
            response = self.api_instance.send_transac_email(email)
            logger.info(f"Email sent successfully: {response}")
            return True
        except ApiException as e:
            logger.error(f"Failed to send email: {e}")
            return False/main.py
from fastapi import FastAPI
from .database import  engine
from . import models
from .services.logger_queue import setup_background_logging
from .system_vars import sys_logger

from .routers import a_crude, auth,roles,users,departments,location,a_transfer,a_supp_routes,a_lifecycle,a_tracking,a_assignment,a_maintainance,a_disposal
from .routers.reports import assets_r,complience_r,departments_r,exec_r,maintainance_r,reports,sec_r,transdispo_r,utils_r
from fastapi.middleware.cors import CORSMiddleware

from .routers import other_supp_routes,auth22



app = FastAPI()

if sys_logger:
    setup_background_logging(app)
 
models.Base.metadata.create_all(bind=engine)


origins = [
    "http://localhost:8080",
    "http://localhost:5173"
] # also mig

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
) # migrate to sys vars
'''
td:
 - load counties in memory during startup

'''
app.include_router(roles.router)
app.include_router(users.router)
app.include_router(auth.router)
app.include_router(auth22.router)

app.include_router(location.router)
app.include_router(departments.router)

app.include_router(a_crude.router)
app.include_router(other_supp_routes.router)
app.include_router(a_supp_routes.router)
app.include_router(a_lifecycle.router)
app.include_router(a_tracking.router)
app.include_router(a_assignment.router)
app.include_router(a_transfer.router)

app.include_router(a_maintainance.router)
app.include_router(a_disposal.router)

app.include_router(utils_r.router)
app.include_router(reports.router)
app.include_router(assets_r.router)
app.include_router(departments_r.router)
app.include_router(maintainance_r.router)
app.include_router(transdispo_r.router)
app.include_router(exec_r.router)
app.include_router(complience_r.router)
app.include_router(sec_r.router)